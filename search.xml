<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>将本地仓库同时和gitee和GitHub关联起来</title>
    <url>/2020/03/10/git02/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/poloyy/p/12215199.html" target="_blank" rel="noopener">参考这篇文章</a></p>
<h3 id="gitee拉取GitHub"><a href="#gitee拉取GitHub" class="headerlink" title="gitee拉取GitHub"></a>gitee拉取GitHub</h3><p>直接在Gitee中创建一个项目，然后在最后一行的“导入已有仓库”一栏中复制已有的GitHub仓库就可以了。<br>需要注意的是，<b>复制的仓库地址是https链接而不是SSH格式</b></p>
<p>这样的话就已经创建好了仓库</p>
<a id="more"></a>
<h3 id="本地配置推送方式"><a href="#本地配置推送方式" class="headerlink" title="本地配置推送方式"></a>本地配置推送方式</h3><ul>
<li>方式一：定义不同的远程仓库名称，然后分别推送 多次推送，配了几个远程仓库就推送几次 </li>
<li>方式二：在同一个远程仓库下添加另一个远程仓库的地址，然后推送 only一次推送 </li>
</ul>
<h4 id="本地只有单个ssh-key时的包"><a href="#本地只有单个ssh-key时的包" class="headerlink" title="本地只有单个ssh-key时的包"></a>本地只有单个ssh-key时的包</h4><h5 id="方式一：多次推送"><a href="#方式一：多次推送" class="headerlink" title="方式一：多次推送"></a>方式一：多次推送</h5><ul>
<li>优点<ul>
<li>想推哪个仓库就推哪个</li>
<li>不想推就不推哪个</li>
</ul>
</li>
<li>缺点<ul>
<li>推送仓库数量多时，时间成本高</li>
</ul>
</li>
</ul>
<p><b>1.可以直接通过命令将本地项目和gitee项目关联</b></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee 码云项目地址</span></span><br></pre></td></tr></table></figure>
<p><b>2.也可以通过修改本地项目的配置文件</b><br>1、首先，进入项目的<code>.git</code>文件夹，打开<code>config</code>文件<br>2、然后找到<code>[remote &quot;origin&quot;]</code>，复制一份remote到下面，修改remote的名字和url即可</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   url = git<span class="variable">@github</span><span class="symbol">:jjjlk</span></span><br><span class="line">   fetch = jjlkjl</span><br></pre></td></tr></table></figure>
<p>为了避免冲突，将原始的remote名字也改掉，注意：remote的名字任意，但是提交的时候要和对应config文件里的remote对应名字相同。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">"github"</span>]</span><br><span class="line">   <span class="attr">url</span> = github地址</span><br><span class="line">   <span class="attr">fetch</span> = jjlkjl</span><br><span class="line"></span><br><span class="line">[remote <span class="string">"gitee"</span>]</span><br><span class="line">   <span class="attr">url</span> = gitee地址</span><br><span class="line">   <span class="attr">fetch</span> = jjlkjl</span><br></pre></td></tr></table></figure>
<p>3、执行以下命令，可以看到配置的两个仓库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure>
<p>4、推送代码时，需要对<code>两个仓库分别执行一次push命令</code>，也就是多次推送</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git push github <span class="literal">master</span></span><br><span class="line">git push gitee <span class="literal">master</span></span><br></pre></td></tr></table></figure>

<h5 id="方式二：一次推送"><a href="#方式二：一次推送" class="headerlink" title="方式二：一次推送"></a>方式二：一次推送</h5><p><b>通过命令将码云项目地址添加到本地已有的remote下</b></p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="built_in">--add</span> <span class="string">origin </span>码云项目地址</span><br></pre></td></tr></table></figure>
<p><b>2、也可以通过修改本地项目的配置文件</b><br>直接在项目的config文件下进行配置<br>在上述方式的</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   <span class="attr">url</span> = github地址</span><br><span class="line">   <span class="attr">url</span> = gitee地址</span><br><span class="line">   <span class="attr">fetch</span> = jaojisoajc</span><br></pre></td></tr></table></figure>
<p><b>推送代码只需执行以下一条命令即可</b></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<h5 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h5><p>git push的时候有时候会出现错误<code>[rejected] master -&gt; master(fetch first)</code>，<code>error: failed to push some refs to &#39;git@cinu&#39;</code></p>
<p>此时可以输入：<code>git push -f</code>进行解决错误，然后再：<code>git push</code></p>
<p>如果上述解决方式不管用也可以输入：<code>git pull --rebase origin master</code>之后再进行<code>git push</code>即可。</p>
<h4 id="当本地有多个ssh-key时"><a href="#当本地有多个ssh-key时" class="headerlink" title="当本地有多个ssh-key时"></a>当本地有多个ssh-key时</h4><p>如果想要配置多个ssh-key的话，可以参考<a href="https://www.cnblogs.com/poloyy/p/12189140.html" target="_blank" rel="noopener">文章1</a><a href="https://www.cnblogs.com/lambdaRan/p/11022857.html" target="_blank" rel="noopener">文章2</a></p>
<p>需要更改两个地方：<br><b>第一：公钥配置文件，目录是：<code>C:\User\.ssh</code>下的<code>config</code>文件</b><br>正常来说是一个ssh-key指向一个仓库即可，譬如第一个key的Host配成github的，第二个key的Host配成gitee</p>
<p><b>第二：需要修改在上面配置过的config文件，它在项目目录下的.git文件夹下</b><br>原本只有一个ssh-key时，配置文件可能是这样的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   url = git<span class="meta">@github</span>.<span class="string">com:</span>用户名/项目名.git</span><br><span class="line">   url = git<span class="meta">@gitee</span>.<span class="string">com:</span>用户名/项目名.git</span><br><span class="line">   fetch = hiohohuihohioih</span><br></pre></td></tr></table></figure>

<p>当有两个ssh-key时，配置文件需要改成</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   <span class="attr">url</span> = git@&#123;GitHub_HOST&#125;:用户名/项目名.git</span><br><span class="line">   <span class="attr">url</span> = git@&#123;Gittee_HOST&#125;:用户名/项目名.git</span><br><span class="line">   <span class="attr">fetch</span> = khdsuifchsdlifh</span><br></pre></td></tr></table></figure>
<p>最后将<code>Github_HOST</code>、<code>Gitee_HOST</code>替换成我们自己配置里面的Host地址</p>
<p>其余步骤都是一样的，需要强调的是，如果有多个ssh-key时，还得修改下配置文件。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果只需要把博客同时推送到两个远程仓库中，只需要在_config文件中添加如下代码：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  # <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:flysara/flysara.github.io.git</span><br><span class="line">  <span class="attribute">repository</span>: </span><br><span class="line">    <span class="attribute">gitee</span>: git<span class="variable">@gitee</span>.<span class="attribute">com</span>:luckyTeresa/luckyTeresa.git</span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:flysara/flysara.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

<p>然后在项目下大概GUI Bash，输入<code>git remote add gitee 码云地址</code>和<code>git remote add github GitHub地址</code>即可。推送的时候直接<code>hexo d</code>。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>本地仓库关联多个远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d遇到的“Repository not found”问题</title>
    <url>/2020/03/10/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A202/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>新建博文以后，更新上传，使用<code>hexo d</code>时，发现控制台报错，报错信息如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>Repository not found. </span><br><span class="line">fatal: Could not read from remote repository</span><br></pre></td></tr></table></figure>

<p>翻译过来就是不能找到远程仓库，我查看了其他的博文，都是重新配置生成公钥，可是我的公钥已经生成，并且也已经和远程仓库连接好了，所以就百思不得其解。最后终于找到了解决办法</p>
<a id="more"></a>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>首先来讲一些原理和规则吧：<br>git的两种上传方式：</p>
<ul>
<li>HTTPS</li>
<li>SSH<br>这两种方式的URL是不同的<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTTPS方式</span></span><br><span class="line"><span class="attribute">https</span>:<span class="comment">//github.com/xxxx/StudyEveryDay.git</span></span><br><span class="line"><span class="comment">// SSH方式</span></span><br><span class="line">git<span class="variable">@github</span>.<span class="attribute">com</span>:xxxx/StudyEveryDay.git</span><br></pre></td></tr></table></figure>
其中，我在该项目根目录下的_config文件中，对git的部署设置如下：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  # <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:flysara/flysara.github.io.git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//gitee.com/luckyTeresa/luckyTeresa.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要注意：</p>
<ul>
<li>上面的repository地址并不是仓库的地址，而是你下克隆项目时弹出的那个地址</li>
<li>如果使用git就选择SSH，如果选择HTTPS那么相应的type字段也要修改为https</li>
</ul>
<p>而我这次的错误和坑就是上面的第二点，我设置的type时git，但是我创建的仓库的链接地址确是使用的https的形式，所以没有办法跟远程仓库进行连接，从而出现了找不到远程仓库的错误。</p>
<p>了解了问题的原因以后，我修改的代码如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  # <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:flysara/flysara.github.io.git</span><br><span class="line">  <span class="attribute">repository</span>:  git<span class="variable">@gitee</span>.<span class="attribute">com</span>:luckyTeresa/luckyTeresa.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

<p>最后显示部署成功</p>
]]></content>
      <categories>
        <category>博客相关问题解决</category>
      </categories>
      <tags>
        <tag>博客遇到的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/07/vue3-12/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.Vuex概述<br>2.Vuex基本使用<br>3.使用Vuex完成todo案例</p>
<h3 id="1-Vuex概述"><a href="#1-Vuex概述" class="headerlink" title="1.Vuex概述"></a>1.Vuex概述</h3><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享</p>
<a id="more"></a>
<p>使用Vuex管理数据的好处：<br>A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护<br>B.能够高效的实现组件之间的数据共享，提高开发效率<br>C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新</p>
<h3 id="2-Vuex的基本使用"><a href="#2-Vuex的基本使用" class="headerlink" title="2.Vuex的基本使用"></a>2.Vuex的基本使用</h3><p>创建带有vuex的vue项目，打开终端，输入命令：vue ui<br>当项目仪表盘打开之后，我们点击页面左上角的项目管理下拉列表，再点击Vue项目管理器<br>点击创建项目，如下图所示<br>第一步，设置项目名称和包管理器<br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BAvuex%E9%A1%B9%E7%9B%AE01.png" alt=""><br>第二步，设置手动配置项目<br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BAvuex%E9%A1%B9%E7%9B%AE02.png" alt=""><br>第三步，设置功能项<br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BAvuex%E9%A1%B9%E7%9B%AE03.png" alt=""><br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BAvuex%E9%A1%B9%E7%9B%AE04%281%29.png" alt=""><br>第四步，创建项目<br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BAvuex%E9%A1%B9%E7%9B%AE05.png" alt=""></p>
<h3 id="3-使用Vuex完成计数器案例"><a href="#3-使用Vuex完成计数器案例" class="headerlink" title="3.使用Vuex完成计数器案例"></a>3.使用Vuex完成计数器案例</h3><p>打开刚刚创建的vuex项目，找到src目录中的App.vue组件，将代码重新编写如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-addition</span>&gt;</span><span class="tag">&lt;/<span class="name">my-addition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>----------------------------------------<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-subtraction</span>&gt;</span><span class="tag">&lt;/<span class="name">my-subtraction</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Addition <span class="keyword">from</span> <span class="string">'./components/Addition.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Subtraction <span class="keyword">from</span> <span class="string">'./components/Subtraction.vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="actionscript">    <span class="string">'my-subtraction'</span>: Subtraction,</span></span><br><span class="line"><span class="actionscript">    <span class="string">'my-addition'</span>: Addition</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在components文件夹中创建Addition.vue组件，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>当前最新的count值为：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在components文件夹中创建Subtraction.vue组件，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>当前最新的count值为：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后在项目根目录(与src平级)中创建 .prettierrc 文件，编写代码如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"semi"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Vuex中的核心特性"><a href="#4-Vuex中的核心特性" class="headerlink" title="4.Vuex中的核心特性"></a>4.Vuex中的核心特性</h3><h4 id="A-State"><a href="#A-State" class="headerlink" title="A.State"></a>A.State</h4><pre><code>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储
例如，打开项目中的store.js文件，在State对象中可以添加我们要共享的数据，如：count:0

在组件中访问State的方式：
1).this.$store.state.全局数据名称  如：this.$store.state.count
2).先按需导入mapState函数： import { mapState } from &apos;vuex&apos;
然后数据映射为计算属性： computed:{ ...mapState([&apos;全局数据名称&apos;]) }</code></pre><h4 id="B-Mutation"><a href="#B-Mutation" class="headerlink" title="B.Mutation"></a>B.Mutation</h4><p>Mutation用于修改变更$store中的数据<br>使用方式：<br>打开store.js文件，在mutations中添加代码如下</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    add(<span class="keyword">state</span>,step)&#123;</span><br><span class="line">      //第一个形参永远都是<span class="keyword">state</span>也就是<span class="variable">$state</span>对象</span><br><span class="line">      //第二个形参是调用add时传递的参数</span><br><span class="line">      <span class="keyword">state</span>.count+=step;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后在Addition.vue中给按钮添加事件代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="meta">@click</span>=<span class="string">"Add"</span>&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  Add()&#123;</span><br><span class="line">    <span class="comment">//使用commit函数调用mutations中的对应函数，</span></span><br><span class="line">    <span class="comment">//第一个参数就是我们要调用的mutations中的函数名</span></span><br><span class="line">    <span class="comment">//第二个参数就是传递给add函数的参数</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'add'</span>,<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用mutations的第二种方式：<br>import { mapMutations } from ‘vuex’</p>
<p>methods:{<br>  …mapMutations([‘add’])<br>}<br>如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">import &#123; mapState,mapMutations &#125; from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      //获得mapMutations映射的<span class="function"><span class="keyword">sub</span>函数</span></span><br><span class="line"><span class="function">      ...<span class="title">mapMutations</span>(['<span class="title">sub</span>']),</span></span><br><span class="line"><span class="function">      //当点击按钮时触发<span class="title">Sub</span>函数</span></span><br><span class="line"><span class="function">      <span class="title">Sub</span></span>()&#123;</span><br><span class="line">          //调用<span class="function"><span class="keyword">sub</span>函数完成对数据的操作</span></span><br><span class="line"><span class="function">          <span class="title">this</span>.<span class="title">sub</span></span>(10);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">      ...mapState([<span class="string">'count'</span>])</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="C-Action"><a href="#C-Action" class="headerlink" title="C.Action"></a>C.Action</h4><p>在mutations中不能编写异步的代码，会导致vue调试器的显示出错。<br>在vuex中我们可以使用Action来执行异步操作。<br>操作步骤如下：<br>打开store.js文件，修改Action，如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addAsync(context,step)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      context.commit(<span class="string">'add'</span>,step);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Addition.vue中给按钮添加事件代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="meta">@click</span>=<span class="string">"AddAsync"</span>&gt;...+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  AddAsync()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addAsync'</span>,<span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式：<br>import { mapActions } from ‘vuex’</p>
<p>methods:{<br>  …mapMutations([‘subAsync’])<br>}<br>如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapMutations,mapActions &#125; from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      <span class="comment">//获得mapMutations映射的sub函数</span></span><br><span class="line">      ...mapMutations([<span class="string">'sub'</span>]),</span><br><span class="line">      <span class="comment">//当点击按钮时触发Sub函数</span></span><br><span class="line">      Sub()&#123;</span><br><span class="line">          <span class="comment">//调用sub函数完成对数据的操作</span></span><br><span class="line">          <span class="keyword">this</span>.sub(<span class="number">10</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//获得mapActions映射的addAsync函数</span></span><br><span class="line">      ...mapActions([<span class="string">'subAsync'</span>]),</span><br><span class="line">      asyncSub()&#123;</span><br><span class="line">          <span class="keyword">this</span>.subAsync(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">      ...mapState([<span class="string">'count'</span>])</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="D-Getter"><a href="#D-Getter" class="headerlink" title="D.Getter"></a>D.Getter</h4><p>Getter用于对Store中的数据进行加工处理形成新的数据<br>它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化<br>打开store.js文件，添加getters，如下：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  .......</span><br><span class="line">  getters:&#123;</span><br><span class="line">    //添加了一个showNum的属性</span><br><span class="line">    showNum : <span class="keyword">state</span> =&gt;&#123;</span><br><span class="line">      return '最新的count值为：'+<span class="keyword">state</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后打开Addition.vue中，添加插值表达式使用getters</p>
<h3></h3>

<p>或者也可以在Addition.vue中，导入mapGetters，并将之映射为计算属性<br>import { mapGetters } from ‘vuex’<br>computed:{<br>  …mapGetters([‘showNum’])<br>}</p>
<h3 id="5-vuex案例"><a href="#5-vuex案例" class="headerlink" title="5.vuex案例"></a>5.vuex案例</h3><h4 id="A-初始化案例"><a href="#A-初始化案例" class="headerlink" title="A.初始化案例"></a>A.初始化案例</h4><p>首先使用vue ui初始化一个使用vuex的案例<br>然后打开public文件夹，创建一个list.json文件，文件代码如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"info"</span>: <span class="string">"Racing car sprays burning fuel into crowd."</span>,</span><br><span class="line">        <span class="attr">"done"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"info"</span>: <span class="string">"Japanese princess to wed commoner."</span>,</span><br><span class="line">        <span class="attr">"done"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"info"</span>: <span class="string">"Australian walks 100km after outback crash."</span>,</span><br><span class="line">        <span class="attr">"done"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"info"</span>: <span class="string">"Man charged over missing wedding girl."</span>,</span><br><span class="line">        <span class="attr">"done"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">"info"</span>: <span class="string">"Los Angeles battles huge wildfires."</span>,</span><br><span class="line">        <span class="attr">"done"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>再接着，打开main.js,添加store.js的引入，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入 ant-design-vue 组件库</span></span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">'ant-design-vue'</span></span><br><span class="line"><span class="comment">// 2. 导入组件库的样式表</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant-design-vue/dist/antd.css'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 3. 安装组件库</span></span><br><span class="line">Vue.use(Antd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>再接着打开store.js，添加axios请求json文件获取数据的代码，如下：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> 'vue'</span><br><span class="line">import Vuex <span class="keyword">from</span> 'vuex'</span><br><span class="line">import axios <span class="keyword">from</span> 'axios'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    //所有任务列表</span><br><span class="line">    list: [],</span><br><span class="line">    //文本输入框中的值</span><br><span class="line">    inputValue: 'AAA'</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    initList(<span class="keyword">state</span>, list) &#123;</span><br><span class="line">      <span class="keyword">state</span>.list = list</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>InputValue(<span class="keyword">state</span>,value)&#123;</span><br><span class="line">      <span class="keyword">state</span>.inputValue = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    getList(context) &#123;</span><br><span class="line">      axios.get('/list.json').then((&#123; data &#125;) =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(data);</span><br><span class="line">        context.commit('initList', data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>最后，代开App.vue文件，将store中的数据获取并展示：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入任务"</span> <span class="attr">class</span>=<span class="string">"my_ipt"</span> <span class="attr">:value</span>=<span class="string">"inputValue"</span> @<span class="attr">change</span>=<span class="string">"handleInputChange"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>添加事项<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a-list</span> <span class="attr">bordered</span> <span class="attr">:dataSource</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"dt_list"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">a-list-item</span> <span class="attr">slot</span>=<span class="string">"renderItem"</span> <span class="attr">slot-scope</span>=<span class="string">"item"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 复选框 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">a-checkbox</span> <span class="attr">:checked</span>=<span class="string">"item.done"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.info&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a-checkbox</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 删除链接 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">"actions"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">a-list-item</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- footer区域 --&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 未完成的任务个数 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>0条剩余<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 操作按钮 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">a-button-group</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a-button</span>&gt;</span>未完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a-button</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">a-button-group</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 把已经完成的任务清空 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">a</span>&gt;</span>清除已完成<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">a-list</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import &#123; mapState &#125; from 'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  name: 'app',</span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      // list:[]</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created()&#123;</span></span><br><span class="line"><span class="xml">    // console.log(this.$store);</span></span><br><span class="line"><span class="xml">    this.$store.dispatch('getList')</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  methods:&#123;</span></span><br><span class="line"><span class="xml">    handleInputChange(e)&#123;</span></span><br><span class="line"><span class="xml">      // console.log(e.target.value)</span></span><br><span class="line"><span class="xml">      this.$store.commit('setInputValue',e.target.value)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  computed:&#123;</span></span><br><span class="line"><span class="xml">    ...mapState(['list','inputValue'])</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml">#app &#123;</span></span><br><span class="line"><span class="xml">  padding: 10px;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">.my_ipt &#123;</span></span><br><span class="line"><span class="xml">  width: 500px;</span></span><br><span class="line"><span class="xml">  margin-right: 10px;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">.dt_list &#123;</span></span><br><span class="line"><span class="xml">  width: 500px;</span></span><br><span class="line"><span class="xml">  margin-top: 10px;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">.footer &#123;</span></span><br><span class="line"><span class="xml">  display: flex;</span></span><br><span class="line"><span class="xml">  justify-content: space-between;</span></span><br><span class="line"><span class="xml">  align-items: center;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="B-完成添加事项"><a href="#B-完成添加事项" class="headerlink" title="B.完成添加事项"></a>B.完成添加事项</h4><p>首先，打开App.vue文件，给“添加事项”按钮绑定点击事件，编写处理函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">&lt;a-button type=<span class="string">"primary"</span> <span class="meta">@click</span>=<span class="string">"addItemToList"</span>&gt;添加事项&lt;/a-button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写事件处理函数</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    ......</span><br><span class="line">    addItemToList()&#123;</span><br><span class="line">      <span class="comment">//向列表中新增事项</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.inputValue.trim().length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.warning(<span class="string">'文本框内容不能为空'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addItem'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后打开store.js编写addItem</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    //所有任务列表</span><br><span class="line">    list: [],</span><br><span class="line">    //文本输入框中的值</span><br><span class="line">    inputValue: 'AAA',</span><br><span class="line">    //下一个id</span><br><span class="line">    nextId:<span class="number">5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    ........</span><br><span class="line">    //添加列表项</span><br><span class="line">    addItem(<span class="keyword">state</span>)&#123;</span><br><span class="line">      const obj = &#123;</span><br><span class="line">        id :<span class="keyword">state</span>.nextId,</span><br><span class="line">        info: <span class="keyword">state</span>.inputValue.trim(),</span><br><span class="line">        done:false</span><br><span class="line">      &#125;</span><br><span class="line">      //将创建好的事项添加到数组list中</span><br><span class="line">      <span class="keyword">state</span>.list.push(obj)</span><br><span class="line">      //将nextId值自增</span><br><span class="line">      <span class="keyword">state</span>.nextId++</span><br><span class="line">      <span class="keyword">state</span>.inputValue = ''</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="C-完成删除事项"><a href="#C-完成删除事项" class="headerlink" title="C.完成删除事项"></a>C.完成删除事项</h4><p>首先，打开App.vue文件，给“删除”按钮绑定点击事件，编写处理函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">&lt;a slot=<span class="string">"actions"</span> <span class="meta">@click</span>=<span class="string">"removeItemById(item.id)"</span>&gt;删除&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写事件处理函数</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    ......</span><br><span class="line">    removeItemById(id)&#123;</span><br><span class="line">      <span class="comment">//根据id删除事项</span></span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeItem'</span>,id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后打开store.js编写addItem</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  ......</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    ........</span><br><span class="line">    removeItem(<span class="keyword">state</span>,id)&#123;</span><br><span class="line">      //根据id删除事项数据</span><br><span class="line">      const index = <span class="keyword">state</span>.list.findIndex( x =&gt; x.id === id )</span><br><span class="line">      // console.<span class="keyword">log</span>(index);</span><br><span class="line">      if(index != -<span class="number">1</span>) <span class="keyword">state</span>.list.splice(index,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="D-完成选中状态的改变"><a href="#D-完成选中状态的改变" class="headerlink" title="D.完成选中状态的改变"></a>D.完成选中状态的改变</h4><p>首先，打开App.vue文件，给“复选”按钮绑定点击事件，编写处理函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">&lt;a-checkbox :checked=<span class="string">"item.done"</span> <span class="meta">@change</span>=<span class="string">"cbStateChanged(item.id,<span class="variable">$event</span>)"</span>&gt;&#123;&#123;item.info&#125;&#125;&lt;/a-checkbox&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写事件处理函数</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    ......</span><br><span class="line">    cbStateChanged(id,e)&#123;</span><br><span class="line">      <span class="comment">//复选框状态改变时触发</span></span><br><span class="line">      <span class="keyword">const</span> param = &#123;</span><br><span class="line">        id:id,</span><br><span class="line">        status:e.target.checked</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//根据id更改事项状态</span></span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'changeStatus'</span>,param)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后打开store.js编写addItem</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  ......</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    ........</span><br><span class="line">    changeStatus(<span class="keyword">state</span>,param)&#123;</span><br><span class="line">      //根据id改变对应事项的状态</span><br><span class="line">      const index = <span class="keyword">state</span>.list.findIndex( x =&gt; x.id === param.id )</span><br><span class="line">      if(index != -<span class="number">1</span>) <span class="keyword">state</span>.list[index].done = param.status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="E-剩余项统计"><a href="#E-剩余项统计" class="headerlink" title="E.剩余项统计"></a>E.剩余项统计</h4><p>打开store.js，添加getters完成剩余项统计</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">  unDoneLength(<span class="keyword">state</span>)&#123;</span><br><span class="line">    const temp = <span class="keyword">state</span>.list.filter( x =&gt; x.done === false )</span><br><span class="line">    console.<span class="keyword">log</span>(temp)</span><br><span class="line">    return temp.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开App.vue，使用getters展示剩余项</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">//使用映射好的计算属性展示剩余项</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 未完成的任务个数 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;unDoneLength&#125;</span><span class="xml">&#125;条剩余<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//导入getters</span></span><br><span class="line"><span class="xml">import </span><span class="template-variable">&#123; mapState,mapGetters &#125;</span><span class="xml"> from 'vuex'</span></span><br><span class="line"><span class="xml">//映射</span></span><br><span class="line"><span class="xml">computed:</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  ...mapState(['list','inputValue']),</span></span><br><span class="line"><span class="template-variable">  ...mapGetters(['unDoneLength'])</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="F-清除完成事项"><a href="#F-清除完成事项" class="headerlink" title="F.清除完成事项"></a>F.清除完成事项</h4><p>首先，打开App.vue文件，给“清除已完成”按钮绑定点击事件，编写处理函数</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 把已经完成的任务清空 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"clean"</span>&gt;</span>清除已完成<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//编写事件处理函数</span></span><br><span class="line"><span class="xml">methods:</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  ......</span></span><br><span class="line"><span class="template-variable">  clean()&#123;</span></span><br><span class="line"><span class="template-variable">    //清除已经完成的事项</span></span><br><span class="line"><span class="template-variable">    this.$store.commit('cleanDone')</span></span><br><span class="line"><span class="template-variable">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后打开store.js编写addItem</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>new Vuex.Store(&#123;</span><br><span class="line">  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">    cleanDone(state)&#123;</span><br><span class="line">      state.list = state.list.filter( x =&gt; x.done === <span class="literal">false</span> )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="G-点击选项卡切换事项"><a href="#G-点击选项卡切换事项" class="headerlink" title="G.点击选项卡切换事项"></a>G.点击选项卡切换事项</h4><p>打开App.vue，给“全部”，“未完成”，“已完成”三个选项卡绑定点击事件，编写处理函数<br>并将列表数据来源更改为一个getters。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a-list</span> <span class="attr">bordered</span> <span class="attr">:dataSource</span>=<span class="string">"infoList"</span> <span class="attr">class</span>=<span class="string">"dt_list"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  ......</span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 操作按钮 --&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">a-button-group</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">"viewKey ==='all'?'primary':'default'"</span> @<span class="attr">click</span>=<span class="string">"changeList('all')"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">"viewKey ==='undone'?'primary':'default'"</span> @<span class="attr">click</span>=<span class="string">"changeList('undone')"</span>&gt;</span>未完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">"viewKey ==='done'?'primary':'default'"</span> @<span class="attr">click</span>=<span class="string">"changeList('done')"</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">a-button-group</span>&gt;</span></span></span><br><span class="line"><span class="xml">  ......</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">a-list</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">//编写事件处理函数以及映射计算属性</span><br><span class="line">methods:&#123;</span><br><span class="line">  ......</span><br><span class="line">  changeList(<span class="built_in"> key</span> )&#123;</span><br><span class="line">    //点击“全部”，“已完成”，“未完成”时触发</span><br><span class="line">    this.<span class="variable">$store</span>.commit(<span class="string">'changeKey'</span><span class="built_in">,key</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapState([<span class="string">'list'</span>,<span class="string">'inputValue'</span>,<span class="string">'viewKey'</span>]),</span><br><span class="line">  ...mapGetters([<span class="string">'unDoneLength'</span>,<span class="string">'infoList'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开store.js，添加getters，mutations，state</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    ......</span><br><span class="line">    //保存默认的选项卡值</span><br><span class="line">    viewKey:'<span class="literal">all</span>'</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    ......</span><br><span class="line">    changeKey(<span class="keyword">state</span>,key)&#123;</span><br><span class="line">      //当用户点击“全部”，“已完成”，“未完成”选项卡时触发</span><br><span class="line">      <span class="keyword">state</span>.viewKey = key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br><span class="line">  getters:&#123;</span><br><span class="line">    .......</span><br><span class="line">    infoList(<span class="keyword">state</span>)&#123;</span><br><span class="line">      if(<span class="keyword">state</span>.viewKey === '<span class="literal">all</span>')&#123;</span><br><span class="line">        return <span class="keyword">state</span>.list</span><br><span class="line">      &#125;</span><br><span class="line">      if(<span class="keyword">state</span>.viewKey === 'undone')&#123;</span><br><span class="line">        return <span class="keyword">state</span>.list.filter( x =&gt; x.done === false )</span><br><span class="line">      &#125;</span><br><span class="line">      if(<span class="keyword">state</span>.viewKey === 'done')&#123;</span><br><span class="line">        return <span class="keyword">state</span>.list.filter( x =&gt; x.done === true )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域资源共享CORS</title>
    <url>/2020/03/06/%E9%9D%A2%E7%BB%8F05/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">参考阮一峰博客文章</a><br>CORS是一个w3c标准，全称是快于资源共享。它允许浏览器向跨源服务器，发出XMLHttpRequet请求，从而克服了AJAX只能同源使用的限制。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能。整个CORS通信过程，都是浏览器自动完成。不需要用户参与。对于开发者来说，CORS通信与同源AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，当用户不会有感觉。</p>
<p>因此实现CORS通信的关键时服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<a id="more"></a>
<h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>浏览器将CORS请求分成两类：简单请求和非简单请求。<br>只要同时满足以下两大条件就属于简单请求：</p>
<ul>
<li>请求方法时以下三种方法之一：<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</li>
<li>HTTP的头信息不超过以下几种字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-Id</li>
<li>Content-Type：只限于三个只application/x-www-form-urlencoded、mutipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<p>凡是不满足以上两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理是不一样的。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段</p>
<p>浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">GET<span class="regexp">/cors HTTP/</span><span class="number">1.1</span></span><br><span class="line"><span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line"><span class="string">Host:</span>api.alice.com</span><br><span class="line">Accept-<span class="string">Language:</span> en-US</span><br><span class="line"><span class="string">Connection:</span> keep-alive</span><br><span class="line">User-<span class="string">Agent:</span> Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>上面的信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同一这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP响应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP的状态码有可能是200.</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-<span class="string">Credentials:</span> <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-<span class="string">Headers:</span> Foobar</span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
<p>上面的头信息之中有三个与CORS请求相关的字段，都以<code>Access-Control</code>开头</p>
<ul>
<li>Access-Control-Allow-Origin：该字段是必须的，它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接收任意域名的请求。</li>
<li>Access-Control-Allow-Credentials： 该字段可选。它的值是一个布尔值，表示是否允许发送cookie。默认情况下，cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，cookie可以包含在请求中，一起发送给服务器，这个值也只能设为<code>true</code>，如果服务器不需要浏览器发送cookie，删除该字段即可。</li>
<li>Access-Control-Expose-Headers：该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到六个基本字段<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Progma</code>。如果想要拿到其他字段就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</li>
</ul>
<h4 id="withCredentials属性"><a href="#withCredentials属性" class="headerlink" title="withCredentials属性"></a>withCredentials属性</h4><p>上面说到，CORS请求默认不发送cookie和HTTP认证信息。如果要把cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Access-Control-Allow-Credentials:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则即使服务器同意发送cookie，浏览器也不会发送。或者服务器要求设置cookie，浏览器也不会处理。</p>
<p>但是如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xhr.withCredentials</span> = <span class="literal">true</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果要发送cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，cookie依然遵循同源政策，只有用服务器域名设置的cookie才会上传，其他域名的cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的cookie。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，成为<code>预检请求</code>。</p>
<p>浏览器先访问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="built_in">url</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<p>上面代码HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这时一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的HTTP头信息。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http: <span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> PUT</span><br><span class="line">Access-Control-Request-Header: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Access-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息还包括两个特殊字段</p>
<h5 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a>Access-Control-Request-Method</h5><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<h5 id="Access-Control-Request-Header"><a href="#Access-Control-Request-Header" class="headerlink" title="Access-Control-Request-Header"></a>Access-Control-Request-Header</h5><p>该字段是一个逗号分割的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h4 id="预检请求的响应"><a href="#预检请求的响应" class="headerlink" title="预检请求的响应"></a>预检请求的响应</h4><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Header</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">01</span> <span class="string">Dec</span> <span class="number">2008</span> <span class="number">01</span><span class="string">:15:39</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache/2.0.61(Unix)</span></span><br><span class="line"><span class="attr">Access-Control-Request-Origin:</span> <span class="string">http://api.bob.com</span></span><br><span class="line"><span class="attr">Access-Control-Request-Methods:</span> <span class="string">GET,</span> <span class="string">POST,</span> <span class="string">PUT</span></span><br><span class="line"><span class="attr">Access-Control-Request-Headers:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html;</span> <span class="string">charset=utf-8</span></span><br><span class="line"><span class="attr">Content-Encoding:</span> <span class="string">gzip</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Keep-Alive:</span> <span class="string">timeout=2,</span> <span class="string">max=100</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/plain</span></span><br></pre></td></tr></table></figure>

<p>上面的HTTP回应中，关键的是<code>Access-Control-Request-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为型号，表示同意任意跨源请求。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Request-Origin: *</span><br></pre></td></tr></table></figure>
<p>如果浏览器否定了“预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时浏览器会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot <span class="keyword">load</span> <span class="keyword">http</span>://api.bob.com</span><br><span class="line">Origin <span class="keyword">http</span>://api.bob.com <span class="keyword">is</span> <span class="keyword">not</span> allowed <span class="keyword">by</span> <span class="keyword">Access</span>-Control-Request-Origin</span><br></pre></td></tr></table></figure>

<p>服务器回应的其他CORS相关字段如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Methods: <span class="keyword">GET</span>, POST, PUT</span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Headers: X-Custom-<span class="keyword">Header</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Credentials: <span class="keyword">true</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Max-Age: <span class="number">1728000</span></span><br></pre></td></tr></table></figure>

<h5 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h5><p>该字段必需，它的值是逗号分割的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的哪个方法。这时为了避免多次“预检”请求</p>
<h5 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h5><p>如果浏览器请求包括<code>Access-Control-Request-Methods</code>字段，则<code>Access-Control-Allow-Methods</code>字段是必须的。它也是一个逗号分割的字符串，表明服务器支持的所有头信息字段，不限于浏览器“预检”中请求的字段。</p>
<h5 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h5><p>该字段与简单请求时的含义相同</p>
<h5 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h5><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期时20天，即允许缓存该条回应20天，再次期间不用发出另一条预检请求。</p>
<h4 id="浏览器的正常请求与回应"><a href="#浏览器的正常请求与回应" class="headerlink" title="浏览器的正常请求与回应"></a>浏览器的正常请求与回应</h4><p>一旦服务器通过“预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面时“预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span>: value</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br></pre></td></tr></table></figure>

<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的</p>
<p>下面是服务器正常的回应：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Origin:</span><span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的</p>
<h3 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>跨域资源共享CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/06/vue3-11/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.完成项目优化<br>2.完成项目上线</p>
<h3 id="1-项目优化"><a href="#1-项目优化" class="headerlink" title="1.项目优化"></a>1.项目优化</h3><p>实现步骤：<br>A.生成打包报告，根据报告优化项目<br>B.第三方库启用CDN<br>C.Element-UI组件按需加载<br>D.路由懒加载<br>E.首页内容定制</p>
<a id="more"></a>
<h3 id="2-添加进度条"><a href="#2-添加进度条" class="headerlink" title="2.添加进度条"></a>2.添加进度条</h3><p>给项目添加进度条效果，先打开项目控制台，打开依赖，安装nprogress<br>打开main.js，编写如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入进度条插件</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">'nprogress'</span></span><br><span class="line"><span class="comment">//导入进度条样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'nprogress/nprogress.css'</span></span><br><span class="line">.....</span><br><span class="line"><span class="comment">//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//当进入request拦截器，表示发送了请求，我们就开启进度条</span></span><br><span class="line">  NProgress.start()</span><br><span class="line">  <span class="comment">//为请求头对象，添加token验证的Authorization字段</span></span><br><span class="line">  config.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">"token"</span>)</span><br><span class="line">  <span class="comment">//必须返回config</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在response拦截器中，隐藏进度条</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//当进入response拦截器，表示请求已经结束，我们就结束进度条</span></span><br><span class="line">  NProgress.done()</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-根据报错修改代码"><a href="#3-根据报错修改代码" class="headerlink" title="3.根据报错修改代码"></a>3.根据报错修改代码</h3><p>根据ESLint的警告提示更改对应的代码<br>在.prettierrc文件中更改设置”printWidth”:200,  将每行代码的文字数量更改为200</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"semi"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"printWidth"</span>:<span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-执行build"><a href="#4-执行build" class="headerlink" title="4.执行build"></a>4.执行build</h3><p>安装一个插件（babel-plugin-transform-remove-console）在项目build阶段移除所有的console信息<br>打开项目控制台，点击依赖-&gt;开发依赖，输入babel-plugin-transform-remove-console，安装<br>打开babel.config.js，编辑代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目发布阶段需要用到的babel插件</span></span><br><span class="line">const productPlugins = []</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是开发还是发布阶段</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(process.env.NODE_ENV === <span class="string">'production'</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">//发布阶段</span></span><br><span class="line">  productPlugins.push(<span class="string">"transform-remove-console"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module<span class="selector-class">.exports</span> = &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@vue/app"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...productPlugins</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-生成打包报告"><a href="#5-生成打包报告" class="headerlink" title="5.生成打包报告"></a>5.生成打包报告</h3><p>A.命令行形式生成打包报告<br>vue-cli-service build –report<br>B.在vue控制台生成打包报告<br>点击“任务”=&gt;“build”=&gt;“运行”<br>运行完毕之后点击右侧“分析”，“控制台”面板查看报告</p>
<h3 id="6-修改webpack的默认配置"><a href="#6-修改webpack的默认配置" class="headerlink" title="6.修改webpack的默认配置"></a>6.修改webpack的默认配置</h3><p>默认情况下，vue-cli 3.0生成的项目，隐藏了webpack配置项，如果我们需要配置webpack<br>需要通过vue.config.js来配置。<br>在项目根目录中创建vue.config.js文件，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    chainWebpack:<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//发布模式</span></span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'production'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//entry找到默认的打包入口，调用clear则是删除默认的打包入口</span></span><br><span class="line">            <span class="comment">//add添加新的打包入口</span></span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//开发模式</span></span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'development'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：<br>chainWebpack可以通过链式编程的形式，修改webpack配置<br>configureWebpack可以通过操作对象的形式，修改webpack配置</p>
<h3 id="7-加载外部CDN"><a href="#7-加载外部CDN" class="headerlink" title="7.加载外部CDN"></a>7.加载外部CDN</h3><p>默认情况下，依赖项的所有第三方包都会被打包到js/chunk-vendors.<strong>**</strong>.js文件中，导致该js文件过大<br>那么我们可以通过externals排除这些包，使它们不被打包到js/chunk-vendors.<strong>**</strong>.js文件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    chainWebpack:<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//发布模式</span></span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'production'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//entry找到默认的打包入口，调用clear则是删除默认的打包入口</span></span><br><span class="line">            <span class="comment">//add添加新的打包入口</span></span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用externals设置排除项</span></span><br><span class="line">            config.set(<span class="string">'externals'</span>,&#123;</span><br><span class="line">                vue:<span class="string">'Vue'</span>,</span><br><span class="line">                <span class="string">'vue-router'</span>:<span class="string">'VueRouter'</span>,</span><br><span class="line">                axios:<span class="string">'axios'</span>,</span><br><span class="line">                lodash:<span class="string">'_'</span>,</span><br><span class="line">                echarts:<span class="string">'echarts'</span>,</span><br><span class="line">                nprogress:<span class="string">'NProgress'</span>,</span><br><span class="line">                <span class="string">'vue-quill-editor'</span>:<span class="string">'VueQuillEditor'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//开发模式</span></span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'development'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好排除之后，为了使我们可以使用vue，axios等内容，我们需要加载外部CDN的形式解决引入依赖项。<br>打开开发入口文件main-prod.js,删除掉默认的引入代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="comment">// import './plugins/element.js'</span></span><br><span class="line"><span class="comment">//导入字体图标</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./assets/fonts/iconfont.css'</span></span><br><span class="line"><span class="comment">//导入全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./assets/css/global.css'</span></span><br><span class="line"><span class="comment">//导入第三方组件vue-table-with-tree-grid</span></span><br><span class="line"><span class="keyword">import</span> TreeTable <span class="keyword">from</span> <span class="string">'vue-table-with-tree-grid'</span></span><br><span class="line"><span class="comment">//导入进度条插件</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">'nprogress'</span></span><br><span class="line"><span class="comment">//导入进度条样式</span></span><br><span class="line"><span class="comment">// import 'nprogress/nprogress.css'</span></span><br><span class="line"><span class="comment">// //导入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="comment">// //导入vue-quill-editor（富文本编辑器）</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor <span class="keyword">from</span> <span class="string">'vue-quill-editor'</span></span><br><span class="line"><span class="comment">// //导入vue-quill-editor的样式</span></span><br><span class="line"><span class="comment">// import 'quill/dist/quill.core.css'</span></span><br><span class="line"><span class="comment">// import 'quill/dist/quill.snow.css'</span></span><br><span class="line"><span class="comment">// import 'quill/dist/quill.bubble.css'</span></span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://127.0.0.1:8888/api/private/v1/'</span></span><br><span class="line"><span class="comment">//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//当进入request拦截器，表示发送了请求，我们就开启进度条</span></span><br><span class="line">  NProgress.start()</span><br><span class="line">  <span class="comment">//为请求头对象，添加token验证的Authorization字段</span></span><br><span class="line">  config.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">"token"</span>)</span><br><span class="line">  <span class="comment">//必须返回config</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在response拦截器中，隐藏进度条</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//当进入response拦截器，表示请求已经结束，我们就结束进度条</span></span><br><span class="line">  NProgress.done()</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局注册组件</span></span><br><span class="line">Vue.component(<span class="string">'tree-table'</span>, TreeTable)</span><br><span class="line"><span class="comment">//全局注册富文本组件</span></span><br><span class="line">Vue.use(VueQuillEditor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建过滤器将秒数过滤为年月日，时分秒</span></span><br><span class="line">Vue.filter(<span class="string">'dateFormat'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">originVal</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> m = (dt.getMonth()+<span class="number">1</span>+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> d = (dt.getDate()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>然后打开public/index.html添加外部cdn引入代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>电商后台管理系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- nprogress 的样式表文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 富文本编辑器 的样式表文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- element-ui 的样式表文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/vue/2.5.22/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/axios/0.18.0/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 富文本编辑器的 js 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/quill/1.3.4/quill.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- element-ui 的 js 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/element-ui/2.8.2/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We're sorry but vue_shop doesn't work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-定制首页内容"><a href="#8-定制首页内容" class="headerlink" title="8.定制首页内容"></a>8.定制首页内容</h3><p>开发环境的首页和发布环境的首页展示内容的形式有所不同<br>如开发环境中使用的是import加载第三方包，而发布环境则是使用CDN，那么首页也需根据环境不同来进行不同的实现<br>我们可以通过插件的方式来定制首页内容，打开vue.config.js，编写代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    chainWebpack:<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'production'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用插件</span></span><br><span class="line">            config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//添加参数isProd</span></span><br><span class="line">                args[<span class="number">0</span>].isProd = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> args</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        config.when(process.env.NODE_ENV === <span class="string">'development'</span>,<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">            config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用插件</span></span><br><span class="line">            config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//添加参数isProd</span></span><br><span class="line">                args[<span class="number">0</span>].isProd = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> args</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在public/index.html中使用插件判断是否为发布环境并定制首页内容</p>
<figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> BASE_URL </span><span class="xml"><span class="tag"><span class="string">%&gt;favicon.ico"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> htmlWebpackPlugin.options.isProd ? <span class="string">''</span> : <span class="string">'dev - '</span> </span><span class="xml"><span class="tag">%&gt;</span>电商后台管理系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">if</span>(htmlWebpackPlugin.options.isProd)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- nprogress 的样式表文件 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    ........</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- element-ui 的 js 文件 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/element-ui/2.8.2/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  .......</span></span><br></pre></td></tr></table></figure>

<h3 id="9-路由懒加载"><a href="#9-路由懒加载" class="headerlink" title="9.路由懒加载"></a>9.路由懒加载</h3><p>当路由被访问时才加载对应的路由文件，就是路由懒加载。<br>路由懒加载实现步骤：<br>1.安装 @babel/plugin-syntax-dynamic-import<br>打开vue控制台，点击依赖-&gt;安装依赖-&gt;开发依赖-&gt;搜索@babel/plugin-syntax-dynamic-import<br>点击安装。</p>
<p>2.在babel.config.js中声明该插件，打开babel.config.js</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目发布阶段需要用到的babel插件</span></span><br><span class="line">const productPlugins = []</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是开发还是发布阶段</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(process.env.NODE_ENV === <span class="string">'production'</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">//发布阶段</span></span><br><span class="line">  productPlugins.push(<span class="string">"transform-remove-console"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module<span class="selector-class">.exports</span> = &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@vue/app"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ..<span class="selector-class">.productPlugins</span>,</span><br><span class="line">    <span class="comment">//配置路由懒加载插件</span></span><br><span class="line">    <span class="string">"@babel/plugin-syntax-dynamic-import"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.将路由更改为按需加载的形式，打开router.js，更改引入组件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"login_home_welcome" */</span> <span class="string">'./components/Login.vue'</span>)</span><br><span class="line"><span class="comment">// import Login from './components/Login.vue'</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"login_home_welcome" */</span> <span class="string">'./components/Home.vue'</span>)</span><br><span class="line"><span class="comment">// import Home from './components/Home.vue'</span></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"login_home_welcome" */</span> <span class="string">'./components/Welcome.vue'</span>)</span><br><span class="line"><span class="comment">// import Welcome from './components/Welcome.vue'</span></span><br><span class="line"><span class="keyword">const</span> Users = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"user" */</span> <span class="string">'./components/user/Users.vue'</span>)</span><br><span class="line"><span class="comment">// import Users from './components/user/Users.vue'</span></span><br><span class="line"><span class="keyword">const</span> Rights = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"power" */</span> <span class="string">'./components/power/Rights.vue'</span>)</span><br><span class="line"><span class="comment">// import Rights from './components/power/Rights.vue'</span></span><br><span class="line"><span class="keyword">const</span> Roles = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"power" */</span> <span class="string">'./components/power/Roles.vue'</span>)</span><br><span class="line"><span class="comment">// import Roles from './components/power/Roles.vue'</span></span><br><span class="line"><span class="keyword">const</span> Cate = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"goods" */</span> <span class="string">'./components/goods/Cate.vue'</span>)</span><br><span class="line"><span class="comment">// import Cate from './components/goods/Cate.vue'</span></span><br><span class="line"><span class="keyword">const</span> Params = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"goods" */</span> <span class="string">'./components/goods/Params.vue'</span>)</span><br><span class="line"><span class="comment">// import Params from './components/goods/Params.vue'</span></span><br><span class="line"><span class="keyword">const</span> GoodList = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"goods" */</span> <span class="string">'./components/goods/List.vue'</span>)</span><br><span class="line"><span class="comment">// import GoodList from './components/goods/List.vue'</span></span><br><span class="line"><span class="keyword">const</span> GoodAdd = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"goods" */</span> <span class="string">'./components/goods/Add.vue'</span>)</span><br><span class="line"><span class="comment">// import GoodAdd from './components/goods/Add.vue'</span></span><br><span class="line"><span class="keyword">const</span> Order = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"order" */</span> <span class="string">'./components/order/Order.vue'</span>)</span><br><span class="line"><span class="comment">// import Order from './components/order/Order.vue'</span></span><br><span class="line"><span class="keyword">const</span> Report = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"report" */</span> <span class="string">'./components/report/Report.vue'</span>)</span><br><span class="line"><span class="comment">// import Report from './components/report/Report.vue'</span></span><br></pre></td></tr></table></figure>

<h3 id="10-项目上线"><a href="#10-项目上线" class="headerlink" title="10.项目上线"></a>10.项目上线</h3><h4 id="A-通过node创建服务器"><a href="#A-通过node创建服务器" class="headerlink" title="A.通过node创建服务器"></a>A.通过node创建服务器</h4><p>在vue_shop同级创建一个文件夹vue_shop_server存放node服务器<br>使用终端打开vue_shop_server文件夹，输入命令 npm init -y<br>初始化包之后，输入命令 npm i express -S<br>打开vue_shop目录，复制dist文件夹，粘贴到vue_shop_server中<br>在vue_shop_server文件夹中创建app.js文件,编写代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'./dist'</span>))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8998</span>,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server running at http://127.0.0.1:8998"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后再次在终端中输入  node app.js</p>
<h4 id="B-开启gzip压缩"><a href="#B-开启gzip压缩" class="headerlink" title="B.开启gzip压缩"></a>B.开启gzip压缩</h4><p>打开vue_shop_server文件夹的终端，输入命令：npm i compression -D<br>打开app.js,编写代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(compression())</span><br><span class="line">app.use(express.static(<span class="string">'./dist'</span>))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8998</span>,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server running at http://127.0.0.1:8998"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="C-配置https服务"><a href="#C-配置https服务" class="headerlink" title="C.配置https服务"></a>C.配置https服务</h4><p>配置https服务一般是后台进行处理，前端开发人员了解即可。<br>首先，需要申请SSL证书，进入<a href="https://freessl.cn官网" target="_blank" rel="noopener">https://freessl.cn官网</a><br>在后台导入证书，打开今天资料/素材，复制素材中的两个文件到vue_shop_server中<br>打开app.js文件，编写代码导入证书，并开启https服务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>)</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//创建配置对象设置公钥和私钥</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    cert:fs.readFileSync(<span class="string">'./full_chain.pem'</span>),</span><br><span class="line">    key:fs.readFileSync(<span class="string">'./private.key'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(compression())</span><br><span class="line">app.use(express.static(<span class="string">'./dist'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.listen(8998,()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log("server running at http://127.0.0.1:8998")</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//启动https服务</span></span><br><span class="line">https.createServer(options,app).listen(<span class="number">443</span>)</span><br></pre></td></tr></table></figure>
<p>注意：因为我们使用的证书有问题，所以无法正常使用https服务</p>
<h4 id="D-使用pm2管理应用"><a href="#D-使用pm2管理应用" class="headerlink" title="D.使用pm2管理应用"></a>D.使用pm2管理应用</h4><p>打开vue_shop_server文件夹的终端，输入命令：npm i pm2 -g<br>使用pm2启动项目，在终端中输入命令：pm2 start app.js –name 自定义名称<br>查看项目列表命令：pm2 ls<br>重启项目：pm2 restart 自定义名称<br>停止项目：pm2 stop 自定义名称<br>删除项目：pm2 delete 自定义名称</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略和规避方法</title>
    <url>/2020/03/05/%E9%9D%A2%E7%BB%8F06/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">摘抄自阮一峰老师博客</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>浏览器安全的基石是“同源政策”。目前，所有浏览器都实行这个政策。同源政策指的是三个相同：</p>
<ul>
<li><p>协议相同</p>
</li>
<li><p>域名相同</p>
</li>
<li><p>端口相同</p>
<a id="more"></a>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>HTTP//
:</code>,域名是<code>www.example.com</code>，端口号是<code>80</code>，（默认端口号是80，可以省略）。它的同源情况如下：</p>
</li>
<li><p><code>http://www.example.com/dir/other.html</code>： 同源</p>
</li>
<li><p><code>http://example.com/dir/other.html</code>： 不同源（域名不相同）</p>
</li>
<li><p><code>http://v2.www.example.com/dir/other.html</code>： 不同源（域名不相同）</p>
</li>
<li><p><code>http://www.example.com：81/dir/other.html</code>： 不同源（端口不同）</p>
</li>
</ul>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>同源政策的目的，是为了保证用户信息的安全，防止恶意网站窃取数据</p>
<p>设想这样一种情况：A银行是一家银行，用户登录以后，又去浏览器其他网站。如果其他网站可以读取A网站的cookie，由于cookie包含隐私，这些信息就会泄露。更可怕的是，cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见“同源政策”是必需的，否则cookie就可以共享，互联网就毫无安全可言了</p>
<h4 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h4><p>随着互联网的发展，“同源政策”越来越严格。目前，如果非同源，供有三种行为收到限制。</p>
<ul>
<li>cookie、localstorage和indexDB无法读取</li>
<li>DOM无法获得</li>
<li>AJAX请求不能发送</li>
</ul>
<p>虽然这些限制是必要的，但有些时候很不方便，合理用途也会受到影响。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是服务端写入浏览器的一小段信息，只有同源的网页才能共享。但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document    .domain</code>共享cookie</p>
<p>举例来说，A网页时<code>http://wl.example.com/a.html</code>，B网页时<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享cookie。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">document.domain</span> = <span class="string">'example.com'</span></span><br></pre></td></tr></table></figure>

<p>现在A网页通过脚本设置一个cookie</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">document.cookie</span> = <span class="string">'test1=hello'</span></span><br></pre></td></tr></table></figure>
<p>B网页就可以读到这个cookie</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie</span><br></pre></td></tr></table></figure>

<p>这种方法只适用于cookie和iframe窗口，localstorage和indexDB无法通过这种方法规避同源政策，而要使用postMessage API</p>
<p>另外，服务器也可以在设置cookie的时候，指定cookie的所属域名为一级域名，比如<code>.example.com</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>-Cookie: key=<span class="keyword">value</span>; <span class="keyword">domain</span> = .example.com; <span class="type">path</span>=/</span><br></pre></td></tr></table></figure>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个cookie</p>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源就会报错</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIframe'</span>).contentWindow.<span class="built_in">document</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，父窗口想要获取子窗口的DOM，因为跨源会导致报错。</p>
<p>反之亦然，子窗口获取父窗口的DOM也会报错</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.parent</span><span class="selector-class">.document</span><span class="selector-class">.body</span></span><br></pre></td></tr></table></figure>

<p>如果两个窗口库一级域名相同，只是二级域名不同，那么设置<code>document.domain</code>属性，就可以规避同源政策，并拿到DOM。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<ul>
<li>片段标识符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（Cross-document messagin）</li>
</ul>
<h4 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h4><p>片段标识符（fragment identifier）指的是，URL的<code>#</code>后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">'#'</span> + data</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIframe'</span>).src = src</span><br></pre></td></tr></table></figure>

<p>子窗口通过监听<code>hashchange</code>事件得到通知</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，子窗口也可以改变父窗口的片段标识符</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">parent.location.href</span> = target + <span class="string">'#'</span> + hash</span><br></pre></td></tr></table></figure>

<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点就是，无论是否同源，只要在同一个窗口里面，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">window.<span class="keyword">name</span> = <span class="keyword">data</span></span><br></pre></td></tr></table></figure>

<p>接着，子窗口跳回一个与主窗口同于的网址</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">= 'http</span>://parent/url/com/xxx.html'</span><br></pre></td></tr></table></figure>

<p>然后主窗口就可以读取子窗口的<code>window.name</code>了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">'myiframe'</span>).contentWindow.name</span><br></pre></td></tr></table></figure>

<p>这种方法的优点就是，<code>window.name</code>容量很大，可以防止非常长的字符串；缺点就是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h4 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h4><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信API。</p>
<p>这个API为<code>window</code>对象新增了<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var popup = window.<span class="keyword">open</span>('http:<span class="comment">//bbb.com','title')</span></span><br><span class="line">popup.post<span class="constructor">Message('<span class="params">hello</span> <span class="params">world</span>', '<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">bbb</span>.<span class="params">com</span>')</span></span><br></pre></td></tr></table></figure>
<p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收信息的窗口的源，即’协议+域名+端口’。也可设置为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的方法类似：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.opener.post<span class="constructor">Message('Nice <span class="params">to</span> <span class="params">see</span> <span class="params">you</span>', '<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">aaa</span>.<span class="params">com</span>')</span></span><br></pre></td></tr></table></figure>

<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e.data)</span><br><span class="line">	&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>message事件的事件对象<code>event</code>，提供以下三个属性：</p>
<ul>
<li>event.source：发送消息的窗口</li>
<li>event.origin：消息发向的网址</li>
<li>event.data： 消息内容</li>
</ul>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.add<span class="constructor">EventListener('<span class="params">message</span>', <span class="params">receiveMessage</span>)</span></span><br><span class="line"><span class="keyword">function</span> receive<span class="constructor">Message(<span class="params">event</span>)</span> &#123;</span><br><span class="line">	event.source.post<span class="constructor">Message('<span class="params">hhhhh</span>')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>event.origin属性可以过滤不是发给本窗口的消息</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage)</span><br><span class="line">function receiveMessage(<span class="keyword">event</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">event</span>.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">event</span>.data === <span class="string">'hello'</span>) &#123;</span><br><span class="line">		<span class="keyword">event</span>.<span class="keyword">source</span>.postMessage(<span class="string">'hello'</span>, <span class="keyword">event</span>.origin)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		console.<span class="keyword">log</span>(<span class="keyword">event</span>.data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>通过<code>window.postMessage</code>，读写其他窗口的localStorage也成为了可能。</p>
<p>主窗口写入iframe子窗口的<code>localStorage</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.onmessage = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.origin !== 'hhtp:<span class="comment">//bbb.com') &#123;</span></span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	var payload = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse(e.data)</span><br><span class="line">	localStorage.set<span class="constructor">Item(<span class="params">payload</span>.<span class="params">key</span>, JSON.<span class="params">stringify</span>(<span class="params">payload</span>.<span class="params">data</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口将父窗口发来的信息，写入自己的localStorage。<br>父窗口发送消息的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var win = document.get<span class="constructor">ElementsByTagName('<span class="params">iframe</span>')</span><span class="literal">[<span class="number">0</span>]</span>.contentWindow</span><br><span class="line">var obj = &#123; name: 'Jack' &#125;</span><br><span class="line">win.post<span class="constructor">Message(JSON.<span class="params">stringify</span>(&#123;<span class="params">key</span>: '<span class="params">storage</span>', <span class="params">data</span>: <span class="params">obj</span>&#125;)</span>, 'http:<span class="comment">//bbb.com')</span></span><br></pre></td></tr></table></figure>
<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e.origin !== <span class="string">'http://bbb.com'</span>) <span class="keyword">return</span></span><br><span class="line">	<span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data)</span><br><span class="line">	<span class="keyword">switch</span> (payloade.method) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'set'</span>:</span><br><span class="line">		  localStorage.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data))</span><br><span class="line">		  <span class="keyword">break</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">'get'</span>:</span><br><span class="line">		  <span class="keyword">var</span> <span class="built_in">parent</span> = <span class="built_in">window</span>.parent</span><br><span class="line">		  <span class="keyword">var</span> data = localStorage.getItem(payload.key)</span><br><span class="line">		  <span class="built_in">parent</span>.postMessage(data, <span class="string">'http: //aaa.com'</span>)</span><br><span class="line">		  <span class="keyword">break</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">		  localStorage.removeItem(payload.key)</span><br><span class="line">		  <span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加强版的父窗口发送消息如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'set'</span>&#125;), data.obj)</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'get'</span>&#125;), <span class="string">"*"</span>)</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span></span><br><span class="line">	<span class="comment">// 'Jack'</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSONP数据，这种做法不收同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">	script.setAttribute(<span class="string">'type'</span>, <span class="string">"text/javascript"</span>)</span><br><span class="line">	script.src = src</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'your address is'</span> + data.ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于JSONP是必须的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">foo</span>(&#123;</span></span><br><span class="line"><span class="function">	<span class="string">"ip"</span>: <span class="string">"8.8.8.8"</span></span></span><br><span class="line"><span class="function">	&#125;)</span></span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据会被是为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket是一种通信协议，使用<code>ws: //</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源，即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: Websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0siohcchd</span><br><span class="line">Sec-Websocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS是跨源资源共享。相比较JSONP只能发送<code>GET</code>请求，CORS允许发送任何类型的请求。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>同源策略和规避方法</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/05/vue3-10/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.完成商品添加<br>2.完成订单列表<br>3.完成数据统计展示</p>
<a id="more"></a>

<h3 id="1-添加商品"><a href="#1-添加商品" class="headerlink" title="1.添加商品"></a>1.添加商品</h3><h4 id="A-完成图片上传"><a href="#A-完成图片上传" class="headerlink" title="A.完成图片上传"></a>A.完成图片上传</h4><p>使用upload组件完成图片上传<br>在element.js中引入upload组件，并注册<br>因为upload组件进行图片上传的时候并不是使用axios发送请求<br>所以，我们需要手动为上传图片的请求添加token，即为upload组件添加headers属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在页面中添加upload组件，并设置对应的事件和属性</span></span><br><span class="line">&lt;el-tab-pane label=<span class="string">"商品图片"</span> name=<span class="string">"3"</span>&gt;</span><br><span class="line">  &lt;!-- 商品图片上传</span><br><span class="line">  action:指定图片上传api接口</span><br><span class="line">  :on-preview ： 当点击图片时会触发该事件进行预览操作,处理图片预览</span><br><span class="line">  :on-remove : 当用户点击图片右上角的X号时触发执行</span><br><span class="line">  :on-success：当用户点击上传图片并成功上传时触发</span><br><span class="line">  list-type ：设置预览图片的方式</span><br><span class="line">  :headers ：设置上传图片的请求头 --&gt;</span><br><span class="line">  &lt;el-upload :action=<span class="string">"uploadURL"</span> :on-preview=<span class="string">"handlePreview"</span> :on-remove=<span class="string">"handleRemove"</span> :on-success=<span class="string">"handleSuccess"</span> list-type=<span class="string">"picture"</span> :headers=<span class="string">"headerObj"</span>&gt;</span><br><span class="line">    &lt;el-button size=<span class="string">"small"</span> type=<span class="string">"primary"</span>&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">  &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-tab-pane&gt;</span><br><span class="line"><span class="comment">//在el-card卡片视图下面添加对话框用来预览图片</span></span><br><span class="line">&lt;!-- 预览图片对话框 --&gt;</span><br><span class="line">&lt;el-dialog title=<span class="string">"图片预览"</span> :visible.sync=<span class="string">"previewVisible"</span> width=<span class="string">"50%"</span>&gt;</span><br><span class="line">  &lt;img :src=<span class="string">"previewPath"</span> <span class="class"><span class="keyword">class</span>="<span class="title">previewImg</span>" /&gt;</span></span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在data中添加数据</span></span><br><span class="line"><span class="keyword">data</span>()&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//添加商品的表单数据对象</span></span><br><span class="line">    addForm: &#123;</span><br><span class="line">      goods_name: <span class="string">''</span>,</span><br><span class="line">      goods_price: <span class="number">0</span>,</span><br><span class="line">      goods_weight: <span class="number">0</span>,</span><br><span class="line">      goods_number: <span class="number">0</span>,</span><br><span class="line">      goods_cat: [],</span><br><span class="line">      <span class="comment">//上传图片数组</span></span><br><span class="line">      pics: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//上传图片的url地址</span></span><br><span class="line">    uploadURL: <span class="string">'http://127.0.0.1:8888/api/private/v1/upload'</span>,</span><br><span class="line">    <span class="comment">//图片上传组件的headers请求头对象</span></span><br><span class="line">    headerObj: &#123; Authorization: window.sessionStorage.getItem(<span class="string">'token'</span>) &#125;,</span><br><span class="line">    <span class="comment">//保存预览图片的url地址</span></span><br><span class="line">    previewPath: <span class="string">''</span>,</span><br><span class="line">    <span class="comment">//控制预览图片对话框的显示和隐藏</span></span><br><span class="line">    previewVisible:<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//在methods中添加事件处理函数</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  .......</span><br><span class="line">  handlePreview(file) &#123;</span><br><span class="line">    <span class="comment">//当用户点击图片进行预览时执行，处理图片预览</span></span><br><span class="line">    <span class="comment">//形参file就是用户预览的那个文件</span></span><br><span class="line">    <span class="keyword">this</span>.previewPath = file.response.<span class="keyword">data</span>.url</span><br><span class="line">    <span class="comment">//显示预览图片对话框</span></span><br><span class="line">    <span class="keyword">this</span>.previewVisible = <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  handleRemove(file) &#123;</span><br><span class="line">    <span class="comment">//当用户点击X号删除时执行</span></span><br><span class="line">    <span class="comment">//形参file就是用户点击删除的文件</span></span><br><span class="line">    <span class="comment">//获取用户点击删除的那个图片的临时路径</span></span><br><span class="line">    <span class="keyword">const</span> filePath = file.response.<span class="keyword">data</span>.tmp_path</span><br><span class="line">    <span class="comment">//使用findIndex来查找符合条件的索引</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="keyword">this</span>.addForm.pics.findIndex(item =&gt; item.pic === filePath)</span><br><span class="line">    <span class="comment">//移除索引对应的图片</span></span><br><span class="line">    <span class="keyword">this</span>.addForm.pics.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  handleSuccess(response) &#123;</span><br><span class="line">    <span class="comment">//当上传成功时触发执行</span></span><br><span class="line">    <span class="comment">//形参response就是上传成功之后服务器返回的结果</span></span><br><span class="line">    <span class="comment">//将服务器返回的临时路径保存到addForm表单的pics数组中</span></span><br><span class="line">    <span class="keyword">this</span>.addForm.pics.push(&#123; pic: response.<span class="keyword">data</span>.tmp_path &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-使用富文本插件"><a href="#B-使用富文本插件" class="headerlink" title="B.使用富文本插件"></a>B.使用富文本插件</h4><p>想要使用富文本插件vue-quill-editor，就必须先从依赖安装该插件<br>引入并注册vue-quill-editor，打开main.js，编写如下代码</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入vue-quill-editor（富文本编辑器）</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor from <span class="string">'vue-quill-editor'</span></span><br><span class="line"><span class="comment">//导入vue-quill-editor的样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'quill/dist/quill.core.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'quill/dist/quill.snow.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'quill/dist/quill.bubble.css'</span></span><br><span class="line"><span class="params">...</span><span class="params">...</span></span><br><span class="line"><span class="comment">//全局注册组件</span></span><br><span class="line">Vue.component(<span class="string">'tree-table'</span>, TreeTable)</span><br><span class="line"><span class="comment">//全局注册富文本组件</span></span><br><span class="line">Vue.use(VueQuillEditor)</span><br></pre></td></tr></table></figure>

<p>使用富文本插件vue-quill-editor</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 富文本编辑器组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"商品内容"</span> <span class="attr">name</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 富文本编辑器组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">quill-editor</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_introduce"</span>&gt;</span><span class="tag">&lt;/<span class="name">quill-editor</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加商品按钮 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">class</span>=<span class="string">"btnAdd"</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//在数据中添加goods_introduce</span><br><span class="line">//添加商品的表单数据对象</span><br><span class="line">addForm: &#123;</span><br><span class="line">  goods_name: '',</span><br><span class="line">  goods_price: 0,</span><br><span class="line">  goods_weight: 0,</span><br><span class="line">  goods_number: 0,</span><br><span class="line">  goods_cat: [],</span><br><span class="line">  //上传图片数组</span><br><span class="line">  pics: [],</span><br><span class="line">  //商品的详情介绍</span><br><span class="line">  goods_introduce:''</span><br><span class="line">&#125;</span><br><span class="line">//在global.css样式中添加富文本编辑器的最小高度</span><br><span class="line">.ql-editor&#123;</span><br><span class="line">    min-height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">//给添加商品按钮添加间距</span><br><span class="line">.btnAdd&#123;</span><br><span class="line">  margin-top:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-添加商品"><a href="#C-添加商品" class="headerlink" title="C.添加商品"></a>C.添加商品</h4><p>完成添加商品的操作<br>在添加商品之前，为了避免goods_cat数组转换字符串之后导致级联选择器报错<br>我们需要打开vue控制条，点击依赖，安装lodash，把addForm进行深拷贝</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开Add.vue，导入lodash</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//官方推荐将lodash导入为_</span></span><br><span class="line">import _ from <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给添加商品按钮绑定点击事件</span></span><br><span class="line">&lt;!-- 添加商品按钮 --&gt;</span><br><span class="line">&lt;el-<span class="selector-tag">button</span> type=<span class="string">"primary"</span> class=<span class="string">"btnAdd"</span> @click=<span class="string">"add"</span>&gt;添加商品&lt;/el-button&gt;</span><br><span class="line"><span class="comment">//编写点击事件完成商品添加</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  this.<span class="variable">$refs</span><span class="selector-class">.addFormRef</span>.validate(async valid=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!valid) return this.<span class="variable">$message</span>.error(<span class="string">"请填写必要的表单项!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将addForm进行深拷贝，避免goods_cat数组转换字符串之后导致级联选择器报错</span></span><br><span class="line">    const <span class="selector-tag">form</span> = _.cloneDeep(this.addForm)</span><br><span class="line">    <span class="comment">//将goods_cat从数组转换为"1,2,3"字符串形式</span></span><br><span class="line">    <span class="selector-tag">form</span><span class="selector-class">.goods_cat</span> = <span class="selector-tag">form</span><span class="selector-class">.goods_cat</span>.join(<span class="string">","</span>)</span><br><span class="line">    <span class="comment">//处理attrs数组，数组中需要包含商品的动态参数和静态属性</span></span><br><span class="line">    <span class="comment">//将manyTableData（动态参数）处理添加到attrs</span></span><br><span class="line">    this<span class="selector-class">.manyTableData</span>.forEach(item=&gt;&#123;</span><br><span class="line">      <span class="selector-tag">form</span><span class="selector-class">.attrs</span>.push(&#123; attr_id:item<span class="selector-class">.attr_id</span>, attr_value:item<span class="selector-class">.attr_vals</span>.join(<span class="string">" "</span>) &#125;) </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//将onlyTableData（静态属性）处理添加到attrs</span></span><br><span class="line">    this<span class="selector-class">.onlyTableData</span>.forEach(item=&gt;&#123;</span><br><span class="line">      <span class="selector-tag">form</span><span class="selector-class">.attrs</span>.push(&#123; attr_id:item<span class="selector-class">.attr_id</span>, attr_value:item<span class="selector-class">.attr_vals</span> &#125;) </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求完成商品的添加,商品名称必须是唯一的</span></span><br><span class="line">    const &#123;data:res&#125; = await this.<span class="variable">$http</span>.post(<span class="string">'goods'</span>,form)</span><br><span class="line">    <span class="keyword">if</span>(res<span class="selector-class">.meta</span><span class="selector-class">.status</span> !== <span class="number">201</span>)&#123;</span><br><span class="line">      return this.<span class="variable">$message</span>.error(<span class="string">'添加商品失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.<span class="variable">$message</span>.success(<span class="string">'添加商品成功'</span>)</span><br><span class="line">    <span class="comment">//编程式导航跳转到商品列表</span></span><br><span class="line">    this.<span class="variable">$router</span>.push(<span class="string">'/goods'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="D-推送代码"><a href="#D-推送代码" class="headerlink" title="D.推送代码"></a>D.推送代码</h4><p>推送goods_list分支到码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成商品功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将goods_list分支代码合并到master: git merge goods_list<br>将master推送到码云：  git push</p>
<h3 id="2-订单列表"><a href="#2-订单列表" class="headerlink" title="2.订单列表"></a>2.订单列表</h3><h4 id="A-创建分支"><a href="#A-创建分支" class="headerlink" title="A.创建分支"></a>A.创建分支</h4><p>创建order子分支并推送到码云<br>创建order子分支: git checkout -b order<br>将order分支推送到码云： git push -u origin order</p>
<h4 id="B-创建路由"><a href="#B-创建路由" class="headerlink" title="B.创建路由"></a>B.创建路由</h4><p>创建订单列表路由组件并添加路由规则</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//在components中新建<span class="keyword">order</span>文件夹，新建Order.vue组件，组件中添加代码如下</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>订单列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>订单管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>订单列表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 搜索栏 --&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">"20"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span> <span class="attr">v-model</span>=<span class="string">"queryInfo.query"</span> <span class="attr">clearable</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span> &gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  data() &#123;</span></span><br><span class="line"><span class="xquery">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="xquery">        //查询条件</span></span><br><span class="line"><span class="xquery">        queryInfo:&#123;</span></span><br><span class="line"><span class="xquery">            query:<span class="string">''</span>,</span></span><br><span class="line"><span class="xquery">            pagenum:<span class="number">1</span>,</span></span><br><span class="line"><span class="xquery">            pagesize:<span class="number">10</span></span></span><br><span class="line"><span class="xquery">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created() </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">      </span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  methods: </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">      </span></span><br><span class="line"><span class="xquery">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;style<span class="built_in"> lang</span>=<span class="string">"less"</span> scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">//打开router.js导入Order.vue并添加规则</span><br><span class="line"><span class="keyword">import</span> Order from <span class="string">'./components/order/Order.vue'</span></span><br><span class="line"></span><br><span class="line">path: <span class="string">'/home'</span>, component: Home, redirect: <span class="string">'/welcome'</span>, children: [</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/welcome"</span>, component: Welcome &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/users"</span>, component: Users &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/rights"</span>, component: Rights &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/roles"</span>, component: Roles  &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/categories"</span>, component: Cate  &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/params"</span>, component: Params  &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/goods"</span>, component: GoodList  &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/goods/add"</span>, component: GoodAdd  &#125;,</span><br><span class="line">  &#123;<span class="built_in"> path</span>: <span class="string">"/orders"</span>, component: Order  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="C-实现数据展示及分页"><a href="#C-实现数据展示及分页" class="headerlink" title="C.实现数据展示及分页"></a>C.实现数据展示及分页</h4><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 搜索栏 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">"20"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span> <span class="attr">v-model</span>=<span class="string">"queryInfo.query"</span> <span class="attr">clearable</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 订单表格 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"orderList"</span> <span class="attr">border</span> <span class="attr">stripe</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"订单编号"</span> <span class="attr">prop</span>=<span class="string">"order_number"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"订单价格"</span> <span class="attr">prop</span>=<span class="string">"order_price"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"是否付款"</span> <span class="attr">prop</span>=<span class="string">"pay_status"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">v-if</span>=<span class="string">"scope.row.pay_status === '1'"</span>&gt;</span>已付款<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">v-else</span>&gt;</span>未付款<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"是否发货"</span> <span class="attr">prop</span>=<span class="string">"is_send"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"下单时间"</span> <span class="attr">prop</span>=<span class="string">"create_time"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="template-variable">&#123;&#123;scope.row.create_time | dateFormat&#125;&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span> <span class="attr">width</span>=<span class="string">"125px"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">icon</span>=<span class="string">"el-icon-location"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 分页 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-pagination</span> @<span class="attr">size-change</span>=<span class="string">"handleSizeChange"</span> @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span> <span class="attr">:current-page</span>=<span class="string">"queryInfo.pagenum"</span> <span class="attr">:page-sizes</span>=<span class="string">"[3, 5, 10, 15]"</span> <span class="attr">:page-size</span>=<span class="string">"queryInfo.pagesize"</span> <span class="attr">layout</span>=<span class="string">"total, sizes, prev, pager, next, jumper"</span> <span class="attr">:total</span>=<span class="string">"total"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      //查询条件</span></span><br><span class="line"><span class="xml">      queryInfo: &#123;</span></span><br><span class="line"><span class="xml">        query: '',</span></span><br><span class="line"><span class="xml">        pagenum: 1,</span></span><br><span class="line"><span class="xml">        pagesize: 10</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      //订单列表数据</span></span><br><span class="line"><span class="xml">      orderList: [],</span></span><br><span class="line"><span class="xml">      //数据总条数</span></span><br><span class="line"><span class="xml">      total: 0</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created() &#123;</span></span><br><span class="line"><span class="xml">    this.getOrderList()</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  methods: &#123;</span></span><br><span class="line"><span class="xml">    async getOrderList() &#123;</span></span><br><span class="line"><span class="xml">      const &#123; data: res &#125; = await this.$http.get('orders', &#123;</span></span><br><span class="line"><span class="xml">        params: this.queryInfo</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">      if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="xml">        return this.$message.error('获取订单列表数据失败!')</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">      this.total = res.data.total</span></span><br><span class="line"><span class="xml">      this.orderList = res.data.goods</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    handleSizeChange(newSize)&#123;</span></span><br><span class="line"><span class="xml">        this.queryInfo.pagesize = newSize</span></span><br><span class="line"><span class="xml">        this.getOrderList()</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    handleCurrentChange(newPage)&#123;</span></span><br><span class="line"><span class="xml">        this.queryInfo.pagenum = newPage</span></span><br><span class="line"><span class="xml">        this.getOrderList()</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="D-制作省市区县联动"><a href="#D-制作省市区县联动" class="headerlink" title="D.制作省市区县联动"></a>D.制作省市区县联动</h4><p>打开今天的资料，找到素材文件夹，复制citydata.js文件到components/order文件夹中<br>然后导入citydata.js文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> cityData <span class="keyword">from</span> <span class="string">"./citydata.js"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//给修改地址按钮添加点击事件</span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span> @<span class="attr">click</span>=<span class="string">"showEditAddress"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">//添加修改地址对话框,在卡片视图下方添加</span><br><span class="line"><span class="comment">&lt;!-- 修改地址对话框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">"修改收货地址"</span> <span class="attr">:visible.sync</span>=<span class="string">"addressVisible"</span> <span class="attr">width</span>=<span class="string">"50%"</span> @<span class="attr">close</span>=<span class="string">"addressDialogClosed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加表单 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"addressForm"</span> <span class="attr">:rules</span>=<span class="string">"addressFormRules"</span> <span class="attr">ref</span>=<span class="string">"addressFormRef"</span> <span class="attr">label-width</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"省市区县"</span> <span class="attr">prop</span>=<span class="string">"address1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-cascader</span> <span class="attr">:options</span>=<span class="string">"cityData"</span> <span class="attr">v-model</span>=<span class="string">"addressForm.address1"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-cascader</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"详细地址"</span> <span class="attr">prop</span>=<span class="string">"address2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addressForm.address2"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"dialog-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"addressVisible = false"</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"addressVisible = false"</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//js部分的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> cityData <span class="keyword">from</span> <span class="string">"./citydata.js"</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      ......</span><br><span class="line"><span class="actionscript">      <span class="comment">//控制修改地址对话框的显示和隐藏</span></span></span><br><span class="line"><span class="actionscript">      addressVisible:<span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//修改收货地址的表单</span></span></span><br><span class="line">      addressForm:&#123;</span><br><span class="line">          address1:[],</span><br><span class="line"><span class="actionscript">          address2:<span class="string">''</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      addressFormRules:&#123;</span><br><span class="line"><span class="actionscript">          address1:[&#123; required: <span class="literal">true</span>, message: <span class="string">'请选择省市区县'</span>, trigger: <span class="string">'blur'</span> &#125;],</span></span><br><span class="line"><span class="actionscript">          address2:[&#123; required: <span class="literal">true</span>, message: <span class="string">'请输入详细地址'</span>, trigger: <span class="string">'blur'</span> &#125;],</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="comment">//将导入的cityData数据保存起来</span></span></span><br><span class="line">      cityData:cityData</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    ......</span><br><span class="line">    showEditAddress() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//当用户点击修改收货地址按钮时触发</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.addressVisible = <span class="literal">true</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    addressDialogClosed()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.addressFormRef.resetFields()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.el-cascader</span>&#123;</span></span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="E-制作物流进度对话框"><a href="#E-制作物流进度对话框" class="headerlink" title="E.制作物流进度对话框"></a>E.制作物流进度对话框</h4><p>因为我们使用的是element-ui中提供的Timeline组件，所以需要导入并注册组件<br>打开element.js,编写代码会进行导入和注册</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Timeline,TimelineItem</span><br><span class="line">&#125; from 'element-ui'</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(Timeline)</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(TimelineItem)</span><br></pre></td></tr></table></figure>
<p>打开Order.vue文件，添加代码实现物流进度对话框</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 物流信息进度对话框 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">"物流进度"</span> <span class="attr">:visible.sync</span>=<span class="string">"progressVisible"</span> <span class="attr">width</span>=<span class="string">"50%"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 时间线组件  --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-timeline</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-timeline-item</span> <span class="attr">v-for</span>=<span class="string">"(activity, index) in progressInfo"</span> </span></span></span><br><span class="line"><span class="xml">        :key="index" :timestamp="activity.time"&gt;</span></span><br><span class="line"><span class="xml">            </span><span class="template-variable">&#123;&#123;activity.context&#125;&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-timeline-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-timeline</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import cityData from './citydata.js'</span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      ......</span></span><br><span class="line"><span class="xml">      //控制物流进度对话框的显示和隐藏</span></span><br><span class="line"><span class="xml">      progressVisible: false,</span></span><br><span class="line"><span class="xml">      //保存物流信息</span></span><br><span class="line"><span class="xml">      progressInfo: []</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">  &#125;,methods: &#123;</span></span><br><span class="line"><span class="xml">    ......</span></span><br><span class="line"><span class="xml">    async showProgress() &#123;</span></span><br><span class="line"><span class="xml">      //发送请求获取物流数据</span></span><br><span class="line"><span class="xml">      const &#123; data: res &#125; = await this.$http.get('/kuaidi/804909574412544580')</span></span><br><span class="line"></span><br><span class="line"><span class="xml">      if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="xml">        return this.$message.error('获取物流进度失败!')</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      this.progressInfo = res.data</span></span><br><span class="line"><span class="xml">      //显示对话框</span></span><br><span class="line"><span class="xml">      this.progressVisible = true</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="F-推送代码"><a href="#F-推送代码" class="headerlink" title="F.推送代码"></a>F.推送代码</h4><p>将order分支代码推送至码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成订单列表功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将goods_list分支代码合并到master: git merge order<br>将master推送到码云：  git push</p>
<h3 id="3-数据统计"><a href="#3-数据统计" class="headerlink" title="3.数据统计"></a>3.数据统计</h3><h4 id="A-创建子分支"><a href="#A-创建子分支" class="headerlink" title="A.创建子分支"></a>A.创建子分支</h4><p>创建report子分支并推送到码云<br>创建report子分支: git checkout -b report<br>将report分支推送到码云： git push -u origin report</p>
<h4 id="B-创建路由-1"><a href="#B-创建路由-1" class="headerlink" title="B.创建路由"></a>B.创建路由</h4><p>创建数据统计路由组件并添加路由规则</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">//在components中新建report文件夹，新建Report.vue组件，组件中添加代码如下</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>数据报表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; path: '/home' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>数据统计<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>数据报表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span><span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  data() &#123;</span></span><br><span class="line"><span class="template-variable">    return &#123;</span></span><br><span class="line"><span class="template-variable"></span></span><br><span class="line"><span class="template-variable">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,created()</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable"></span></span><br><span class="line"><span class="template-variable">  &#125;</span><span class="xml">,methods:</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable"></span></span><br><span class="line"><span class="template-variable">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>打开router.js，导入Report.vue并设置路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Report from <span class="string">'./components/report/Report.vue'</span></span><br><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/categories"</span>, <span class="string">component:</span> Cate  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/params"</span>, <span class="string">component:</span> Params  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/goods"</span>, <span class="string">component:</span> GoodList  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/goods/add"</span>, <span class="string">component:</span> GoodAdd  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/orders"</span>, <span class="string">component:</span> Order  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/reports"</span>, <span class="string">component:</span> Report  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="C-导入ECharts并使用"><a href="#C-导入ECharts并使用" class="headerlink" title="C.导入ECharts并使用"></a>C.导入ECharts并使用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>数据报表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>数据统计<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>数据报表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width:750px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//导入echarts</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//导入lodash</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//需要跟请求的折线图数据合并的options</span></span></span><br><span class="line">      options: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line"><span class="actionscript">          text: <span class="string">'用户来源'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line"><span class="actionscript">          trigger: <span class="string">'axis'</span>,</span></span><br><span class="line">          axisPointer: &#123;</span><br><span class="line"><span class="actionscript">            type: <span class="string">'cross'</span>,</span></span><br><span class="line">            label: &#123;</span><br><span class="line"><span class="actionscript">              backgroundColor: <span class="string">'#E9EEF3'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line"><span class="actionscript">          left: <span class="string">'3%'</span>,</span></span><br><span class="line"><span class="actionscript">          right: <span class="string">'4%'</span>,</span></span><br><span class="line"><span class="actionscript">          bottom: <span class="string">'3%'</span>,</span></span><br><span class="line"><span class="actionscript">          containLabel: <span class="literal">true</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: [</span><br><span class="line">          &#123;</span><br><span class="line"><span class="actionscript">            boundaryGap: <span class="literal">false</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        yAxis: [</span><br><span class="line">          &#123;</span><br><span class="line"><span class="actionscript">            type: <span class="string">'value'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line"><span class="javascript">  <span class="keyword">async</span> mounted() &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//在页面dom元素加载完毕之后执行的钩子函数mounted</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>))</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//准备数据和配置项</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//发送请求获取折线图数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'reports/type/1'</span>)</span></span><br><span class="line"></span><br><span class="line">    if (res.meta.status !== 200) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取折线图数据失败'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//合并res.data和this.options</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> result = _.merge(res.data,<span class="keyword">this</span>.options)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 使用获取的数据展示图表</span></span></span><br><span class="line">    myChart.setOption(result)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="D-推送代码-1"><a href="#D-推送代码-1" class="headerlink" title="D.推送代码"></a>D.推送代码</h4><p>推送report分支到码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成数据报表功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将report分支代码合并到master: git merge report<br>将master推送到码云：  git push</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>token、cookie和session</title>
    <url>/2020/03/03/%E9%9D%A2%E7%BB%8F04/</url>
    <content><![CDATA[<h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><ul>
<li>很久以前，web基本上就是文档的浏览而已，既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议，就是请求加响应，尤其是我不用记住是谁刚刚发送了HTTP请求，每个请求对我来说都是全新的。</li>
<li>但是随着交互式web应用的兴起，像在线购物网站，需要登陆的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统，哪些人往自己的购物车中放商品，也就是说我必须要把每个人都区分开，因为HTTP请求是无状态的，所以相处的办法就是给大家发一个会话标识（session id ），说白了就是一个随机字符串，每个人收到的都不一样，每次大家向我发起请求的时候，把这个字符串一起发送过来，这样我就能区分开谁是谁了。<a id="more"></a></li>
<li>这样的话，服务器的压力就增加了，每个人只需要保存自己的session id，而服务器要保存所有人的session id。</li>
<li>于是就有人在思考，为什么服务器一定要保存session呢？直接让每个客户端去保存就可以了。可是如果不保存这些session id，服务器怎么验证客户端发给服务器的session id的确是它生成的呢？所以关键点就在于验证。</li>
</ul>
<p>比如说小a已经登陆了系统，我给他发一个令牌（token），里边包含了小a的user id，下一次小a再次通过HTTP请求访问服务器的时候，把这个token通过http header带过来就可以了。</p>
<p>不过这和session没有本质区别，任何人都可以伪造，所以要想个办法让别人伪造不了</p>
<p>对数组做一个签名！比如说服务器使用HMAC-SHA256算法，加上一个只有服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于密钥别人不知道，就无法伪造token了。这个token服务器不保存，当用户小a把这个token发送给服务器的时候，服务器再用同样的HMAC-SHA256算法和同样的密钥，对数据再做计算一次签名，和token中的签名做个比较，如果相同，就知道小a已经登陆过了，并且可以直接取到小a的user id，如果不相同，数据部分肯定被人纂改过，就可以发送给小a：对不起，没有认证。</p>
<p>token中的数据是明文保存的（虽然服务器会有base64做一下编码，但是那不是加密），还是可以被别人看见的，所以服务器不能在其中保存像密码那样敏感的信息。</p>
<p>但是如果一个人的token被偷走了，服务器就会认为小偷是合法用户，就跟一个人的session id被别人偷走一样。</p>
<p>这样一来，服务器就不用保存session id了，它只是生成token，然后用它的CPU计算时间获取了session存储空间。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是一个非常具体的东西，值得就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。<br><span style="color: red">cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件中，下一次请求同一网站时会把该cookie发送给服务器。所以cookie是存储在客户端上的</span>，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量都是有限的。</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session从字面上将，就是会话。这个就类似于和一个人交谈我们要怎么知道当前交谈的是张三而不是李四呢？<br>sission就是类似的道理，服务器要知道当前发送请求给自己的是谁。为了做这种区分，<span style="color: red">服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发送请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了</span>至于客户端怎么保存这个“身份标识”，可以由很多种方式，对于浏览器客户端，大家都默认采用cookie的方式。</p>
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了均衡负载，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><ul>
<li>token的引入： token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行比对，判断用户名和密码正确与否，并作出响应提示，在这样的背景下，token便产生了。</li>
<li>token的定义：token是服务端生成的遗传字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。最贱的token组成<code>uid（用户唯一的身份标识）、time（当前的时间戳）、sign（签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，可以放置恶意第三方拼接token请求服务器）</code></li>
<li>使用token的目的：token的目的是为了减轻服务器的压力，减少插叙数据库，使服务器更加健壮。</li>
</ul>
<p>token的特性：</p>
<ul>
<li>无状态、可扩展</li>
<li>支持移动设备</li>
<li>跨程序调用</li>
<li>安全<br>大部分的API和web应用都是用tokens，例如facebook、twitter、google等</li>
</ul>
<p>使用token的身份验证是无状态的，我们不用讲信息存在服务器或者是session中。</p>
<h3 id="传统身份验证"><a href="#传统身份验证" class="headerlink" title="传统身份验证"></a>传统身份验证</h3><p>HTTP是一种没有状态的协议，也就是它并不知道是谁访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求的时候，还得再验证一下。</p>
<p>解决的办法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登陆的用户是谁，然后把这条记录的id号发送给客户端，客户端收到以后把这个id号存储在cookie里，下次这个用户再向服务端发送请求的时候，可以带着这个cookie，这样服务端会验证这个cookie里的信息，看看能不能在服务端找到对应的记录，如果可以说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p>
<p>上面说的就是session，我们需要在服务端存储为登录的用户生成的session，这些session可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的清理过期的session</p>
<h3 id="基于token的身份验证"><a href="#基于token的身份验证" class="headerlink" title="基于token的身份验证"></a>基于token的身份验证</h3><p>使用token的身份验证方法，在服务端不需要存储用户的登录行为。大概的流程是这样的：</p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个token，再把这个token发送给客户端</li>
<li>客户端收到token后把它存储起来，比如放在cookie或者localstorage里面</li>
<li>客户端每次向服务器请求资源的时候需要带着服务端签发的token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求的数据</li>
</ul>
<p>app登录的时候 发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到app，以后app请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，重新登陆。其中服务器上token设置一个有效期，每次app请求的时候都要验证token和有效期。</p>
<p>每一次请求都需要token，token应该在HTTP头部发送从而保证了HTTP的请求无状态。我们同样通过设置服务器属性<code>Acess-Control-Allow-Origin:*</code>让服务器能接收到所有域的请求。</p>
<p>问题：1、服务器上的token存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢？2、客户端得到的token肯定要加密存储的，发送token的时候再解密，存储到数据库还是配置文件呢？</p>
<p>token是一个易失数据，丢了无非让用户重新登录一下，如果觉得普通的数据库表撑不住了，可以放到MSSQL/MYSQL的内存表里，可以放到memcache里，可以放到redis里，甚至可以放到openresty的变量字典里。</p>
<p>token是个凭条，token丢失的呆久是可以忍受的，只需要重新认证一下就可以了</p>
<p>基于这个出发点，如果我们认为使用数据库来保存token查询事件太长，会成为我们系统的瓶颈或者隐患，可以放在内存当中。比如memcache、redis、kv方式很适合对token方式的查询的需求。<br>这个不会太占内存，比如token的字符串时32位字符串，要是用户量在百万级或千万级，也没有多少内存。要是数据量真的大到单机扛不住，或者存在数据丢失风险，只要这个token生成时足够均匀的，高低位切一下分到不同的机器上就可以了，内存绝对不是一个问题。</p>
<p>客户端方面除非我们有一个非常安全的办法，比如操作系统提供的隐私数据存储，那token肯定会存在泄露的文通。比如我拿你的收集，把你的token拷贝出来，在过期之前都可以以你的身份在别的地方登录。<br>解决这个问题的一个简单办法：</p>
<ul>
<li>在存储的时候把token进行对称加密，用时解开</li>
<li>将请求URL、时间戳、token三者进行合并盐签名，服务端校验有效性</li>
</ul>
<p>这两种办法的出发点都是，窃取你存储的数据较为容易，而反汇编你的程序hack你的加密解密和签名算法是比较难的。方法1它拿到的存储密文解不开，方法2它不知道你的签名算法和盐，两者可以结合使用。</p>
<p>在网络上token铭文传输的话会非常危险，所以建议一定要使用HTTPs，并且把token放在post body<br>里</p>
<h3 id="token的优势"><a href="#token的优势" class="headerlink" title="token的优势"></a>token的优势</h3><ul>
<li>无状态、可扩展<br>在客户端存储的tokens是无状态的，并且能够被扩展。基于这种无状态和不存储session信息，负载均衡器能够将用户信息从一个服务器传到其他服务器上。</li>
</ul>
<p>如果我们将已验证的用户的信息保存在session中，则每次请求都需要用户向已验证的服务器发送验证信息。用户量大时可能会造成一些拥堵。使用token之后，这些问题都解决了，因为tokens自己hold住了用户的验证信息</p>
<ul>
<li>安全性<br>请求中发送token而不再是发送cookie能够防止CSRF。即使在客户端使用cokkie存储token、cookie也仅仅是一个存储机制而不是用于认证。不讲信息存储在session中，让我们少了对session的操作。</li>
</ul>
<p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或者是一组有相同认证的token无效</p>
<ul>
<li><p>可扩展性<br>tokens能够创建与其他程序共享权限的程序。例如，能将一个随便的社交账号和自己的大号联系起来。当通过服务登录twitter时，我们可以将这些buffer附到twitter的数据流上。使用token时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens</p>
</li>
<li><p>多平台跨域<br>只要用户有一个听过了验证的token，数据和资源能够在任何域上被请求到。</p>
</li>
<li><p>基于标准<br>创建token的时候，我们可以设定一些选项。</p>
</li>
</ul>
<h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul>
<li>cookie数据存储在客户端上，session数据发在服务器上</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie七篇，考虑到安全应当使用session</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li>
<li>单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie</li>
<li>所以：将登录信息等重要信息存放位session，其他信息如果需要保留，可以放在cookie中</li>
</ul>
<h3 id="session和token的区别"><a href="#session和token的区别" class="headerlink" title="session和token的区别"></a>session和token的区别</h3><p>session和token并不矛盾，作为身份认证，token安全性比session好，因为每个请求都有签名还能防止监听以及重防攻击，而session就必须靠链路层来保障通讯安全了。如果我们需要实现有状态的会话，仍然可以增加session来在服务端保存一些状态</p>
<p>app通常用restful api跟server打交道。rest是stateless的，也就是app不需要像brower那样用cookie来保存session，因此用session token标识自己就够了，session/state由阿皮server的逻辑处理。如果后端不是stateless的rest api，那么可能需要在app里保存session，可以在app里嵌入webkit，用一个隐藏的browser来管理cookie session </p>
<p>session是一种HTTP存储机制，目的是为了无状态的HTTP提供的持久机制。所谓session认证只是简单的把user信息存储到session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而token，如果值得是OAuth token或类似的机制的话，提供的是认证和授权，认证是针对用户，授权是针对app。其目的是让某app有权利访问某用户啊的信息。这里的token是唯一的，不可转移到其他app上，也不可以转到其他用户上。转过来说session。session只提供一种简单的认证，即有此SID，即认为有此user的全部权力。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其他网站或者第三方app。所以简单来说，如果你的用户数据可能需要和第三方共享，或者第三方调用API接口，用token。如果永远只自己的网站，自己的app，用什么就无所谓了。</p>
<p>注意：对于session；来说，除非程序通知服务器删除一个session，否则服务器会一致保留，程序一般都是在用户做log off的时候发个指令去删除session。</p>
<p>然而浏览器从来不会主动在关闭之前通知服务器它要挂壁，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次链接服务器时也无法找到原来的session。如果服务器设置的cookie被保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够打开原来的session</p>
<p>恰恰时由于关闭浏览器并不会导致session被删除，迫使服务器位session设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以以为客户端已经停止了活动，才会把session删除以节省存储空间。</p>
<p><a href="https://blog.csdn.net/qq_31201781/article/details/94575507" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>token、cookie和session</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/03/vue3-09/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.完成参数管理<br>2.推送代码到码云<br>3.制作商品列表页面<br>4.制作商品添加页面</p>
<a id="more"></a>
<h3 id="1-参数管理"><a href="#1-参数管理" class="headerlink" title="1.参数管理"></a>1.参数管理</h3><h4 id="A-展示动态参数可选项"><a href="#A-展示动态参数可选项" class="headerlink" title="A.展示动态参数可选项"></a>A.展示动态参数可选项</h4><p>动态参数可选项展示及操作<br>在获取动态参数的方法中进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将获取到的数据中的attr_vals字符串转换为数组</span></span><br><span class="line">res.data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  item.attr_vals = item.attr_vals ? item.attr_vals.split(<span class="string">' '</span>) : []</span><br><span class="line">  <span class="comment">//添加一个bool值控制文本框的显示或者隐藏</span></span><br><span class="line">  item.inputVisible = <span class="literal">false</span></span><br><span class="line">  <span class="comment">//添加一个inputValue保存文本框值</span></span><br><span class="line">  item.inputValue = <span class="string">''</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后再修改展开行中的代码，生成el-tag和文本框以及添加按钮</span></span><br><span class="line">&lt;!-- 展开行 --&gt;</span><br><span class="line">&lt;el-table-column type=<span class="string">"expand"</span>&gt;</span><br><span class="line">  &lt;template slot-scope=<span class="string">"scope"</span>&gt;</span><br><span class="line">    &lt;!-- 循环生成的el-tag --&gt;</span><br><span class="line">    &lt;el-tag v-<span class="keyword">for</span>=<span class="string">"(item,i) in scope.row.attr_vals"</span> :key=<span class="string">"i"</span> closable&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/el-tag&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-input class="input-new-tag" v-if="scope.row.inputVisible" v-model="scope.row.inputValue" ref="saveTagInput" size="small" @keyup.enter.native="handleInputConfirm(scope.row)" @blur="handleInputConfirm(scope.row)"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-input&gt;</span><br><span class="line">    &lt;!-- 添加按钮 --&gt;</span><br><span class="line">    &lt;el-button v-<span class="keyword">else</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"button-new-tag"</span> size=<span class="string">"small"</span> @click=<span class="string">"showInput(scope.row)"</span>&gt;+ New Tag&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/el-table-column&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/最后对应文本框的事件和按钮的事件添加处理函数</span></span><br><span class="line"><span class="regexp">handleInputConfirm(row)&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/当用户在文本框中按下enter键或者焦点离开时都会触发执行</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/判断用户在文本框中输入的内容是否合法</span></span><br><span class="line"><span class="regexp">  if(row.inputValue.trim().length===0)&#123;</span></span><br><span class="line"><span class="regexp">    row.inputValue = ''</span></span><br><span class="line"><span class="regexp">    row.inputVisible = false</span></span><br><span class="line"><span class="regexp">    return</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ row.inputVisible = false</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/如果用户输入了真实合法的数据，需要保存起来</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">showInput(row)&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/用户点击添加按钮时触发</span></span><br><span class="line"><span class="regexp">  row.inputVisible = true</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/$nextTick:在页面上元素被重新渲染之后，调用回调函数的代码</span></span><br><span class="line"><span class="regexp">  this.$nextTick(_=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/让文本框自动获得焦点</span></span><br><span class="line"><span class="regexp">    this.$refs.saveTagInput.$refs.input.focus()</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="B-添加-删除可选项"><a href="#B-添加-删除可选项" class="headerlink" title="B.添加/删除可选项"></a>B.添加/删除可选项</h4><p>添加/删除动态参数可选项</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">给el-tag添加删除事件</span><br><span class="line">&lt;el-tag v-<span class="keyword">for</span>=<span class="string">"(item,i) in scope.row.attr_vals"</span> :key=<span class="string">"i"</span> closable @close=<span class="string">"handleClose(i,scope.row)"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/el-tag&gt;</span><br><span class="line"></span><br><span class="line">在methods中添加新增，删除事件处理函数</span><br><span class="line"><span class="function"><span class="title">handleInputConfirm</span><span class="params">(row)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当用户在文本框中按下enter键或者焦点离开时都会触发执行</span></span><br><span class="line">  <span class="comment">//判断用户在文本框中输入的内容是否合法</span></span><br><span class="line">  <span class="keyword">if</span>(row<span class="selector-class">.inputValue</span>.trim().length===<span class="number">0</span>)&#123;</span><br><span class="line">    row<span class="selector-class">.inputValue</span> = <span class="string">''</span></span><br><span class="line">    row<span class="selector-class">.inputVisible</span> = false</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// row.inputVisible = false</span></span><br><span class="line">  <span class="comment">//如果用户输入了真实合法的数据，需要保存起来</span></span><br><span class="line">  row<span class="selector-class">.attr_vals</span>.push(row<span class="selector-class">.inputValue</span>.trim())</span><br><span class="line">  row<span class="selector-class">.inputValue</span> = <span class="string">''</span></span><br><span class="line">  row<span class="selector-class">.inputVisible</span> = false</span><br><span class="line"></span><br><span class="line">  this.saveAttrVals(row)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">handleClose</span><span class="params">(index,row)</span></span>&#123;</span><br><span class="line">  <span class="comment">//删除对应索引的参数可选项</span></span><br><span class="line">  row<span class="selector-class">.attr_vals</span>.splice(index,<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//调用函数，完成保存可选项的操作</span></span><br><span class="line">  this.saveAttrVals(row)</span><br><span class="line">&#125;,</span><br><span class="line">async saveAttrVals(row)&#123;</span><br><span class="line">  <span class="comment">//封装函数，完成保存可选项的操作</span></span><br><span class="line">  <span class="comment">//发起请求，保存参数细项</span></span><br><span class="line">  const &#123;data:res&#125; = await this.<span class="variable">$http</span>.put(`categories/$&#123;this.cateId&#125;/attributes/$&#123;row.attr_id&#125;`,</span><br><span class="line">  &#123;attr_name:row<span class="selector-class">.attr_name</span>,attr_sel:row<span class="selector-class">.attr_sel</span>,attr_vals:row<span class="selector-class">.attr_vals</span>.join(<span class="string">' '</span>)&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res<span class="selector-class">.meta</span><span class="selector-class">.status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    return this.<span class="variable">$message</span>.error(<span class="string">'修改参数项失败'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.<span class="variable">$message</span>.success(<span class="string">'修改参数项成功'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：当用户在级联选择框中选中了非三级分类时，需要清空表格中数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">async handleChange() &#123;</span><br><span class="line">      <span class="comment">//如果用户选择的不是三级分类</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.selectedCateKeys.length !== <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectedCateKeys = []</span><br><span class="line">        <span class="keyword">this</span>.manyTableData = []</span><br><span class="line">        <span class="keyword">this</span>.onlyTableData = []</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>

<p>补充2：当完成了动态参数可选项的功能之后，我们也需要一样的方式完成静态属性可选项的功能。</p>
<p>此时我们只需要将动态参数可选项中的展开行复制到静态属性的表格中即可</p>
<h3 id="2-推送代码到码云"><a href="#2-推送代码到码云" class="headerlink" title="2.推送代码到码云"></a>2.推送代码到码云</h3><p>添加到暂存求： git add .<br>提交到本地仓库：  git commit -m ‘完成了分类参数开发’<br>推送到码云：  git push<br>切换到master ： git checkout master<br>合并到master ： git merge goods_params</p>
<p>创建子分支<br>git checkout -b goods_list<br>推送至码云 git push -u origin goods_list</p>
<h3 id="3-商品列表"><a href="#3-商品列表" class="headerlink" title="3.商品列表"></a>3.商品列表</h3><h4 id="A-制作商品列表基本结构"><a href="#A-制作商品列表基本结构" class="headerlink" title="A.制作商品列表基本结构"></a>A.制作商品列表基本结构</h4><p>添加子级路由组件以及对应的规则,并设置组件的基本机构<br>打开router.js,添加下面的代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GoodList from <span class="string">'./components/goods/List.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/categories"</span>, <span class="string">component:</span> Cate  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/params"</span>, <span class="string">component:</span> Params  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/goods"</span>, <span class="string">component:</span> GoodList  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>打开List.vue组件，添加下列代码</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>商品列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; path: '/home' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品列表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">"20"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  data() &#123;</span></span><br><span class="line"><span class="template-variable">    return &#123;&#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created() </span><span class="template-variable">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  methods: </span><span class="template-variable">&#123;&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="B-数据展示"><a href="#B-数据展示" class="headerlink" title="B.数据展示"></a>B.数据展示</h4><p>添加数据表格展示数据以及分页功能的实现,搜索功能的实现<br>在main.js中添加过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建过滤器将秒数过滤为年月日，时分秒</span></span><br><span class="line">Vue.filter(<span class="string">'dateFormat'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">originVal</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> m = (dt.getMonth()+<span class="number">1</span>+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> d = (dt.getDate()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds()+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 搜索栏 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">"20"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span> <span class="attr">v-model</span>=<span class="string">"queryInfo.query"</span> <span class="attr">clearable</span> @<span class="attr">clear</span>=<span class="string">"getGoodsList"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span> @<span class="attr">click</span>=<span class="string">"getGoodsList"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 表格区域 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"goodsList"</span> <span class="attr">border</span> <span class="attr">stripe</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"商品名称"</span> <span class="attr">prop</span>=<span class="string">"goods_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"商品价格(元)"</span> <span class="attr">prop</span>=<span class="string">"goods_price"</span> <span class="attr">width</span>=<span class="string">"95px"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"商品重量"</span> <span class="attr">prop</span>=<span class="string">"goods_weight"</span> <span class="attr">width</span>=<span class="string">"95px"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"创建时间"</span> <span class="attr">prop</span>=<span class="string">"add_time"</span> <span class="attr">width</span>=<span class="string">"140px"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="template-variable">&#123;&#123;scope.row.add_time | dateFormat&#125;&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span> <span class="attr">width</span>=<span class="string">"125px"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 分页 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-pagination</span> @<span class="attr">size-change</span>=<span class="string">"handleSizeChange"</span> @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span> <span class="attr">:current-page</span>=<span class="string">"queryInfo.pagenum"</span> <span class="attr">:page-sizes</span>=<span class="string">"[3, 5, 10, 15]"</span> <span class="attr">:page-size</span>=<span class="string">"queryInfo.pagesize"</span> <span class="attr">layout</span>=<span class="string">"total, sizes, prev, pager, next, jumper"</span> <span class="attr">:total</span>=<span class="string">"total"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//绑定数据以及添加方法</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      //查询参数</span></span><br><span class="line"><span class="xml">      queryInfo: &#123;</span></span><br><span class="line"><span class="xml">        query: '',</span></span><br><span class="line"><span class="xml">        pagenum: 1,</span></span><br><span class="line"><span class="xml">        pagesize: 10</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">      //保存商品列表信息</span></span><br><span class="line"><span class="xml">      goodsList: [],</span></span><br><span class="line"><span class="xml">      //总数据条数</span></span><br><span class="line"><span class="xml">      total: 0</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  created() &#123;</span></span><br><span class="line"><span class="xml">    this.getGoodsList()</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  methods: &#123;</span></span><br><span class="line"><span class="xml">    async getGoodsList() &#123;</span></span><br><span class="line"><span class="xml">      //   根据分页获取对应的商品列表</span></span><br><span class="line"><span class="xml">      const &#123; data: res &#125; = await this.$http.get('goods', &#123;</span></span><br><span class="line"><span class="xml">        params: this.queryInfo</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">      if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="xml">        return this.$message.error('获取商品列表失败')</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      console.log(res.data)</span></span><br><span class="line"><span class="xml">      this.$message.success('获取商品列表成功')</span></span><br><span class="line"><span class="xml">      this.goodsList = res.data.goods</span></span><br><span class="line"><span class="xml">      this.total = res.data.total</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    handleSizeChange(newSize)&#123;</span></span><br><span class="line"><span class="xml">        //当页号发生改变时，更改pagesize，重新请求</span></span><br><span class="line"><span class="xml">        this.queryInfo.pagesize = newSize</span></span><br><span class="line"><span class="xml">        this.getGoodsList();</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    handleCurrentChange(newPage)&#123;</span></span><br><span class="line"><span class="xml">        //当页码发生改变时，更改pagesize，重新请求</span></span><br><span class="line"><span class="xml">        this.queryInfo.pagenum = newPage</span></span><br><span class="line"><span class="xml">        this.getGoodsList();</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="C-实现删除商品"><a href="#C-实现删除商品" class="headerlink" title="C.实现删除商品"></a>C.实现删除商品</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定按钮点击事件</span></span><br><span class="line">&lt;el-button size=<span class="string">"mini"</span> type=<span class="string">"danger"</span> icon=<span class="string">"el-icon-delete"</span> <span class="meta">@click</span>=<span class="string">"removeGoods(scope.row.goods_id)"</span>&gt;&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件函数代码编写</span></span><br><span class="line">async removeGoods(goods_id) &#123;</span><br><span class="line">  <span class="comment">//根据id删除对应的参数或属性</span></span><br><span class="line">  <span class="comment">//弹窗提示用户是否要删除</span></span><br><span class="line">  <span class="keyword">const</span> confirmResult = await <span class="keyword">this</span>.$confirm(</span><br><span class="line">    <span class="string">'请问是否要删除该商品'</span>,</span><br><span class="line">    <span class="string">'删除提示'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      confirmButtonText: <span class="string">'确认删除'</span>,</span><br><span class="line">      cancelButtonText: <span class="string">'取消'</span>,</span><br><span class="line">      type: <span class="string">'warning'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).<span class="keyword">catch</span>(err =&gt; err)</span><br><span class="line">  <span class="comment">//如果用户点击确认，则confirmResult 为'confirm'</span></span><br><span class="line">  <span class="comment">//如果用户点击取消, 则confirmResult获取的就是catch的错误消息'cancel'</span></span><br><span class="line">  <span class="keyword">if</span> (confirmResult != <span class="string">'confirm'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$message.info(<span class="string">'已经取消删除'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//没有取消就是要删除，发送请求完成删除</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.delete(`goods/$&#123;goods_id&#125;`)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'删除商品失败'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$message.success(<span class="string">'删除商品成功'</span>)</span><br><span class="line">  <span class="keyword">this</span>.getGoodsList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-添加商品"><a href="#4-添加商品" class="headerlink" title="4.添加商品"></a>4.添加商品</h3><h4 id="A-添加编程式导航"><a href="#A-添加编程式导航" class="headerlink" title="A.添加编程式导航"></a>A.添加编程式导航</h4><p>在List.vue中添加编程式导航，并创建添加商品路由组件及规则</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//在List.vue中添加编程式导航</span><br><span class="line">&lt;<span class="keyword">el</span>-<span class="keyword">col</span> :span=<span class="string">"4"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">el</span>-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"goAddPage"</span>&gt;添加商品&lt;/<span class="keyword">el</span>-button&gt;</span><br><span class="line">&lt;/<span class="keyword">el</span>-<span class="keyword">col</span>&gt;</span><br><span class="line"></span><br><span class="line">goAddPage()&#123;</span><br><span class="line">    this.$router.push(<span class="string">'/goods/add'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在router.js中引入goods/Add.vue,并添加路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GoodAdd from <span class="string">'./components/goods/Add.vue'</span></span><br><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/categories"</span>, <span class="string">component:</span> Cate  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/params"</span>, <span class="string">component:</span> Params  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/goods"</span>, <span class="string">component:</span> GoodList  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/goods/add"</span>, <span class="string">component:</span> GoodAdd  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="B-布局Add-vue组件"><a href="#B-布局Add-vue组件" class="headerlink" title="B.布局Add.vue组件"></a>B.布局Add.vue组件</h4><p>布局过程中需要使用Steps组件，在element.js中引入并注册该组件，并在global.css中给组件设置全局样式</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Steps,<span class="keyword">Step</span>&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line">Vue.use(<span class="keyword">Step</span>)</span><br><span class="line">Vue.use(Steps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//global.css</span></span><br><span class="line">.el-steps&#123;</span><br><span class="line">    margin:<span class="number">15</span>px <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.el-step__title&#123;</span><br><span class="line">    font-<span class="keyword">size</span>: <span class="number">13</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在Add.vue中进行页面布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"&#123; path: '/home' &#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息提示 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-alert</span> <span class="attr">title</span>=<span class="string">"添加商品信息"</span> <span class="attr">type</span>=<span class="string">"info"</span> <span class="attr">center</span> <span class="attr">show-icon</span> <span class="attr">:closable</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-alert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 步骤条组件 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- align-center(居中效果) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-steps</span> <span class="attr">:space</span>=<span class="string">"200"</span> <span class="attr">:active</span>=<span class="string">"activeIndex - 0"</span> <span class="attr">finish-status</span>=<span class="string">"success"</span> <span class="attr">align-center</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"基本信息"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"商品参数"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"商品属性"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"商品图片"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"商品内容"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-step</span> <span class="attr">title</span>=<span class="string">"完成"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-step</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-steps</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- tab栏区域:el-tab-pane必须是el-tabs的子节点</span></span><br><span class="line"><span class="comment">            :tab-position="'left'"(设置tab栏为左右结构tab栏) --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 表单：label-position="top"(设置label在文本框上方) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"addForm"</span> <span class="attr">:rules</span>=<span class="string">"addFormRules"</span> <span class="attr">ref</span>=<span class="string">"addFormRef"</span> <span class="attr">label-width</span>=<span class="string">"100px"</span> <span class="attr">label-position</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-tabs</span> <span class="attr">v-model</span>=<span class="string">"activeIndex"</span> <span class="attr">:tab-position</span>=<span class="string">"'left'"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"基本信息"</span> <span class="attr">name</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"商品名称"</span> <span class="attr">prop</span>=<span class="string">"goods_name"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"商品价格"</span> <span class="attr">prop</span>=<span class="string">"goods_price"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_price"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"商品重量"</span> <span class="attr">prop</span>=<span class="string">"goods_weight"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_weight"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"商品数量"</span> <span class="attr">prop</span>=<span class="string">"goods_number"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_number"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"商品分类"</span> <span class="attr">prop</span>=<span class="string">"goods_cat"</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 选择商品分类的级联选择框 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-cascader</span> <span class="attr">expandTrigger</span>=<span class="string">'hover'</span> <span class="attr">v-model</span>=<span class="string">"addForm.goods_cat"</span> <span class="attr">:options</span>=<span class="string">"cateList"</span> <span class="attr">:props</span>=<span class="string">"cateProps"</span> @<span class="attr">change</span>=<span class="string">"handleChange"</span> <span class="attr">clearable</span>&gt;</span><span class="tag">&lt;/<span class="name">el-cascader</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"商品参数"</span> <span class="attr">name</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"商品属性"</span> <span class="attr">name</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"商品图片"</span> <span class="attr">name</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"商品内容"</span> <span class="attr">name</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-tabs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//保存步骤条激活项索引</span></span></span><br><span class="line"><span class="actionscript">      activeIndex: <span class="string">'0'</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//添加商品的表单数据对象</span></span></span><br><span class="line">      addForm: &#123;</span><br><span class="line"><span class="actionscript">        goods_name: <span class="string">''</span>,</span></span><br><span class="line">        goods_price: 0,</span><br><span class="line">        goods_weight: 0,</span><br><span class="line">        goods_number: 0,</span><br><span class="line">        goods_cat:[]</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="comment">//验证规则</span></span></span><br><span class="line">      addFormRules: &#123;</span><br><span class="line">        goods_name: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入商品名称'</span>, trigger: <span class="string">'blur'</span> &#125;</span></span><br><span class="line">        ],</span><br><span class="line">        goods_price: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入商品价格'</span>, trigger: <span class="string">'blur'</span> &#125;</span></span><br><span class="line">        ],</span><br><span class="line">        goods_weight: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入商品重量'</span>, trigger: <span class="string">'blur'</span> &#125;</span></span><br><span class="line">        ],</span><br><span class="line">        goods_number: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入商品数量'</span>, trigger: <span class="string">'blur'</span> &#125;</span></span><br><span class="line">        ],</span><br><span class="line">        goods_cat: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请选择商品分类'</span>, trigger: <span class="string">'blur'</span> &#125;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="comment">//用来保存分类数据</span></span></span><br><span class="line">      cateList: [],</span><br><span class="line"><span class="actionscript">      <span class="comment">//配置级联菜单中数据如何展示</span></span></span><br><span class="line">      cateProps: &#123;</span><br><span class="line"><span class="actionscript">        value: <span class="string">'cat_id'</span>,</span></span><br><span class="line"><span class="actionscript">        label: <span class="string">'cat_name'</span>,</span></span><br><span class="line"><span class="actionscript">        children: <span class="string">'children'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.getCateList()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> getCateList() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'categories'</span>)</span></span><br><span class="line"></span><br><span class="line">      if (res.meta.status !== 200) &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取商品分类数据失败'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.cateList = res.data</span></span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange()&#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//如果用户选择的不是三级分类,该次选择无效，因为必须选择三级分类</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_cat.length !== <span class="number">3</span>)&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.addForm.goods_cat = []</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="C-添加tab栏切换验证"><a href="#C-添加tab栏切换验证" class="headerlink" title="C.添加tab栏切换验证"></a>C.添加tab栏切换验证</h4><p>也就是说不输入某些内容，无法切换到别的tab栏</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先给tabs添加tab切换前事件</span></span><br><span class="line">&lt;el-tabs v-model=<span class="string">"activeIndex"</span> :tab-position=<span class="string">"'left'"</span> :before-leave=<span class="string">"beforeTabLeave"</span>&gt;</span><br><span class="line">......</span><br><span class="line">&lt;/el-tabs&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再到methods编写事件函数beforeTabLeave</span></span><br><span class="line">beforeTabLeave(activeName,oldActiveName)&#123;</span><br><span class="line">  <span class="comment">//在tab栏切换之前触发，两个形参为切换前，后的tab栏name</span></span><br><span class="line">  <span class="keyword">if</span>(oldActiveName === <span class="string">'0'</span>)&#123;</span><br><span class="line">      <span class="comment">//在第一个标签页的时候</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_cat.length !== <span class="number">3</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'请选择商品的分类'</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_name.trim() === <span class="string">''</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'请输入商品名称'</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_price.trim() === <span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'请输入商品价格'</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_weight.trim() === <span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'请输入商品重量'</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.addForm.goods_number.trim() === <span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'请输入商品数量'</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="D-展示信息"><a href="#D-展示信息" class="headerlink" title="D.展示信息"></a>D.展示信息</h4><p>展示商品参数信息,商品属性信息<br>在商品参数信息展示中使用的el-checkbox,el-checkbox-group组件，打开element.js引入组件并注册组件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在用户点击tab栏时触发事件</span></span><br><span class="line">&lt;el-tabs v-model=<span class="string">"activeIndex"</span> :tab-position=<span class="string">"'left'"</span> :before-leave=<span class="string">"beforeTabLeave"</span> <span class="meta">@tab</span>-click=<span class="string">"tabClicked"</span>&gt;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line"><span class="comment">//在参数信息，商品属性面板中添加循环生成结构的代码</span></span><br><span class="line">&lt;el-tab-pane label=<span class="string">"商品参数"</span> name=<span class="string">"1"</span>&gt;</span><br><span class="line">  &lt;!-- 渲染表单item项 --&gt;</span><br><span class="line">  &lt;el-form-item :label=<span class="string">"item.attr_name"</span> :key=<span class="string">"item.attr_id"</span> v-<span class="keyword">for</span>=<span class="string">"item in manyTableData"</span>&gt;</span><br><span class="line">      &lt;!-- 使用数组渲染复选框组 --&gt;</span><br><span class="line">      &lt;el-checkbox-group v-model=<span class="string">"item.attr_vals"</span>&gt;</span><br><span class="line">          &lt;el-checkbox border :label=<span class="string">"val"</span> v-<span class="keyword">for</span>=<span class="string">"(val,i) in item.attr_vals"</span> :key=<span class="string">"i"</span>&gt;&lt;/el-checkbox&gt;</span><br><span class="line">      &lt;/el-checkbox-group&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">&lt;/el-tab-pane&gt;</span><br><span class="line">&lt;el-tab-pane label=<span class="string">"商品属性"</span> name=<span class="string">"2"</span>&gt;</span><br><span class="line">  &lt;!-- 循环生成静态属性 --&gt;</span><br><span class="line">  &lt;el-form-item :label=<span class="string">"item.attr_name"</span> v-<span class="keyword">for</span>=<span class="string">"item in onlyTableData"</span> :key=<span class="string">"item.attr_id"</span>&gt;</span><br><span class="line">      &lt;el-input v-model=<span class="string">"item.attr_vals"</span>&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">&lt;/el-tab-pane&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在data数据中添加保存动态参数和静态属性的数组</span></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">//动态参数列表</span></span><br><span class="line">      manyTableData: [],</span><br><span class="line">      <span class="comment">//静态属性列表</span></span><br><span class="line">      onlyTableData:[]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    .......</span><br><span class="line">    async tabClicked() &#123;</span><br><span class="line">      <span class="comment">//当用户点击切换tab栏时触发</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.activeIndex === <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="comment">//发送请求获取动态参数</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(</span><br><span class="line">          `categories/$&#123;<span class="keyword">this</span>.cateId&#125;/attributes`,</span><br><span class="line">          &#123; params: &#123; sel: <span class="string">'many'</span> &#125; &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取动态参数列表失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将attr_vals字符串转换为数组</span></span><br><span class="line">        res.<span class="keyword">data</span>.forEach(item =&gt; &#123;</span><br><span class="line">          item.attr_vals =</span><br><span class="line">            item.attr_vals.length === <span class="number">0</span> ? [] : item.attr_vals.split(<span class="string">' '</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.manyTableData = res.<span class="keyword">data</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.activeIndex === <span class="string">'2'</span>) &#123;</span><br><span class="line">        <span class="comment">//发送请求获取静态属性</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(</span><br><span class="line">          `categories/$&#123;<span class="keyword">this</span>.cateId&#125;/attributes`,</span><br><span class="line">          &#123; params: &#123; sel: <span class="string">'only'</span> &#125; &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取静态属性列表失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.onlyTableData = res.<span class="keyword">data</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//添加 计算属性获取三级分类</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    cateId() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.addForm.goods_cat.length === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addForm.goods_cat[<span class="number">2</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/03/vue3-08/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.完成商品分类<br>2.完成参数管理 </p>
<h3 id="1-商品分类"><a href="#1-商品分类" class="headerlink" title="1.商品分类"></a>1.商品分类</h3><h4 id="A-新建分支goods-cate"><a href="#A-新建分支goods-cate" class="headerlink" title="A.新建分支goods_cate"></a>A.新建分支goods_cate</h4><p>新建分支goods_cate并推送到码云</p>
<a id="more"></a>
<p>git checkout -b goods_cate<br>git push -u origin goods_cate</p>
<h4 id="B-创建子级路由"><a href="#B-创建子级路由" class="headerlink" title="B.创建子级路由"></a>B.创建子级路由</h4><p>创建categories子级路由组件并设置路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cate from <span class="string">'./components/goods/Cate.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">"/categories"</span>, <span class="string">component:</span> Cate  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="C-添加组件基本布局"><a href="#C-添加组件基本布局" class="headerlink" title="C.添加组件基本布局"></a>C.添加组件基本布局</h4><p>在Cate.vue组件中添加面包屑导航以及卡片视图中的添加分类按钮</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>商品分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; path: '/home' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品分类<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 添加分类按钮区域 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>添加分类<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 分类表格  --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 分页 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="D-请求分类数据"><a href="#D-请求分类数据" class="headerlink" title="D.请求分类数据"></a>D.请求分类数据</h4><p>请求分类数据并将数据保存在data中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 商品分类数据列表</span></span><br><span class="line">      cateList: [],</span><br><span class="line">      <span class="comment">//查询分类数据的条件</span></span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        type: <span class="number">3</span>,</span><br><span class="line">        pagenum: <span class="number">1</span>,</span><br><span class="line">        pagesize: <span class="number">5</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//保存总数据条数</span></span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getCateList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getCateList() &#123;</span><br><span class="line">      <span class="comment">//获取商品分类数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'categories'</span>, &#123;</span><br><span class="line">        params: queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取商品列表数据失败'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将数据列表赋值给cateList</span></span><br><span class="line">      <span class="keyword">this</span>.cateList = res.<span class="keyword">data</span>.result</span><br><span class="line">      <span class="comment">//保存总数据条数</span></span><br><span class="line">      <span class="keyword">this</span>.total = res.<span class="keyword">data</span>.total</span><br><span class="line">      <span class="comment">//   console.log(res.data);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="E-使用插件展示数据"><a href="#E-使用插件展示数据" class="headerlink" title="E.使用插件展示数据"></a>E.使用插件展示数据</h4><p>使用第三方插件vue-table-with-tree-grid展示分类数据<br>    1).在vue 控制台中点击依赖-&gt;安装依赖-&gt;运行依赖-&gt;输入vue-table-with-tree-gird-&gt;点击安装<br>    2).打开main.js，导入vue-table-with-tree-grid<br>    import TreeTable from ‘vue-table-with-tree-grid’<br>    …..<br>    Vue.config.productionTip = false</p>
<pre><code>//全局注册组件
Vue.component(&apos;tree-table&apos;, TreeTable)
3).使用组件展示分类数据</code></pre><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分类表格</span><br><span class="line">:data(设置数据源) :<span class="built_in">columns</span>(设置表格中列配置信息) :selection-type(是否有复选框)</span><br><span class="line">:<span class="built_in">expand</span>-type(是否展开数据) <span class="built_in">show</span>-index(是否设置索引列) index-text(设置索引列头)</span><br><span class="line"><span class="built_in">border</span>(是否添加纵向边框) :<span class="built_in">show</span>-<span class="built_in">row</span>-hover(是否鼠标悬停高亮) --&gt;</span><br><span class="line">&lt;tree-table :data=<span class="string">"cateList"</span> :<span class="built_in">columns</span>=<span class="string">"columns"</span> :selection-type=<span class="string">"false"</span></span><br><span class="line">:<span class="built_in">expand</span>-type=<span class="string">"false"</span> <span class="built_in">show</span>-index index-text=<span class="string">"#"</span> <span class="built_in">border</span> :<span class="built_in">show</span>-<span class="built_in">row</span>-hover=<span class="string">"false"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tree-table&gt;</span><br><span class="line"></span><br><span class="line">在数据中添加<span class="built_in">columns</span>:</span><br><span class="line"><span class="built_in">columns</span>: [</span><br><span class="line">    &#123;<span class="built_in">label</span>:'分类名称',prop:'cat_name'&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="F-自定义数据列"><a href="#F-自定义数据列" class="headerlink" title="F.自定义数据列"></a>F.自定义数据列</h4><p>使用vue-table-with-tree-grid定义模板列并添加自定义列</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">//先在columns中添加一个列</span></span><br><span class="line"><span class="xml">columns: [</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;label:'分类名称',prop:'cat_name'&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    //type:'template'(将该列设置为模板列)，template:'isok'(设置该列模板的名称为isok)</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;label:'是否有效',prop:'',type:'template',template:'isok'&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;label:'排序',prop:'',type:'template',template:'order'&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;label:'操作',prop:'',type:'template',template:'opt'&#125;</span></span><br><span class="line"><span class="xml">]</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 是否有效区域， 设置对应的模板列： slot="isok"(与columns中设置的template一致) --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"isok"</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-success"</span> <span class="attr">v-if</span>=<span class="string">"scope.row.cat_deleted === false"</span> <span class="attr">style</span>=<span class="string">"color:lightgreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-error"</span> <span class="attr">v-else</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 排序 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"order"</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">v-if</span>=<span class="string">"scope.row.cat_level===0"</span>&gt;</span>一级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">v-else-if</span>=<span class="string">"scope.row.cat_level===1"</span>&gt;</span>二级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"warning"</span> <span class="attr">v-else</span>&gt;</span>三级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 操作 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"opt"</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="G-完成分页功能"><a href="#G-完成分页功能" class="headerlink" title="G.完成分页功能"></a>G.完成分页功能</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分页 --&gt;</span><br><span class="line">&lt;el-pagination <span class="meta">@size</span>-change=<span class="string">"handleSizeChange"</span> <span class="meta">@current</span>-change=<span class="string">"handleCurrentChange"</span> :current-page=<span class="string">"queryInfo.pagenum"</span> :page-sizes=<span class="string">"[3, 5, 10, 15]"</span> :page-size=<span class="string">"queryInfo.pagesize"</span> layout=<span class="string">"total, sizes, prev, pager, next, jumper"</span> :total=<span class="string">"total"</span>&gt;</span><br><span class="line">&lt;/el-pagination&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对应的事件函数</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  .......</span><br><span class="line">  handleSizeChange(newSize)&#123;</span><br><span class="line">    <span class="comment">//当pagesize发生改变时触发</span></span><br><span class="line">    <span class="keyword">this</span>.queryInfo.pagesize = newSize;</span><br><span class="line">    <span class="keyword">this</span>.getCateList();</span><br><span class="line">  &#125;,</span><br><span class="line">  handleCurrentChange(newPage)&#123;</span><br><span class="line">    <span class="comment">//当pagenum发生改变时触发</span></span><br><span class="line">    <span class="keyword">this</span>.queryInfo.pagenum = newPage;</span><br><span class="line">    <span class="keyword">this</span>.getCateList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="H-完成添加分类"><a href="#H-完成添加分类" class="headerlink" title="H.完成添加分类"></a>H.完成添加分类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">&lt;!-- 添加分类按钮区域 --&gt;</span><br><span class="line">&lt;el-row&gt;</span><br><span class="line">  &lt;el-col&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"showAddCateDialog"</span>&gt;添加分类&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>el-col&gt;</span><br><span class="line">&lt;<span class="regexp">/el-row&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">&lt;!-- 添加分类对话框 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;el-dialog title="添加分类" :visible.sync="addCateDialogVisible" width="50%"  @close="addCateDialogClosed"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;!-- 添加分类表单 --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;el-form :model="addCateForm" :rules="addCateFormRules" ref="addCateFormRuleForm" label-width="100px"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-form-item label="分类名称" prop="cat_name"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;el-input v-model="addCateForm.cat_name"&gt;&lt;/</span>el-input&gt;</span><br><span class="line">    &lt;<span class="regexp">/el-form-item&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-form-item label="父级分类" prop="cat_pid"&gt;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">  &lt;<span class="regexp">/el-form&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span slot="footer" class="dialog-footer"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-button @click="addCateDialogVisible = false"&gt;取 消&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"addCate"</span>&gt;确 定&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/el-dialog&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/用来显示或隐藏添加分类对话框</span></span><br><span class="line"><span class="regexp">addCateDialogVisible: false,</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/添加分类的表单数据对象</span></span><br><span class="line"><span class="regexp">addCateForm:&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/分类名称</span></span><br><span class="line"><span class="regexp">  cat_name:'',</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/添加分类的父级id，0则表示父级为0.添加一级分类</span></span><br><span class="line"><span class="regexp">  cat_pid:0,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/添加分类的等级，0则表示添加一级分类</span></span><br><span class="line"><span class="regexp">  cat_level:0</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/添加分类校验规则</span></span><br><span class="line"><span class="regexp">addCateFormRules:&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/验证规则</span></span><br><span class="line"><span class="regexp">  cat_name:[ &#123;required:true , message:'请输入分类名称',trigger:'blur'&#125; ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/保存1,2级父级分类的列表</span></span><br><span class="line"><span class="regexp">parentCateList:[]</span></span><br><span class="line"><span class="regexp">.......</span></span><br><span class="line"><span class="regexp">showAddCateDialog() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/调用getParentCateList获取分类列表</span></span><br><span class="line"><span class="regexp">  this.getParentCateList()</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/显示添加分类对话框</span></span><br><span class="line"><span class="regexp">  this.addCateDialogVisible = true</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">async getParentCateList()&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/获取父级分类数据列表</span></span><br><span class="line"><span class="regexp">  const &#123; data: res &#125; = await this.$http.get('categories', &#123;</span></span><br><span class="line"><span class="regexp">    params: &#123;type:2&#125;</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="regexp">    return this.$message.error('获取商品分类列表数据失败')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  this.parentCateList = res.data</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>添加级联菜单显示父级分类<br>先导入Cascader组件，并注册<br>然后添加使用级联菜单组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item label=<span class="string">"父级分类"</span> prop=<span class="string">"cat_pid"</span>&gt;</span><br><span class="line">  &lt;!-- expandTrigger=<span class="string">'hover'</span>(鼠标悬停触发级联) v-model(设置级联菜单绑定数据) :options(指定级联菜单数据源)  :props(用来配置数据显示的规则) </span><br><span class="line">  clearable(提供“X”号完成删除文本功能) change-on-select(是否可以选中任意一级的菜单) --&gt;</span><br><span class="line">  &lt;el-cascader expandTrigger=<span class="string">'hover'</span> v-model=<span class="string">"selectedKeys"</span> :options=<span class="string">"parentCateList"</span> :props=<span class="string">"cascaderProps"</span> <span class="meta">@change</span>=<span class="string">"parentCateChange"</span> clearable change-on-select&gt;&lt;/el-cascader&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">添加数据</span><br><span class="line"><span class="comment">//配置级联菜单中数据如何展示</span></span><br><span class="line">cascaderProps:&#123;</span><br><span class="line">  value:<span class="string">'cat_id'</span>,</span><br><span class="line">  label:<span class="string">'cat_name'</span>,</span><br><span class="line">  children:<span class="string">'children'</span>,</span><br><span class="line">  expandTrigger:<span class="string">'hover'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//绑定用户选择的分类值</span></span><br><span class="line">selectedKeys:[]</span><br><span class="line">.....</span><br><span class="line">methods:&#123;</span><br><span class="line">  .....</span><br><span class="line">  parentCateChange()&#123;</span><br><span class="line">    <span class="comment">//级联菜单中选择项发生变化时触发</span></span><br><span class="line">    console.log(<span class="keyword">this</span>.selectedKeys)</span><br><span class="line">    <span class="comment">//如果用户选择了父级分类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.selectedKeys.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//则将数组中的最后一项设置为父级分类</span></span><br><span class="line">      <span class="keyword">this</span>.addCateForm.cat_pid = <span class="keyword">this</span>.selectedKeys[<span class="keyword">this</span>.selectedKeys.length - <span class="number">1</span>]</span><br><span class="line">      <span class="comment">//level也要跟着发生变化</span></span><br><span class="line">      <span class="keyword">this</span>.addCateForm.cat_level = <span class="keyword">this</span>.selectedKeys.length</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.addCateForm.cat_pid = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.addCateForm.cat_level = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  addCateDialogClosed()&#123;</span><br><span class="line">    <span class="comment">//当关闭添加分类对话框时，重置表单</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.addCateFormRef.resetFields()</span><br><span class="line">    <span class="keyword">this</span>.selectedKeys = [];</span><br><span class="line">    <span class="keyword">this</span>.addCateForm.cat_pid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.addCateForm.cat_level = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  addCate() &#123;</span><br><span class="line">    <span class="comment">//点击确定，完成添加分类</span></span><br><span class="line">    console.log(<span class="keyword">this</span>.addCateForm)</span><br><span class="line">    <span class="keyword">this</span>.$refs.addCateFormRef.validate(async valid =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!valid) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">//发送请求完成添加分类</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.post(</span><br><span class="line">        <span class="string">'categories'</span>,</span><br><span class="line">        <span class="keyword">this</span>.addCateForm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">201</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'添加分类失败'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.$message.success(<span class="string">'添加分类成功'</span>)</span><br><span class="line">      <span class="keyword">this</span>.getCateList()</span><br><span class="line">      <span class="keyword">this</span>.addCateDialogVisible = <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="I-推送代码"><a href="#I-推送代码" class="headerlink" title="I.推送代码"></a>I.推送代码</h4><p>制作完添加分类之后，将代码提交到仓库，推送到码云,将goods_cate分支合并到master<br>git add .<br>git commit -m ‘完成商品分类’<br>git push<br>git checkout master<br>git merge goods_cate</p>
<h3 id="2-参数管理"><a href="#2-参数管理" class="headerlink" title="2.参数管理"></a>2.参数管理</h3><p>只允许给三级分类内容设置参数，参数分为动态参数和静态参数属性</p>
<h4 id="A-添加子级组件"><a href="#A-添加子级组件" class="headerlink" title="A.添加子级组件"></a>A.添加子级组件</h4><p>添加Params.vue子组件，并在router.js中引入该组件并设置路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Params from <span class="string">'./components/goods/Params.vue'</span></span><br><span class="line">......</span><br><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/categories"</span>, <span class="string">component:</span> Cate  &#125;,</span><br><span class="line">  &#123; <span class="string">path:</span> <span class="string">"/params"</span>, <span class="string">component:</span> Params  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="B-完成组件基本布局"><a href="#B-完成组件基本布局" class="headerlink" title="B.完成组件基本布局"></a>B.完成组件基本布局</h4><p>完成Params.vue组件的基本布局<br>其中警告提示信息使用了el-alert，在element.js引入该组件并注册</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>分类参数<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; path: '/home' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>分类参数<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 警告区域 :closable="false"(是否展示“X”号) show-icon(显示图标) --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-alert</span> <span class="attr">title</span>=<span class="string">"注意：只允许为第三级分类设置相关参数"</span> <span class="attr">type</span>=<span class="string">"warning"</span> <span class="attr">:closable</span>=<span class="string">"false"</span> <span class="attr">show-icon</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-alert</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 选择商品分类区域 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">class</span>=<span class="string">"cat_opt"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择商品分类：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="comment">&lt;!-- 选择商品分类的级联选择框 --&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-col</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="C-完成级联选择框"><a href="#C-完成级联选择框" class="headerlink" title="C.完成级联选择框"></a>C.完成级联选择框</h4><p>完成商品分类级联选择框</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择商品分类区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-row</span> <span class="attr">class</span>=<span class="string">"cat_opt"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择商品分类：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择商品分类的级联选择框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-cascader</span> <span class="attr">expandTrigger</span>=<span class="string">'hover'</span> <span class="attr">v-model</span>=<span class="string">"selectedCateKeys"</span> <span class="attr">:options</span>=<span class="string">"cateList"</span> <span class="attr">:props</span>=<span class="string">"cateProps"</span> @<span class="attr">change</span>=<span class="string">"handleChange"</span> <span class="attr">clearable</span>&gt;</span><span class="tag">&lt;/<span class="name">el-cascader</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//分类列表</span></span></span><br><span class="line">        cateList:[],</span><br><span class="line"><span class="actionscript">        <span class="comment">//用户在级联下拉菜单中选中的分类id</span></span></span><br><span class="line">        selectedCateKeys:[],</span><br><span class="line"><span class="actionscript">        <span class="comment">//配置级联菜单中数据如何展示</span></span></span><br><span class="line">        cateProps: &#123;</span><br><span class="line"><span class="actionscript">            value: <span class="string">'cat_id'</span>,</span></span><br><span class="line"><span class="actionscript">            label: <span class="string">'cat_name'</span>,</span></span><br><span class="line"><span class="actionscript">            children: <span class="string">'children'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.getCateList()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> getCateList()&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//获取所有的商品分类列表</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'categories'</span>)</span></span><br><span class="line"></span><br><span class="line">        if (res.meta.status !== 200) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取分类数据失败'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">//将数据列表赋值给cateList</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.cateList = res.data</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// //保存总数据条数</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// this.total = res.data.total</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//   console.log(res.data);</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleChange()&#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">//当用户在级联菜单中选择内容改变时触发</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.selectedCateKeys);</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="D-展示参数"><a href="#D-展示参数" class="headerlink" title="D.展示参数"></a>D.展示参数</h4><p>展示动态参数数据以及静态属性数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tab页签区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-tabs</span> <span class="attr">v-model</span>=<span class="string">"activeName"</span> @<span class="attr">tab-click</span>=<span class="string">"handleTabClick"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加动态参数的面板 将标签页改为many --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"动态参数"</span> <span class="attr">name</span>=<span class="string">"many"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span>添加参数<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 动态参数表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"manyTableData"</span> <span class="attr">border</span> <span class="attr">stripe</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 展开行 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"expand"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 索引列 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"参数名称"</span> <span class="attr">prop</span>=<span class="string">"attr_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加静态属性的面板 将标签页改为only --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"静态属性"</span> <span class="attr">name</span>=<span class="string">"only"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span>添加属性<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 静态属性表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"onlyTableData"</span> <span class="attr">border</span> <span class="attr">stripe</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 展开行 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"expand"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 索引列 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"属性名称"</span> <span class="attr">prop</span>=<span class="string">"attr_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tabs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      ......</span><br><span class="line"><span class="actionscript">      <span class="comment">//tab页签激活显示的页签项</span></span></span><br><span class="line"><span class="actionscript">      activeName: <span class="string">'many'</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//用来保存动态参数数据</span></span></span><br><span class="line">      manyTableData: [],</span><br><span class="line"><span class="actionscript">      <span class="comment">//用来保存静态属性数据</span></span></span><br><span class="line">      onlyTableData: []  </span><br><span class="line">    &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    .......</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> handleChange() &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//当用户在级联菜单中选择内容改变时触发</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.selectedCateKeys)</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//发送请求，根据用户选择的三级分类和面板获取参数数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(</span></span><br><span class="line"><span class="javascript">        <span class="string">`categories/<span class="subst">$&#123;<span class="keyword">this</span>.cateId&#125;</span>/attributes`</span>,</span></span><br><span class="line"><span class="actionscript">        &#123; params: &#123; sel: <span class="keyword">this</span>.activeName &#125; &#125;</span></span><br><span class="line">      )</span><br><span class="line">      if (res.meta.status !== 200) &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取参数列表数据失败'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(res.data)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.activeName === <span class="string">'many'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//获取的是动态参数</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.manyTableData = res.data</span></span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.activeName === <span class="string">'only'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//获取的是静态属性</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.onlyTableData = res.data</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleTabClick() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.activeName)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.handleChange()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">//添加计算属性用来获取按钮禁用与否</span></span></span><br><span class="line">    isButtonDisabled() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.selectedCateKeys.length !== <span class="number">3</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">//获取选中的三级分类id</span></span></span><br><span class="line">    cateId() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.selectedCateKeys.length === <span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.selectedCateKeys[<span class="keyword">this</span>.selectedCateKeys.length - <span class="number">1</span>]</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="literal">null</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-添加参数"><a href="#E-添加参数" class="headerlink" title="E.添加参数"></a>E.添加参数</h4><p>完成添加参数或属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加参数或属性对话框 --&gt;</span><br><span class="line">&lt;el-dialog :title=<span class="string">"'添加'+titleText"</span> :visible.sync=<span class="string">"addDialogVisible"</span> width=<span class="string">"50%"</span> @close=<span class="string">"addDialogClosed"</span>&gt;</span><br><span class="line">  &lt;!-- 添加表单 --&gt;</span><br><span class="line">  &lt;el-form :model=<span class="string">"addForm"</span> :rules=<span class="string">"addFormRules"</span> ref=<span class="string">"addFormRef"</span> label-width=<span class="string">"100px"</span>&gt;</span><br><span class="line">    &lt;el-form-item :label=<span class="string">"titleText"</span> prop=<span class="string">"attr_name"</span>&gt;</span><br><span class="line">      &lt;el-input v-model=<span class="string">"addForm.attr_name"</span>&gt;&lt;<span class="regexp">/el-input&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">  &lt;<span class="regexp">/el-form&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span slot="footer" class="dialog-footer"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-button @click="addDialogVisible = false"&gt;取 消&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"addParams"</span>&gt;确 定&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/el-dialog&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      .......</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/控制添加参数.属性对话框的显示或隐藏</span></span><br><span class="line"><span class="regexp">      addDialogVisible: false,</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/添加参数的表单数据对象</span></span><br><span class="line"><span class="regexp">      addForm: &#123;</span></span><br><span class="line"><span class="regexp">        attr_name: ''</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/添加表单验证规则</span></span><br><span class="line"><span class="regexp">      addFormRules: &#123;</span></span><br><span class="line"><span class="regexp">        attr_name: [&#123; required: true, message: '请输入名称', trigger: 'blur' &#125;]</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,methods: &#123;</span></span><br><span class="line"><span class="regexp">    .......</span></span><br><span class="line"><span class="regexp">    addParams() &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/当用户点击对话框中的确定时，校验表单</span></span><br><span class="line"><span class="regexp">      this.$refs.addFormRef.validate(async valid =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/校验不通过，return</span></span><br><span class="line"><span class="regexp">        if (!valid) return</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/校验通过，发送请求完成添加参数或者属性</span></span><br><span class="line"><span class="regexp">        const &#123; data: res &#125; = this.$http.post(`categories/</span>$&#123;<span class="keyword">this</span>.cateId&#125;/attributes<span class="string">`,</span></span><br><span class="line"><span class="string">          &#123; </span></span><br><span class="line"><span class="string">            attr_name: this.addForm.attr_name, </span></span><br><span class="line"><span class="string">            attr_sel: this.activeName,</span></span><br><span class="line"><span class="string">            attr_vals: "a,b,c" </span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        console.log(res)</span></span><br><span class="line"><span class="string">        if (res.meta.status !== 201) &#123;</span></span><br><span class="line"><span class="string">          return this.$message.error('添加' + this.titleText + '数据失败')</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        this.$message.success('添加' + this.titleText + '数据成功')</span></span><br><span class="line"><span class="string">        this.addDialogVisible = false</span></span><br><span class="line"><span class="string">        this.getCateList()</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="F-编辑参数"><a href="#F-编辑参数" class="headerlink" title="F.编辑参数"></a>F.编辑参数</h4><p>完成编辑参数或属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修改参数或属性对话框 --&gt;</span><br><span class="line">&lt;el-dialog :title=<span class="string">"'修改'+titleText"</span> :visible.sync=<span class="string">"editDialogVisible"</span> width=<span class="string">"50%"</span> @close=<span class="string">"editDialogClosed"</span>&gt;</span><br><span class="line">  &lt;!-- 添加表单 --&gt;</span><br><span class="line">  &lt;el-form :model=<span class="string">"editForm"</span> :rules=<span class="string">"editFormRules"</span> ref=<span class="string">"editFormRef"</span> label-width=<span class="string">"100px"</span>&gt;</span><br><span class="line">    &lt;el-form-item :label=<span class="string">"titleText"</span> prop=<span class="string">"attr_name"</span>&gt;</span><br><span class="line">      &lt;el-input v-model=<span class="string">"editForm.attr_name"</span>&gt;&lt;<span class="regexp">/el-input&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">  &lt;<span class="regexp">/el-form&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span slot="footer" class="dialog-footer"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-button @click="editDialogVisible = false"&gt;取 消&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"editParams"</span>&gt;确 定&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/el-dialog&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      .......</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/控制修改参数.属性对话框的显示或隐藏</span></span><br><span class="line"><span class="regexp">      editDialogVisible:false,</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/修改参数.属性对话框中的表单</span></span><br><span class="line"><span class="regexp">      editForm:&#123;</span></span><br><span class="line"><span class="regexp">        attr_name:''</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/修改表单的验证规则</span></span><br><span class="line"><span class="regexp">      editFormRules:&#123;</span></span><br><span class="line"><span class="regexp">        attr_name:[</span></span><br><span class="line"><span class="regexp">          &#123; required: true, message: '请输入名称', trigger: 'blur' &#125;</span></span><br><span class="line"><span class="regexp">        ]</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,methods: &#123;</span></span><br><span class="line"><span class="regexp">    .......</span></span><br><span class="line"><span class="regexp">    async showEditDialog(attr_id)&#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/发起请求获取需要修改的那个参数数据</span></span><br><span class="line"><span class="regexp">      const &#123;data:res&#125; = await this.$http.get(`categories/</span>$&#123;<span class="keyword">this</span>.cateId&#125;/attributes/$&#123;attr_id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">      &#123;params:&#123; attr_sel:this.activeName &#125;&#125;)</span></span><br><span class="line"><span class="string">      if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="string">        return this.$message.error('获取参数数据失败')</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      this.editForm = res.data;</span></span><br><span class="line"><span class="string">      //显示修改参数.属性对话框</span></span><br><span class="line"><span class="string">      this.editDialogVisible = true;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    editDialogClosed()&#123;</span></span><br><span class="line"><span class="string">      //当关闭修改参数.属性对话框时</span></span><br><span class="line"><span class="string">      this.$refs.editFormRef.resetFields()</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    editParams()&#123;</span></span><br><span class="line"><span class="string">      //验证表单</span></span><br><span class="line"><span class="string">      this.$refs.editFormRef.validate(async valid =&gt; &#123;</span></span><br><span class="line"><span class="string">        if(!valid) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        //发送请求完成修改</span></span><br><span class="line"><span class="string">        const &#123;data:res&#125; = await this.$http.put(`</span>categories/$&#123;<span class="keyword">this</span>.cateId&#125;/attributes/$&#123;<span class="keyword">this</span>.editForm.attr_id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">        &#123;attr_name:this.editForm.attr_name,attr_sel:this.activeName&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (res.meta.status !== 200) &#123;</span></span><br><span class="line"><span class="string">          return this.$message.error('获取参数数据失败')</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        this.$message.success('修改' + this.titleText + '数据成功')</span></span><br><span class="line"><span class="string">        this.editDialogVisible = false</span></span><br><span class="line"><span class="string">        this.handleChange();</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="G-删除参数"><a href="#G-删除参数" class="headerlink" title="G.删除参数"></a>G.删除参数</h4><p>删除参数或属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">给两个删除按钮添加事件</span><br><span class="line">&lt;el-button size=<span class="string">"mini"</span> type=<span class="string">"danger"</span> icon=<span class="string">"el-icon-delete"</span> <span class="meta">@click</span>=<span class="string">"removeParams(scope.row.attr_id)"</span>&gt;删除&lt;/el-button&gt;</span><br><span class="line">&lt;el-button size=<span class="string">"mini"</span> type=<span class="string">"danger"</span> icon=<span class="string">"el-icon-delete"</span> <span class="meta">@click</span>=<span class="string">"removeParams(scope.row.attr_id)"</span>&gt;删除&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">添加对应的事件处理函数</span><br><span class="line">async removeParams(attr_id)&#123;</span><br><span class="line">  <span class="comment">//根据id删除对应的参数或属性</span></span><br><span class="line">  <span class="comment">//弹窗提示用户是否要删除</span></span><br><span class="line">  <span class="keyword">const</span> confirmResult = await <span class="keyword">this</span>.$confirm(</span><br><span class="line">    <span class="string">'请问是否要删除该'</span>+<span class="keyword">this</span>.titleText,</span><br><span class="line">    <span class="string">'删除提示'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      confirmButtonText: <span class="string">'确认删除'</span>,</span><br><span class="line">      cancelButtonText: <span class="string">'取消'</span>,</span><br><span class="line">      type: <span class="string">'warning'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).<span class="keyword">catch</span>(err =&gt; err)</span><br><span class="line">  <span class="comment">//如果用户点击确认，则confirmResult 为'confirm'</span></span><br><span class="line">  <span class="comment">//如果用户点击取消, 则confirmResult获取的就是catch的错误消息'cancel'</span></span><br><span class="line">  <span class="keyword">if</span> (confirmResult != <span class="string">'confirm'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$message.info(<span class="string">'已经取消删除'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//没有取消就是要删除，发送请求完成删除</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.delete(`categories/$&#123;<span class="keyword">this</span>.cateId&#125;/attributes/$&#123;attr_id&#125;`)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'删除参数数据失败'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$message.success(<span class="string">'删除'</span> + <span class="keyword">this</span>.titleText + <span class="string">'数据成功'</span>)</span><br><span class="line">  <span class="keyword">this</span>.handleChange()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全xss和CSRF</title>
    <url>/2020/03/01/%E9%9D%A2%E7%BB%8F03/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/tg666/p/12305805.html" target="_blank" rel="noopener">参考文章1</a>、<a href="https://www.cnblogs.com/tg666/p/12305805.html" target="_blank" rel="noopener">参考文章2</a></p>
<p>结合我的这篇<a href="/2019/03/29/%E6%B5%8F%E8%A7%88%E5%99%A802/" title="CSRF和XSS网络攻击和防范">CSRF和XSS网络攻击和防范</a>博文</p>
<h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨域脚本攻击，简单点说就是攻击者想尽一切办法将可执行的代码注入到网页中。</p>
<ul>
<li>攻击原理： 不需要做任何的登录认证，它会通过合法的操作（比如再url中输入、在评论框中输入），向页面注入脚本（可能是js、html代码块等）</li>
<li>分为反射型和持久型<ul>
<li>反射型：xss代码出现在URL中，服务端解析响应后，xss代码随响应内容一起传回给浏览器，最后浏览器解析执行xss代码<a id="more"></a></li>
<li>持久型：就是攻击的代码被服务端写入数据库中，比如用户提交评论，将包含xss代码的内容提交，然后服务端将内容保存在数据库中，之后其他用户查看评论的时候都会取出内容展示的时候就会执行这些恶意代码</li>
</ul>
</li>
<li>防御措施：令xss无法攻击，比如对注入的东西进行转义、编码、过滤、校正等<ul>
<li>使用xss filter：针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容，比如：<ul>
<li>表单数据指定值的类型：年龄只能是number、name只能是字母数字等</li>
<li>过滤或移除特殊的html标签<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = require(<span class="comment">'xss')</span></span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="comment">'<span class="doctag">&lt;h1 id="title"&gt;</span>xss<span class="doctag">&lt;/h1&gt;</span><span class="doctag">&lt;script&gt;</span>alert("xss")<span class="doctag">&lt;/script&gt;</span>')</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>设置httpOnly放置客户端获取cookie信息</li>
<li>开启CSP。通常可以通过两种方式来开启CSP：设置HTTP header中的Content-Security-Policy、设置meta标签。<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">以设置Http Header来举例：</span><br><span class="line">Content-Security-<span class="string">Policy:</span> <span class="keyword">default</span>-src <span class="string">'self'</span> <span class="comment">//只允许加载本站资源</span></span><br><span class="line">Content-Security-<span class="string">Policy:</span> img-src <span class="string">https:</span><span class="comment">//*  //只允许加载https协议图片</span></span><br><span class="line">Content-Security-<span class="string">Policy:</span> child-src <span class="string">'none'</span>   <span class="comment">// 允许加载任何来源框架</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF：跨站请求伪造。原理就是CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求达到攻击目的。</p>
<h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>防御措施</p>
<ul>
<li>token验证：登录成功后服务器下发token令牌存到用户本地，再次访问时要主动发送token，浏览器只能额主动发cookie，做不到主动发token</li>
<li>referer验证：判断页面来源是否是自己站点的页面，不是不执行请求</li>
<li>隐藏令牌： 令牌放在http header头中，而不是连接中</li>
</ul>
<h5 id="验证HTTP-Referer字段"><a href="#验证HTTP-Referer字段" class="headerlink" title="验证HTTP Referer字段"></a>验证HTTP Referer字段</h5><p>它记录了该HTTP请求的来源地址。比如说点击一个按钮提交信息，这个请求的referer就是这个按钮所在的页面的URL，如果是别的三方网站的请求，那这个referer就是第三方网站的URL。所以只需要添加一个拦截器来检查referer的值就可以了，简单易行。但是浏览器对于referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。事实上，对于某些浏览器，目前已经有一些方法可以纂改referer值。况且对于最新的浏览器，黑客已经不能该referer的值了，不过因为referer会记录用户的访问来源，有些用户会认为这样侵犯隐私，因此可以设置请求不提供referer，那么接受的网站就可能会认为是CSRF攻击。</p>
<h5 id="使用token验证"><a href="#使用token验证" class="headerlink" title="使用token验证"></a>使用token验证</h5><p>CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并且在服务端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p>
<p>这种方法要比检查referer方法要安全一些，token可以在用户登录后产生并存放session中，然后在每次请求时把token从session中拿出，与请求的token进行比对，但这种方法的难点就在于如何把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，而对于POST请求来说，要在form的最后加上，这样就把token以参数的形式加入请求拦。但是在一个网站中，可以接收请求的地方非常多，要对于每一个请求都加上token时很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用js遍历整个DOM树，对于dom中所有的a和form标签后都加上token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的html代码，这种方法就没有作用，还需要程序员在编码时手动添加token。</p>
<p>该方法还有一个缺点时难以保证token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以上面发布自己个人网站的网址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站得到这个token，并马上就可以发动CSRF攻击。为了避免这一点，系统可以在添加token的时候增加一个判断，如果这个链接是自己本站的，就在后面添加token，如果时通向外网则不加。不过，即使这个CSRFtoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过referer来得到这个token值以发动CSRF攻击。</p>
<h5 id="Samesite-cookie"><a href="#Samesite-cookie" class="headerlink" title="Samesite cookie"></a>Samesite cookie</h5><p>Set-Cookie响应头新增SameSite属性，它用来表明这个cookie是个“同站cookie”，统战cookie只能作为第一方cookie，不能作为第三方cookie。SameSite有两个属性值，分别是Strict和Lax</p>
<ul>
<li>Strict禁止发送所有第三方链接的cookies，默认情况下，如果添加了SameSite关键字，但是没有指定value，那么默认为strict</li>
<li>Lax：只允许发送安全HTTP方法第三方链接的cookies必须是top-level即可引起地址栏变化的跳转方式。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>CSRF：需要用户先登录网站A，获取cookie。XSS：不需要登录</li>
<li>CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站A注入JS代码，然后执行JS里的代码，纂改网站A的内容。</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Web安全xss和CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据传递的方法</title>
    <url>/2020/03/01/%E9%9D%A2%E7%BB%8F02/</url>
    <content><![CDATA[<p>组件时Vue.js最强大的功能，组件可以封装重用的代码，通过传入对象的不同，实现组件的复用，但组件传值就成为一个需要解决的问题。</p>
<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>组件实例的作用域时孤立的。这意味着不能在子组件的模板内直接引用父组件的数据，要让子组件使用父组件的数据，我们需要通过子组件的props选项实现。<br>子组件：</p>
<a id="more"></a>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><span class="template-variable">&#123;&#123;logo&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>子组件需要从父组件获取logo的值，就需要使用props:[‘logo’]</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">	data() &#123;</span><br><span class="line"><span class="actionscript">		<span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	props: [<span class="string">'logo'</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:logo</span>=<span class="string">"logoMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> header <span class="keyword">from</span> <span class="string">'./components/header'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">	data() &#123;</span><br><span class="line"><span class="actionscript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">			logoMsg: <span class="string">'hello'</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	components: &#123;</span><br><span class="line">		header</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>子组件主要通过事件传递数据给父组件<br>子组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"username"</span> @<span class="attr">change</span>=<span class="string">"setUser"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">	data() &#123;</span><br><span class="line"><span class="actionscript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">			username: <span class="string">''</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line"><span class="actionscript">		setUser: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">this</span>.$emit(<span class="string">'transferUser'</span>, <span class="keyword">this</span>.username)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中transferUser是一个自定义的事件，this.username将通过这个事件传递给父组件</p>
<p>父组件：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">login</span> @<span class="attr">transferUser</span>=<span class="string">"getUser"</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;user&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'./components/login'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">	data() &#123;</span><br><span class="line"><span class="actionscript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">			user: <span class="string">''</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		getUser(msg) &#123;</span><br><span class="line"><span class="actionscript">			<span class="keyword">this</span>.user = msg</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	components: &#123;</span><br><span class="line">		login</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>getUser方法中的参数msg就是从子组件传递过来的参数username</p>
<h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">	name: <span class="string">'route'</span>,</span><br><span class="line">	query/<span class="keyword">params</span>: &#123;</span><br><span class="line">		routParams: <span class="keyword">Params</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>在跳转页面的时候在页面中使用&lt; router-link&gt;标签进行路由传值。</p>
<p>需要之一的时，使用params传值的时候，在页面刷新的时候，参数会消失，使用query则不会有这个问题。<br>取值方式为：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$route</span><span class="selector-class">.params</span>.paramName</span><br><span class="line">this.<span class="variable">$route</span><span class="selector-class">.query</span>.paramName</span><br></pre></td></tr></table></figure>

<h3 id="通过localStorage或者sessionStorage来存储数据"><a href="#通过localStorage或者sessionStorage来存储数据" class="headerlink" title="通过localStorage或者sessionStorage来存储数据"></a>通过localStorage或者sessionStorage来存储数据</h3><p>setItem存储value</p>
<ul>
<li>用途：将value存储到key字段</li>
<li>用法：.setItem(key,value)</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sessionStorage</span><span class="selector-class">.setItem</span>(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br><span class="line"><span class="selector-tag">localStorage</span><span class="selector-class">.setItem</span>(<span class="string">"site"</span>,<span class="string">"value"</span>)</span><br></pre></td></tr></table></figure>
<p>使用getItem获取value</p>
<ul>
<li>用途： 获取指定key本地存储的值</li>
<li>用法：.getItem(key</li>
</ul>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = sessionStorage.getItem(<span class="string">"key"</span>)</span><br><span class="line"><span class="keyword">var</span> site = localStorage.getItem(<span class="string">"site"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>在应用复杂的时候，可以使用Vuex来统一管理数据状态</p>
<ul>
<li>Vuex：可以理解是全局状态管理的一个插件，理论上所有组件都能拿到Vuex里面的数据</li>
<li>State：可以理解为组件中的data，就是放数据的地方</li>
<li>Mutation： 可以理解为提交数据给data的方法（同步）</li>
<li>Action： 可以理解为提交数据给Mutation然后通过Mutation再提交给data的方法（异步）</li>
<li>Getter： 可以将data的数据进行过滤，然后组件通过Getter方法获取过滤的data                                                                                                                                                                                                                                       </li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue数据传递的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定原理</title>
    <url>/2020/03/01/%E9%9D%A2%E7%BB%8F01/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wangjiachen666/p/9883916.html" target="_blank" rel="noopener">参考文章</a>-</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Vue内部通过<code>Obeject.defineProperty</code>方法属性拦截的方式，把<code>data</code>对象里每个数据的读写转化为<code>getter/setter</code>，当数据变化时通知视图更新。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>MVVM数据双向绑定：数据变化时更新视图，视图变化时更新数据。<br>也就是说：</p>
<ul>
<li>输入框内容变化时，data中的数据同步变化。即view =&gt; model的变化</li>
<li>data中的数据变化时，文本节点的内容同步变化。即model =&gt; view 的变化<a id="more"></a>
要实现这个过程，关键点在于数据变化时如何更新视图，因为视图变化更新数据我们可以通过事件的监听方式来实现。所以着重讨论数据变化如何更新视图。</li>
</ul>
<p>数据变化的关键点在于是怎么知道数据发生了变化，知道数据在何时发生了变化，那我们就只需在数据变化的时候取更新视图即可。</p>
<h3 id="使数据对象变得“可观测”"><a href="#使数据对象变得“可观测”" class="headerlink" title="使数据对象变得“可观测”"></a>使数据对象变得“可观测”</h3><p>数据的每次读和写都能够被看见，即我们能够知道数据什么时候被读取了或者数据什么时候被改写了，这种特性被称为数据的“可观测”</p>
<p>要将数据变成可观测的，就需要借助<code>Object.defineProperty</code>方法了，MDN的介绍如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>define<span class="constructor">Property()</span>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</span><br></pre></td></tr></table></figure>

<p>我们就可以使用这个方法让数据变得“可观测”<br>首先，我们定义一个数据对象<code>car</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> car = &#123;</span><br><span class="line">	<span class="string">'brand'</span>: <span class="string">'BMW'</span>,</span><br><span class="line">	<span class="string">'price'</span>: 3000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了<code>car</code>的品牌<code>brand</code>是<code>BMW</code>，价格<code>price</code>是3000.现在就可以通过<code>car.brand</code>和<code>car.price</code>直接读写这个car对应的属性值。但是当这个car的属性被读取或被修改时，我们并不知情。那么应该怎么让car主动告诉我们它被修改了呢。</p>
<p>使用<code>object.defineProperty</code>改写上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val = <span class="number">3000</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(car, <span class="string">'price'</span>, &#123;</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'price属性被读取了'</span>)</span><br><span class="line">		<span class="keyword">return</span> val</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'price属性被修改了'</span>)</span><br><span class="line">		val = newVal</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>使用<code>Object.defineProperty()</code>方法给<code>car</code>定义了一个price属性，并把这个属性的读和写分别使用<code>get()</code>和<code>set()</code>进行拦截，每当该属性进行读和写的操作的时候就会触发才<code>get()</code>和<code>set()</code>。<br>这样的化，<code>car</code>就已经可以主动告诉我们它的属性的读写情况了，这就意味着这个<code>car</code>对象已经是“可观测”的。</p>
<p>把car的所有属性都变得可观测的，可以编写如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把一个对象的每一项都转化成可观测对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">	keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">		defineReactive(obj, key, obj[key])</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使一个对象转化成可观测对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">			<span class="keyword">get</span>() &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了`</span>)</span><br><span class="line">				<span class="keyword">return</span> val</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了`</span>)</span><br><span class="line">				val = newVal</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以把car定义成为可观测的对象了</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>完成了数据的可观测，我们就可以知道数据在什么时候被读或写了，那么我们就可以在数据被读或者写的时候通知哪些依赖该数据的视图更新了。为了方便，我们需要先将所有的依赖对象收集起来，一旦数据发生变化，就统一通知更新。这就是典型的<code>发布订阅者</code>模式，数据变化为“发布者”，依赖对象为“订阅者”。</p>
<p>现在我们需要创建一个依赖收集容器，也就是消息订阅器Dep，用来容纳所有的“订阅者”。订阅器Dep主要负责收集订阅者，然后当数据变化的时候执行对应订阅者的更新函数。</p>
<p>创建消息订阅器Dep：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>.subs = []</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 增加订阅者</span></span><br><span class="line">	addSub(sub)&#123;</span><br><span class="line">		<span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 判断是否增加订阅者</span></span><br><span class="line">	depend() &#123;</span><br><span class="line">		<span class="keyword">if</span>(Dep.target) &#123;</span><br><span class="line">			<span class="keyword">this</span>.addSun(Dep.target)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 通知订阅者更新</span></span><br><span class="line">	notify() &#123;</span><br><span class="line">		<span class="keyword">this</span>.subs.forEach(sub =&gt; &#123;</span><br><span class="line">			sub.update()</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>有了订阅器，再将<code>defineReactive</code>函数进行改造一下，向其植入订阅器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">			<span class="keyword">get</span>() &#123;</span><br><span class="line">				dep.depend()</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了`</span>)</span><br><span class="line">				<span class="keyword">return</span> val</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了`</span>)</span><br><span class="line">				val = newVal</span><br><span class="line">				dep.notify() <span class="comment">// 数据变化时通知所有订阅者</span></span><br><span class="line">			&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设计了一个订阅器Dep类，该类里面定义了一些属性和方法，这里需要特别主义的是它有一个静态属性<code>target</code>,这是一个全局唯一的<code>watcher</code>，这是以恶搞非常巧妙的设计，因为在同一时间只能有一个全局的<code>watcher</code>被计算，另外它的<code>subs</code>自身属性也是<code>watcher</code>的数组。</p>
<p>将订阅器Dep添加订阅者的操作设计在<code>getter</code>里面，这是为了让<code>watcher</code>初始化时进行触发，因此需要判断是否添加订阅者。在<code>setter</code>函数里面，如果数据变化，就回去通知所有订阅者，订阅者们就会去执行对应的更新的函数。</p>
<p>到此，订阅器Dep设计完毕，接下来我们设计订阅者watcher。</p>
<h3 id="订阅者watcher"><a href="#订阅者watcher" class="headerlink" title="订阅者watcher"></a>订阅者watcher</h3><p>订阅者<code>watcher</code>在初始化的时候需要将自己添加进订阅器<code>Dep</code>中，那么该如何添加呢？我们已经知道监听器<code>Observer</code>是在<code>get</code>函数执行了添加订阅者<code>watcher</code>的操作的，所以我们只要在订阅者<code>watcher</code>初始化的时候触发对应的<code>get</code>函数去执行添加订阅者操作即可，那要如何触发<code>get</code>函数呢？只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了<code>Object.defineProperty()</code>进行数据监听。我们只要在订阅者<code>watcher</code>初始化的时候才需要添加订阅者。所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在<code>Dep.target</code>上缓存下订阅者，添加成功后在未将其去掉就可以了。订阅者<code>watcher</code>的实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(vm, exp, cb) &#123;</span><br><span class="line">		<span class="keyword">this</span>.vm = vm</span><br><span class="line">		<span class="keyword">this</span>.exp = exp</span><br><span class="line">		<span class="keyword">this</span>.cb = cb</span><br><span class="line">		<span class="keyword">this</span>.value = <span class="keyword">this</span>.<span class="keyword">get</span>()  <span class="comment">//将自己添加到订阅器的操作</span></span><br><span class="line">	&#125;,</span><br><span class="line">	update() &#123;</span><br><span class="line">		let value = <span class="keyword">this</span>.vm.<span class="keyword">data</span>[<span class="keyword">this</span>.exp]</span><br><span class="line">		let oldVal = <span class="keyword">this</span>.value</span><br><span class="line">		<span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value</span><br><span class="line">			<span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		Dep.target = <span class="keyword">this</span> <span class="comment">//缓存自己</span></span><br><span class="line">		let value = <span class="keyword">this</span>.vm.<span class="keyword">data</span>[<span class="keyword">this</span>.exp] <span class="comment">//强制执行监听器里的get函数</span></span><br><span class="line">		Dep.target = <span class="literal">null</span> <span class="comment">//释放自己</span></span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订阅者是一个类，在他的构造函数中，定义了一些属性：</p>
<ul>
<li>vm：一个Vue的实例对象</li>
<li>exp：时node节点的v-model或v-on：clock等指令的属性值。如<code>v-model=&#39;name&#39;</code>，exp就是name</li>
<li>cb： 时watcher绑定的更新函数</li>
</ul>
<p>当我们去实例化一个渲染<code>Watcher</code>的时候，首先进入watcher的构造函数逻辑，就会执行它的this.get()方法，进入get函数，首先会执行：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">Dep.<span class="keyword">target</span> = <span class="keyword">this</span> <span class="comment">//缓存自己</span></span><br></pre></td></tr></table></figure>
<p>实际上九十八Dep.target赋值为当前的渲染watcher，接着又执行了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let value = <span class="keyword">this</span>.vm.<span class="keyword">data</span>[<span class="keyword">this</span>.exp]<span class="comment">// 强制执行监听器里的get函数</span></span><br></pre></td></tr></table></figure>
<p>因为当前vm的数据依赖收集已经完成，那么对应的渲染Dep.target也需要改变。而update（）函数是用来当数据发生变化时调用watcher自身的更新函数进行更新的操作。先通过<code>let value = this.vm.data[this.exp]</code>获取到最新的数据，然后将其与之前get（）获得的旧数据进行比较，如果不一样，则调用cb进行更新。<br>至此，简单的订阅者设计完毕</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现数据的双向绑定，首先要对数据进行劫持监听，所以需要设置一个监听器observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器observer和订阅者watcher之间进行统一管理的。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue双向绑定原理</tag>
      </tags>
  </entry>
  <entry>
    <title>watch和computed对比</title>
    <url>/2020/03/01/%E9%9D%A2%E7%BB%8F00/</url>
    <content><![CDATA[<h2 id="watch和computed区别"><a href="#watch和computed区别" class="headerlink" title="watch和computed区别"></a>watch和computed区别</h2><ul>
<li>watch： 使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function处理函数。即这个属性是用来监听data中数据改变从而进行相关操作的属性。</li>
<li>computed： 在computed中，可以定义一些属性，这些属性叫做【计算属性】，计算属性的本质就是一个方法，只不过，我们在使用这些计算属性的时候，是把他们的名称，直接当作属性来使用的，并不会把计算属性，当作方法去调用<a id="more"></a></li>
<li>watch和computed都是一个function，但是watch中的函数是不需要调用的，computed内部的函数调用的时候不需要加（）</li>
<li>watch（属性监听），监听属性的变化，computed（计算属性）通过属性计算而得来的属性</li>
<li>watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些待定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是computed跟methods的结合体 </li>
<li>watch需要在数据变化时执行，一般用于异步或开销较大的操作时使用</li>
<li>对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时要发生变化，这种情况下我们最好使用计算属性computed</li>
<li>computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用。computed中的函数必须return回最终的结果</li>
<li>当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取</li>
<li>watch一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>computed：当一个属性受多个属性影响的时候就需要用到computed。最典型的例子：购物车商品结算的时候</li>
<li>watch：当一条数据印象多条数据的时候需要用watch。一般是当数据变化时执行异步操作或者开销较大的操作时使用。</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>watch和computed对比</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/03/01/vue3-07/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.修改用户,删除用户<br>2.推送代码到码云<br>3.权限列表<br>4.角色列表<br>5.分配角色</p>
<a id="more"></a>
<h3 id="1-修改用户信息"><a href="#1-修改用户信息" class="headerlink" title="1.修改用户信息"></a>1.修改用户信息</h3><p>A.为用户列表中的修改按钮绑定点击事件<br>B.在页面中添加修改用户对话框，并修改对话框的属性<br>C.根据id查询需要修改的用户数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//展示编辑用户的对话框</span></span><br><span class="line">async showEditDialog(id) &#123;</span><br><span class="line">    <span class="comment">//发送请求根据id获取用户信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'users/'</span> + id)</span><br><span class="line">    <span class="comment">//判断如果添加失败，就做提示</span></span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取用户信息失败'</span>)</span><br><span class="line">    <span class="comment">//将获取到的数据保存到数据editForm中</span></span><br><span class="line">    <span class="keyword">this</span>.editForm = res.<span class="keyword">data</span></span><br><span class="line">    <span class="comment">//显示弹出窗</span></span><br><span class="line">    <span class="keyword">this</span>.editDialogVisible = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>D.在弹出窗中添加修改用户信息的表单并做响应的数据绑定以及数据验证</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对话框主体区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"editForm"</span> <span class="attr">:rules</span>=<span class="string">"editFormRules"</span> <span class="attr">ref</span>=<span class="string">"editFormRef"</span> <span class="attr">label-width</span>=<span class="string">"70px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"editForm.username"</span> <span class="attr">disabled</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"邮箱"</span> <span class="attr">prop</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"editForm.email"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"电话"</span> <span class="attr">prop</span>=<span class="string">"mobile"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"editForm.mobile"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数据绑定以及验证：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制修改用户对话框的显示与否</span></span><br><span class="line"><span class="attribute">editDialogVisible</span>: false,</span><br><span class="line"><span class="comment">//修改用户的表单数据</span></span><br><span class="line"><span class="attribute">editForm</span>: &#123;</span><br><span class="line">    <span class="attribute">username</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="attribute">email</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="attribute">mobile</span>: <span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//修改表单的验证规则对象</span></span><br><span class="line"><span class="attribute">editFormRules</span>: &#123;</span><br><span class="line">    <span class="attribute">email</span>: [</span><br><span class="line">        &#123; <span class="attribute">required</span>: true, <span class="attribute">message</span>: <span class="string">'请输入邮箱'</span>, <span class="attribute">trigger</span>: <span class="string">'blur'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attribute">validator</span>: checkEmail,</span><br><span class="line">        <span class="attribute">message</span>: <span class="string">'邮箱格式不正确，请重新输入'</span>,</span><br><span class="line">        <span class="attribute">trigger</span>: <span class="string">'blur'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attribute">mobile</span>: [</span><br><span class="line">        &#123; <span class="attribute">required</span>: true, <span class="attribute">message</span>: <span class="string">'请输入手机号码'</span>, <span class="attribute">trigger</span>: <span class="string">'blur'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attribute">validator</span>: checkMobile,</span><br><span class="line">        <span class="attribute">message</span>: <span class="string">'手机号码不正确，请重新输入'</span>,</span><br><span class="line">        <span class="attribute">trigger</span>: <span class="string">'blur'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E.监听对话框关闭事件，在对话框关闭之后，重置表单</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog title=<span class="string">"修改用户"</span> :visible.sync=<span class="string">"editDialogVisible"</span> <span class="attribute">width</span>=<span class="string">"50%"</span> @close=<span class="string">"editDialogClosed"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">editDialogClosed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对话框关闭之后，重置表达</span></span><br><span class="line">    this.<span class="variable">$refs</span><span class="selector-class">.editFormRef</span>.resetFields()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F.在用户点击确定按钮的时候，验证数据成功之后发送请求完成修改</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">editUser() &#123;</span><br><span class="line">    <span class="comment">//用户点击修改表单中的确定按钮之后，验证表单数据</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.editFormRef.validate(async valid =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'请填写完整用户信息'</span>)</span><br><span class="line">    <span class="comment">//发送请求完成修改用户的操作</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.put(</span><br><span class="line">        <span class="string">'users/'</span> + <span class="keyword">this</span>.editForm.id,</span><br><span class="line">        <span class="keyword">this</span>.editForm</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//判断如果修改失败，就做提示</span></span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'修改用户失败'</span>)</span><br><span class="line">    <span class="comment">//修改成功的提示</span></span><br><span class="line">    <span class="keyword">this</span>.$message.success(<span class="string">'修改用户成功'</span>)</span><br><span class="line">    <span class="comment">//关闭对话框</span></span><br><span class="line">    <span class="keyword">this</span>.editDialogVisible = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//重新请求最新的数据</span></span><br><span class="line">    <span class="keyword">this</span>.getUserList()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2.删除用户"></a>2.删除用户</h3><p>在点击删除按钮的时候，我们应该跳出提示信息框，让用户确认要进行删除操作。<br>如果想要使用确认取消提示框，我们需要先将提示信息框挂载到vue中。<br>A.导入MessageBox组件，并将MessageBox组件挂载到实例。<br>Vue.prototype.$confirm = MessageBox.confirm<br>B.给用户列表中的删除按钮添加事件，并在事件处理函数中弹出确定取消窗,最后再根据id发送删除用户的请求</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">async removeUserById(id)&#123;</span><br><span class="line">    <span class="comment">//弹出确定取消框，是否删除用户</span></span><br><span class="line">    <span class="keyword">const</span> confirmResult = await <span class="keyword">this</span>.$confirm(<span class="string">'请问是否要永久删除该用户'</span>,<span class="string">'删除提示'</span>,&#123;</span><br><span class="line">    confirmButtonText:<span class="string">'确认删除'</span>,</span><br><span class="line">    cancelButtonText:<span class="string">'取消'</span>,</span><br><span class="line">    type:<span class="string">'warning'</span></span><br><span class="line">    &#125;).<span class="keyword">catch</span>(err=&gt;err)</span><br><span class="line">    <span class="comment">//如果用户点击确认，则confirmResult 为'confirm'</span></span><br><span class="line">    <span class="comment">//如果用户点击取消, 则confirmResult获取的就是catch的错误消息'cancel'</span></span><br><span class="line">    <span class="keyword">if</span>(confirmResult != <span class="string">"confirm"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.info(<span class="string">"已经取消删除"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求根据id完成删除操作</span></span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.delete(<span class="string">'users/'</span>+id)</span><br><span class="line">    <span class="comment">//判断如果删除失败，就做提示</span></span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'删除用户失败'</span>)</span><br><span class="line">    <span class="comment">//修改成功的提示</span></span><br><span class="line">    <span class="keyword">this</span>.$message.success(<span class="string">'删除用户成功'</span>)</span><br><span class="line">    <span class="comment">//重新请求最新的数据</span></span><br><span class="line">    <span class="keyword">this</span>.getUserList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-推送代码"><a href="#3-推送代码" class="headerlink" title="3.推送代码"></a>3.推送代码</h3><p>创建user子分支，并将代码推送到码云<br>A.创建user子分支  git checkout -b user<br>B.将代码添加到暂存区 git add .<br>C.将代码提交并注释 git commit -m ‘添加完成用户列表功能’<br>D.将本地的user分支推送到码云 git push -u origin user<br>E.将user分支代码合并到master:<br>切换到master   git checkout master<br>合并user       git merge user<br>F.将本地master分支的代码推送到码云  git push</p>
<p>创建rights子分支<br>A.创建rights子分支 git checkout -b rights<br>B.将本地的rights分支推送到码云 git push -u origin rights</p>
<h3 id="4-权限列表"><a href="#4-权限列表" class="headerlink" title="4.权限列表"></a>4.权限列表</h3><h4 id="A-添加权限列表路由"><a href="#A-添加权限列表路由" class="headerlink" title="A.添加权限列表路由"></a>A.添加权限列表路由</h4><p>创建权限管理组件（Rights.vue），并在router.js添加对应的路由规则</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import Rights <span class="keyword">from</span> <span class="string">'./components/power/Rights.vue'</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">      path: <span class="string">'/home'</span>, component: Home, redirect: <span class="string">'/welcome'</span>, children: [</span><br><span class="line">        &#123; path: <span class="string">"/welcome"</span>, component: Welcome &#125;,</span><br><span class="line">        &#123; path: <span class="string">"/users"</span>, component:<span class="built_in"> Users </span>&#125;,</span><br><span class="line">        &#123; path: <span class="string">"/rights"</span>, component: Rights &#125;</span><br><span class="line">      ]</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<h4 id="B-添加面包屑导航"><a href="#B-添加面包屑导航" class="headerlink" title="B.添加面包屑导航"></a>B.添加面包屑导航</h4><p>在Rights.vue中添加面包屑组件展示导航路径</p>
<h4 id="C-显示数据"><a href="#C-显示数据" class="headerlink" title="C.显示数据"></a>C.显示数据</h4><p>在data中添加一个rightsList数据，在methods中提供一个getRightsList方法发送请求获取权限列表数据，在created中调用这个方法获取数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"rightsList"</span> <span class="attr">stripe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"权限名称"</span> <span class="attr">prop</span>=<span class="string">"authName"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"路径"</span> <span class="attr">prop</span>=<span class="string">"path"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"权限等级"</span> <span class="attr">prop</span>=<span class="string">"level"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">"scope.row.level === 0"</span>&gt;</span>一级权限<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">"scope.row.level === 1"</span> <span class="attr">type</span>=<span class="string">"success"</span>&gt;</span>二级权限<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">"scope.row.level === 2"</span> <span class="attr">type</span>=<span class="string">"warning"</span>&gt;</span>三级权限<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//列表形式的权限</span></span></span><br><span class="line">            rightsList:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.getRightsList();</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> getRightsList()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'rights/list'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//如果返回状态为异常状态则报错并返回</span></span></span><br><span class="line">            if (res.meta.status !== 200)</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取权限列表失败'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//如果返回状态正常，将请求的数据保存在data中</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.rightsList = res.data</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-角色列表"><a href="#5-角色列表" class="headerlink" title="5.角色列表"></a>5.角色列表</h3><h4 id="A-添加角色列表路由"><a href="#A-添加角色列表路由" class="headerlink" title="A.添加角色列表路由"></a>A.添加角色列表路由</h4><p>添加角色列表子组件（power/Roles.vue），并添加对应的规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home, <span class="string">redirect:</span> <span class="string">'/welcome'</span>, <span class="string">children:</span> [</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">"/welcome"</span>, <span class="string">component:</span> Welcome &#125;,</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">"/users"</span>, <span class="string">component:</span> Users &#125;,</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">"/rights"</span>, <span class="string">component:</span> Rights &#125;,</span><br><span class="line">        &#123; <span class="string">path:</span> <span class="string">"/roles"</span>, <span class="string">component:</span> Roles  &#125;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>
<h4 id="B-添加面包屑导航-1"><a href="#B-添加面包屑导航-1" class="headerlink" title="B.添加面包屑导航"></a>B.添加面包屑导航</h4><p>在Roles.vue中添加面包屑组件展示导航路径</p>
<h4 id="C-显示数据-1"><a href="#C-显示数据-1" class="headerlink" title="C.显示数据"></a>C.显示数据</h4><p>在data中添加一个roleList数据，在methods中提供一个getRoleList方法发送请求获取权限列表数据，在created中调用这个方法获取数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 角色列表区域 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- row-key="id" 是2019年3月提供的新特性，</span></span><br><span class="line"><span class="comment">if there's nested data, rowKey is required.</span></span><br><span class="line"><span class="comment">如果这是一个嵌套的数据，rowkey 是必须添加的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">row-key</span>=<span class="string">"id"</span> <span class="attr">:data</span>=<span class="string">"roleList"</span> <span class="attr">border</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加展开列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"expand"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"角色名称"</span> <span class="attr">prop</span>=<span class="string">"roleName"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"角色描述"</span> <span class="attr">prop</span>=<span class="string">"roleDesc"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span> <span class="attr">width</span>=<span class="string">"300px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"mini"</span> <span class="attr">type</span>=<span class="string">"warning"</span> <span class="attr">icon</span>=<span class="string">"el-icon-setting"</span>&gt;</span>分配权限<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            roleList:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,created()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.getRoleList();</span></span><br><span class="line">    &#125;,methods:&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> getRoleList()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'roles'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//如果返回状态为异常状态则报错并返回</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// if (res.meta.status !== 200)</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//     return this.$message.error('获取角色列表失败')</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// //如果返回状态正常，将请求的数据保存在data中</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// this.roleList = res.data</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res.data)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.roleList = res.data;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="D-补充说明"><a href="#D-补充说明" class="headerlink" title="D.补充说明"></a>D.补充说明</h4><p>之前学习过类似的添加角色，删除角色，编辑角色请参照之前编写过的代码还有接口文档完成效果。</p>
<h4 id="E-生成权限列表"><a href="#E-生成权限列表" class="headerlink" title="E.生成权限列表"></a>E.生成权限列表</h4><p>使用三重嵌套for循环生成权限下拉列表</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 添加展开列 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"expand"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:class</span>=<span class="string">"['bdbottom',i1===0?'bdtop':'']"</span> <span class="attr">v-for</span>=<span class="string">"(item1,i1) in scope.row.children"</span> <span class="attr">:key</span>=<span class="string">"item1.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 渲染一级权限 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"5"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="template-variable">&#123;&#123;item1.authName&#125;&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-caret-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 渲染二，三级权限 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"19"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!-- 通过for循环嵌套渲染二级权限  --&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:class</span>=<span class="string">"[i2===0?'':'bdtop' ]"</span> <span class="attr">v-for</span>=<span class="string">"(item2,i2) in item1.children"</span> <span class="attr">:key</span>=<span class="string">"item2.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"6"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">"success"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item2.authName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-caret-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"18"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">"warning"</span> <span class="attr">v-for</span>=<span class="string">"(item3) in item2.children"</span> <span class="attr">:key</span>=<span class="string">"item3.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            </span><span class="template-variable">&#123;&#123;item3.authName&#125;&#125;</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="F-美化样式"><a href="#F-美化样式" class="headerlink" title="F.美化样式"></a>F.美化样式</h4><p>通过设置global.css中的#app样式min-width:1366px 解决三级权限换行的问题<br>，通过给一级权限el-row添加display:flex,align-items:center的方式解决一级权限垂直居中的问题，二级权限也类似添加，因为需要给多个内容添加，可以将这个样式设置为一个.vcenter{display:flex;align-items:center}</p>
<h4 id="G-添加权限删除功能"><a href="#G-添加权限删除功能" class="headerlink" title="G.添加权限删除功能"></a>G.添加权限删除功能</h4><p>给每一个权限的el-tag添加closable属性，是的权限右侧出现“X”图标<br>再给el-tag添加绑定close事件处理函数removeRightById(scope.row,item1.id)<br>removeRightById(scope.row,item2.id)<br>removeRightById(scope.row,item3.id)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">async removeRightById(role,rightId)&#123;</span><br><span class="line">    <span class="comment">//弹窗提示用户是否要删除</span></span><br><span class="line">    <span class="keyword">const</span> confirmResult = await <span class="keyword">this</span>.$confirm(<span class="string">'请问是否要删除该权限'</span>,<span class="string">'删除提示'</span>,&#123;</span><br><span class="line">        confirmButtonText:<span class="string">'确认删除'</span>,</span><br><span class="line">        cancelButtonText:<span class="string">'取消'</span>,</span><br><span class="line">        type:<span class="string">'warning'</span></span><br><span class="line">    &#125;).<span class="keyword">catch</span>(err=&gt;err)</span><br><span class="line">    <span class="comment">//如果用户点击确认，则confirmResult 为'confirm'</span></span><br><span class="line">    <span class="comment">//如果用户点击取消, 则confirmResult获取的就是catch的错误消息'cancel'</span></span><br><span class="line">    <span class="keyword">if</span>(confirmResult != <span class="string">"confirm"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.info(<span class="string">"已经取消删除"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户点击了确定表示真的要删除</span></span><br><span class="line">    <span class="comment">//当发送delete请求之后，返回的数据就是最新的角色权限信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.delete(`roles/$&#123;role.id&#125;/rights/$&#123;rightId&#125;`)</span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'删除角色权限失败'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无需再重新加载所有权限</span></span><br><span class="line">    <span class="comment">//只需要对现有的角色权限进行更新即可</span></span><br><span class="line">    role.children = res.<span class="keyword">data</span></span><br><span class="line">    <span class="comment">// this.getRoleList();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="H-完成权限分配功能"><a href="#H-完成权限分配功能" class="headerlink" title="H.完成权限分配功能"></a>H.完成权限分配功能</h4><p>先给分配权限按钮添加事件</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;el-button <span class="attribute">size</span>=<span class="string">"mini"</span> <span class="attribute">type</span>=<span class="string">"warning"</span> <span class="attribute">icon</span>=<span class="string">"el-icon-setting"</span> @<span class="attribute">click</span>=<span class="string">"showSetRightDialog"</span>&gt;分配权限&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<p>在showSetRightDialog函数中请求权限树数据并显示对话框</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">async showSetRightDialog() &#123;</span><br><span class="line">    <span class="comment">//当点击分配权限按钮时，展示对应的对话框</span></span><br><span class="line">    <span class="keyword">this</span>.setRightDialogVisible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//获取所有权限的数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'rights/tree'</span>)</span><br><span class="line">    <span class="comment">//如果返回状态为异常状态则报错并返回</span></span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取权限树失败'</span>)</span><br><span class="line">    <span class="comment">//如果返回状态正常，将请求的数据保存在data中</span></span><br><span class="line">    <span class="keyword">this</span>.rightsList = res.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加分配权限对话框，并添加绑定数据setRightDialogVisible</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分配权限对话框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">"分配权限"</span> <span class="attr">:visible.sync</span>=<span class="string">"setRightDialogVisible"</span> <span class="attr">width</span>=<span class="string">"50%"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是一段信息<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"dialog-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"setRightDialogVisible = false"</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"setRightDialogVisible = false"</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="I-完成树形结构弹窗"><a href="#I-完成树形结构弹窗" class="headerlink" title="I.完成树形结构弹窗"></a>I.完成树形结构弹窗</h4><p>在element.js中引入Tree，注册Tree</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分配权限对话框 --&gt;</span><br><span class="line">&lt;el-dialog title=<span class="string">"分配权限"</span> :visible.sync=<span class="string">"setRightDialogVisible"</span> width=<span class="string">"50%"</span> <span class="meta">@close</span>=<span class="string">"setRightDialogClose"</span>&gt;</span><br><span class="line">    &lt;!-- 树形组件</span><br><span class="line">    show-checkbox:显示复选框</span><br><span class="line">    node-key:设置选中节点对应的值</span><br><span class="line">    <span class="keyword">default</span>-expand-all:是否默认展开所有节点</span><br><span class="line">    :<span class="keyword">default</span>-checked-keys 设置默认选中项的数组</span><br><span class="line">    ref:设置引用 --&gt;</span><br><span class="line">    &lt;el-tree :<span class="keyword">data</span>=<span class="string">"rightsList"</span> :props=<span class="string">"treeProps"</span> show-checkbox node-key=<span class="string">"id"</span> <span class="keyword">default</span>-expand-all :<span class="keyword">default</span>-checked-keys=<span class="string">"defKeys"</span> ref=<span class="string">"treeRef"</span>&gt;&lt;/el-tree&gt;</span><br><span class="line">    &lt;span slot=<span class="string">"footer"</span> <span class="class"><span class="keyword">class</span>="<span class="title">dialog</span>-<span class="title">footer</span>"&gt;</span></span><br><span class="line">        &lt;el-button <span class="meta">@click</span>=<span class="string">"setRightDialogVisible = false"</span>&gt;取 消&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=<span class="string">"primary"</span> <span class="meta">@click</span>=<span class="string">"allotRights"</span>&gt;确 定&lt;/el-button&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//角色列表数据</span></span><br><span class="line">      roleList: [],</span><br><span class="line">      <span class="comment">//控制分配权限对话框的显示</span></span><br><span class="line">      setRightDialogVisible: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">//权限树数据</span></span><br><span class="line">      rightsList: [],</span><br><span class="line">      <span class="comment">//树形控件的属性绑定对象</span></span><br><span class="line">      treeProps: &#123;</span><br><span class="line">        <span class="comment">//通过label设置树形节点文本展示authName</span></span><br><span class="line">        label: <span class="string">'authName'</span>,</span><br><span class="line">        <span class="comment">//设置通过children属性展示子节点信息</span></span><br><span class="line">        children: <span class="string">'children'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//设置树形控件中默认选中的内容</span></span><br><span class="line">      defKeys: [],</span><br><span class="line">      <span class="comment">//保存正在操作的角色id</span></span><br><span class="line">      roleId:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getRoleList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getRoleList() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'roles'</span>)</span><br><span class="line">      <span class="comment">//如果返回状态为异常状态则报错并返回</span></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取角色列表失败'</span>)</span><br><span class="line">      <span class="comment">//如果返回状态正常，将请求的数据保存在data中</span></span><br><span class="line">      <span class="comment">// this.roleList = res.data</span></span><br><span class="line">      console.log(res.<span class="keyword">data</span>)</span><br><span class="line">      <span class="keyword">this</span>.roleList = res.<span class="keyword">data</span></span><br><span class="line">    &#125;,</span><br><span class="line">    async removeRightById(role, rightId) &#123;</span><br><span class="line">      <span class="comment">//弹窗提示用户是否要删除</span></span><br><span class="line">      <span class="keyword">const</span> confirmResult = await <span class="keyword">this</span>.$confirm(</span><br><span class="line">        <span class="string">'请问是否要删除该权限'</span>,</span><br><span class="line">        <span class="string">'删除提示'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          confirmButtonText: <span class="string">'确认删除'</span>,</span><br><span class="line">          cancelButtonText: <span class="string">'取消'</span>,</span><br><span class="line">          type: <span class="string">'warning'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ).<span class="keyword">catch</span>(err =&gt; err)</span><br><span class="line">      <span class="comment">//如果用户点击确认，则confirmResult 为'confirm'</span></span><br><span class="line">      <span class="comment">//如果用户点击取消, 则confirmResult获取的就是catch的错误消息'cancel'</span></span><br><span class="line">      <span class="keyword">if</span> (confirmResult != <span class="string">'confirm'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.info(<span class="string">'已经取消删除'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用户点击了确定表示真的要删除</span></span><br><span class="line">      <span class="comment">//当发送delete请求之后，返回的数据就是最新的角色权限信息</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.delete(</span><br><span class="line">        `roles/$&#123;role.id&#125;/rights/$&#123;rightId&#125;`</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'删除角色权限失败'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//无需再重新加载所有权限</span></span><br><span class="line">      <span class="comment">//只需要对现有的角色权限进行更新即可</span></span><br><span class="line">      role.children = res.<span class="keyword">data</span></span><br><span class="line">      <span class="comment">// this.getRoleList();</span></span><br><span class="line">    &#125;,</span><br><span class="line">    async showSetRightDialog(role) &#123;</span><br><span class="line">      <span class="comment">//将role.id保存起来以供保存权限时使用</span></span><br><span class="line">      <span class="keyword">this</span>.roleId = role.id;  </span><br><span class="line">      <span class="comment">//获取所有权限的数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'rights/tree'</span>)</span><br><span class="line">      <span class="comment">//如果返回状态为异常状态则报错并返回</span></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取权限树失败'</span>)</span><br><span class="line">      <span class="comment">//如果返回状态正常，将请求的数据保存在data中</span></span><br><span class="line">      <span class="keyword">this</span>.rightsList = res.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用getLeafKeys进行递归，将三级权限添加到数组中</span></span><br><span class="line">      <span class="keyword">this</span>.getLeafKeys(role, <span class="keyword">this</span>.defKeys)</span><br><span class="line">      <span class="comment">//当点击分配权限按钮时，展示对应的对话框</span></span><br><span class="line">      <span class="keyword">this</span>.setRightDialogVisible = <span class="literal">true</span></span><br><span class="line">      console.log(<span class="keyword">this</span>.defKeys)</span><br><span class="line">    &#125;,</span><br><span class="line">    getLeafKeys(node, arr) &#123;</span><br><span class="line">      <span class="comment">//该函数会获取到当前角色的所有三级权限id并添加到defKeys中</span></span><br><span class="line">      <span class="comment">//如果当前节点不包含children属性，则表示node为三级权限</span></span><br><span class="line">      <span class="keyword">if</span> (!node.children) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.push(node.id)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//递归调用</span></span><br><span class="line">      node.children.forEach(item =&gt; <span class="keyword">this</span>.getLeafKeys(item, arr))</span><br><span class="line">    &#125;,</span><br><span class="line">    setRightDialogClose() &#123;</span><br><span class="line">      <span class="comment">//当用户关闭树形权限对话框的时候，清除掉所有选中状态</span></span><br><span class="line">      <span class="keyword">this</span>.defKeys = []</span><br><span class="line">    &#125;,</span><br><span class="line">    async allotRights() &#123;</span><br><span class="line">      <span class="comment">//当用户在树形权限对话框中点击确定，将用户选择的</span></span><br><span class="line">      <span class="comment">//权限发送请求进行更新</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取所有选中及半选的内容</span></span><br><span class="line">      <span class="keyword">const</span> keys = [</span><br><span class="line">        ...<span class="keyword">this</span>.$refs.treeRef.getCheckedKeys(),</span><br><span class="line">        ...<span class="keyword">this</span>.$refs.treeRef.getHalfCheckedKeys()</span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">//将数组转换为 , 拼接的字符串</span></span><br><span class="line">      <span class="keyword">const</span> idStr = keys.join(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//发送请求完成更新</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.post(</span><br><span class="line">        `roles/$&#123;<span class="keyword">this</span>.roleId&#125;/rights`,</span><br><span class="line">        &#123; rids:idStr &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'分配权限失败'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.$message.success(<span class="string">"分配权限成功"</span>)</span><br><span class="line">      <span class="keyword">this</span>.getRoleList();</span><br><span class="line">      <span class="comment">//关闭对话框</span></span><br><span class="line">      <span class="keyword">this</span>.setRightDialogVisible = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-分配角色"><a href="#6-分配角色" class="headerlink" title="6.分配角色"></a>6.分配角色</h3><p>打开Users.vue，完成分配角色的功能<br>A.添加分配角色对话框</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 分配角色对话框 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">"分配角色"</span> <span class="attr">:visible.sync</span>=<span class="string">"setRoleDialogVisible"</span> <span class="attr">width</span>=<span class="string">"50%"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前的用户:</span><span class="template-variable">&#123;&#123;userInfo.username&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前的角色:</span><span class="template-variable">&#123;&#123;userInfo.role_name&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>分配新角色:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"dialog-footer"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"setRoleDialogVisible = false"</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"setRoleDialogVisible = false"</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>B.给分配角色按钮添加点击事件，点击之后弹出一个对话框进行角色分配</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分配角色 --&gt;</span><br><span class="line">&lt;el-tooltip <span class="class"><span class="keyword">class</span>="<span class="title">item</span>" <span class="title">effect</span>="<span class="title">dark</span>" <span class="title">content</span>="分配角色" <span class="title">placement</span>="<span class="title">top</span>" :<span class="type">enterable="false"&gt;</span></span></span><br><span class="line">    &lt;el-button type=<span class="string">"warning"</span> icon=<span class="string">"el-icon-setting"</span> size=<span class="string">'mini'</span> <span class="meta">@click</span>=<span class="string">"setRole(scope.row)"</span>&gt;&lt;/el-button&gt;</span><br><span class="line">&lt;/el-tooltip&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span>()&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//控制显示分配角色对话框</span></span><br><span class="line">    setRoleDialogVisible:<span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//保存正在操作的那个用户信息</span></span><br><span class="line">    userInfo:&#123;&#125;,</span><br><span class="line">    <span class="comment">//保存所有的角色信息</span></span><br><span class="line">    rolesList:[],</span><br><span class="line">    <span class="comment">//保存用户选中的角色id</span></span><br><span class="line">    selectedRoleId:<span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    ......</span><br><span class="line">    async setRole( userInfo )&#123;</span><br><span class="line">      <span class="comment">//保存起来以供后续使用</span></span><br><span class="line">      <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">      <span class="comment">//获取所有的角色信息，以备下拉列表使用</span></span><br><span class="line">      <span class="comment">//发送请求根据id完成删除操作</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'roles'</span>)</span><br><span class="line">      <span class="comment">//判断如果删除失败，就做提示</span></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取角色列表失败'</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.rolesList = res.<span class="keyword">data</span>;</span><br><span class="line">      <span class="comment">//展示分配角色对话框</span></span><br><span class="line">      <span class="keyword">this</span>.setRoleDialogVisible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C.在element.js中引入Select，Option，注册Select，Option</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 角色选择下拉框</span></span><br><span class="line"><span class="comment">v-model：设置用户选中角色之后的id绑定数据</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">"selectedRoleId"</span> <span class="attr">placeholder</span>=<span class="string">"请选择角色"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- :label 显示文本，:value 选中值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-option</span> <span class="attr">v-for</span>=<span class="string">"item in rolesList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">:label</span>=<span class="string">"item.roleName"</span> <span class="attr">:value</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>D.当用户点击对话框中的确定之后，完成分配角色的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分配角色对话框 --&gt;</span><br><span class="line">&lt;el-dialog title=<span class="string">"分配角色"</span> :visible.sync=<span class="string">"setRoleDialogVisible"</span> width=<span class="string">"50%"</span> @close=<span class="string">"setRoleDialogClosed"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;当前的用户:&#123;&#123;userInfo.username&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;当前的角色:&#123;&#123;userInfo.role_name&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;分配新角色:</span><br><span class="line">        &lt;!-- 角色选择下拉框</span><br><span class="line">        v-model：设置用户选中角色之后的id绑定数据</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;el-select v-model=<span class="string">"selectedRoleId"</span> placeholder=<span class="string">"请选择角色"</span>&gt;</span><br><span class="line">        &lt;!-- :label 显示文本，:value 选中值 --&gt;</span><br><span class="line">        &lt;el-option v-<span class="keyword">for</span>=<span class="string">"item in rolesList"</span> :key=<span class="string">"item.id"</span> :label=<span class="string">"item.roleName"</span> :value=<span class="string">"item.id"</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>el-select&gt;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;span slot=<span class="string">"footer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"dialog-footer"</span>&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"setRoleDialogVisible = false"</span>&gt;取 消&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-button type="primary" @click="saveRoleInfo"&gt;确 定&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>el-dialog&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">async</span> saveRoleInfo()&#123;</span><br><span class="line">      <span class="comment">//当用户点击确定按钮之后</span></span><br><span class="line">      <span class="comment">//判断用户是否选择了需要分配的角色</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.selectedRoleId)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'请选择需要分配的角色'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//发送请求完成分配角色的操作</span></span><br><span class="line">      <span class="keyword">const</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.put(<span class="string">`users/<span class="subst">$&#123;<span class="keyword">this</span>.userInfo.id&#125;</span>/role`</span>,&#123;<span class="attr">rid</span>:<span class="keyword">this</span>.selectedRoleId&#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断如果删除失败，就做提示</span></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'分配角色失败'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.$message.success(<span class="string">'分配角色成功'</span>)</span><br><span class="line">      <span class="keyword">this</span>.getUserList();</span><br><span class="line">      <span class="comment">//关闭对话框</span></span><br><span class="line">      <span class="keyword">this</span>.setRoleDialogVisible = <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setRoleDialogClosed()&#123;</span><br><span class="line">      <span class="comment">//当关闭对话框的时候，重置下拉框中的内容</span></span><br><span class="line">      <span class="keyword">this</span>.selectedRoleId = <span class="string">''</span></span><br><span class="line">      <span class="keyword">this</span>.userInfo = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-将代码推送到码云"><a href="#7-将代码推送到码云" class="headerlink" title="7.将代码推送到码云"></a>7.将代码推送到码云</h3><p>A.将代码推送到暂存区 git add .<br>B.将代码提交到仓库 git commit -m ‘完成了权限功能开发’<br>C.将rights分支代码推送到码云 git push<br>D.将代码合并到master<br>    git checkout master<br>    git merge rights<br>E.将master代码推送到码云<br>    git push</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git01</title>
    <url>/2020/02/23/git01/</url>
    <content><![CDATA[<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>作用：假设我们正在开发一个新功能，但是需要两个周才能完成，第一周写了50%的代码，如果立刻提交，由于代码还没有写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次性提交，又存在丢失每天进度的巨大风险。而分支，就是属于我们自己的分支，别人看不到，它们还继续在原来的分支上正常工作，但是我们就可以在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样既安全又不影响别人工作。</p>
<a id="more"></a>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>每次提交，git都把它们串成一条时间线，这条时间线就是一个分支。只有一条线的这个分支叫做主分支，即master。<code>HEAD</code>严格来说不是指向提交，而是指向master，master才是指向提交的，所以<code>HEAD</code>指向的就是当前的分支。</p>
<p>当我们创建新的分支，例如dev的时候，git创建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev。就表示当前分支在dev上。所以git创建一个分支很快，只是增加了一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化。不过从现在开始，对工作取得修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针保持不变。</p>
<p>在dev分支上的工作完成了，就可以把dev合并到master上。怎么合并呢？直接把master指针指向dev当前的提交，所以git合并分支也很快，就改改指针，工作区内容也不变。</p>
<p>合并分支后，甚至还可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p>
<h4 id="创建dev分支"><a href="#创建dev分支" class="headerlink" title="创建dev分支"></a>创建dev分支</h4><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout -b dev<span class="comment">//创建dev分支并且切换到dev分支</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>checkout```命令加上```-b```参数表示创建并切换，相当于以下两条命令</span></figcaption><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">~~~</span><br><span class="line">然后使用&#96;&#96;&#96;git branch&#96;&#96;&#96;命令查看当前分支</span><br><span class="line">~~~</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">~~~</span><br><span class="line">该&#96;&#96;&#96;git branch&#96;&#96;&#96;命令会列出所有分支，当前分支会有一个* 号</span><br><span class="line">然后就可以在dev分支上正常提交。</span><br><span class="line"></span><br><span class="line">当dev分支的工作完成，我们就可以切换到master分支</span><br><span class="line">~~~</span><br><span class="line">$ git checkout master</span><br><span class="line">~~~</span><br><span class="line">当我们切换到master分支上，会发现刚刚在dev分支上添加的内容不见了，这是因为哪个提交是在dev分支上，而master分支此刻的提交点并没有改变。</span><br><span class="line"></span><br><span class="line">#### 合并分支</span><br><span class="line">~~~</span><br><span class="line">$ git merge dev</span><br><span class="line">~~~</span><br><span class="line">该&#96;&#96;&#96;git merge&#96;&#96;&#96;命令用于合并并指定分支到当前分支。</span><br><span class="line"></span><br><span class="line">#### 删除分支</span><br><span class="line">~~~</span><br><span class="line">$ git branch -d dev</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 注意</span><br><span class="line">切换分支使用&#96;&#96;&#96;git checkout &lt;branch&gt;&#96;&#96;&#96;，而前面讲过的撤销修改则是&#96;&#96;&#96;git checkout --&lt;file&gt;&#96;&#96;&#96;。所以切换分支这个动作，用&#96;&#96;&#96;switch&#96;&#96;&#96;更合理。所以新版的git提供了&#96;&#96;&#96;git switch&#96;&#96;&#96;魔魁切换分支。</span><br><span class="line">创建并切换到新的dev分支</span><br><span class="line">~~~</span><br><span class="line">$ git switch -c dev</span><br><span class="line">~~~</span><br><span class="line">直接切换到已有的master分支</span><br><span class="line">~~~</span><br><span class="line">$ git switch master</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 总结</span><br><span class="line">+ 查看分支： git branch</span><br><span class="line">+ 创建分支： git branch &lt; name&gt;</span><br><span class="line">+ 切换分支： git checkout &lt; name&gt;或者git switch &lt; name&gt;</span><br><span class="line">+ 创建+切换分支： git checkout -b &lt; name&gt;或者git switch -c &lt; name&gt;</span><br><span class="line">+ 合并某分支到当前分支： git merge &lt; name&gt;</span><br><span class="line">+ 删除分支： git branch -d &lt; name&gt;</span><br><span class="line">+ 分支合并图： git log --graph</span><br><span class="line">+ 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt; name&gt;强行删除</span><br><span class="line">+ 查看远程库的命令： git remote</span><br><span class="line">+ git remote -v显示更详细的信息</span><br><span class="line">+ 如果从远程仓库克隆时，git自动把本地的master分支和远程的master分支对应起来了</span><br><span class="line">+ 分支推送</span><br><span class="line">  - master分支时主分支，时刻要与远程同步</span><br><span class="line">  - dev分支时开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</span><br><span class="line">  - bug分支只用于在本地修改bug，就没必要推送到远程了，除非老板要看每周修复了几个bug</span><br><span class="line">  - feature分支是否推送放到远程，取决于我们是否和团队合作在上面开发</span><br><span class="line">+ 从远程抓取分支使用：git pull</span><br><span class="line"></span><br><span class="line">## 标签</span><br><span class="line">+ 创建标签： git tag &lt; name&gt;</span><br><span class="line">+ 查看所有标签： git tag</span><br><span class="line">+ 默认标签是打在最新提交的commit上的。有时候如果忘了打标签，就可以找到历史提交的commit id，然后在此打上就可以了</span><br><span class="line">  - git log --pretty&#x3D;online --abbrev-commit</span><br><span class="line">  - 找到对应commit id敲入命令：git tag &lt; tag-name&gt; &lt; commit id &gt;</span><br><span class="line">+ 标签不是按照时间顺序输出，而是按照字母序列排序，可以使用git show &lt; tagname&gt;查看标签信息</span><br><span class="line">+ 标签总是和某个commit挂钩，如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签</span><br><span class="line"></span><br><span class="line">### 操作标签</span><br><span class="line">如果标签打错了，也可以删除：</span><br><span class="line">~~~</span><br><span class="line">$ git tag -d v0.1</span><br><span class="line">~~~</span><br><span class="line">因为创建的标签都只存储在本地，不会自动推送到远程。所以打错的标签可以在本地安全删除。</span><br><span class="line"></span><br><span class="line">推送标签到远程：使用git push origin &lt; name&gt;</span><br><span class="line">或者一次性全部瑞送到远程的本地标签：git push origin --tags</span><br><span class="line"></span><br><span class="line">如果标签已经推送到远程要删除远程标签就要麻烦一点：先从本地删除&#96;&#96;&#96;git tag -d &lt; name&gt;</span><br></pre></td></tr></table></figure>
<p>然后从远程删除。删除命令也是push<code>git push origin：refs/tags/&lt; name&gt;</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>分支</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/02/17/vue3-06/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.实现后台首页的基本布局<br>2.实现左侧菜单栏<br>3.实现用户列表展示<br>4.实现添加用户</p>
<a id="more"></a>

<h3 id="1-后台首页基本布局"><a href="#1-后台首页基本布局" class="headerlink" title="1.后台首页基本布局"></a>1.后台首页基本布局</h3><p>打开Home.vue组件，进行布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-container</span> <span class="attr">class</span>=<span class="string">"home-container"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 头部区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-header</span>&gt;</span>Header<span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"info"</span> @<span class="attr">click</span>=<span class="string">"logout"</span>&gt;</span> 退出 <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span><span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面主体区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">"200px"</span>&gt;</span>Aside<span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主体结构 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-main</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，跟element-ui组件同名的类名可以帮助我们快速的给对应的组件添加样式，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.home-container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-header</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#373D41</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-aside</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#333744</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-main</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#eaedf1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-顶部布局，侧边栏布局"><a href="#2-顶部布局，侧边栏布局" class="headerlink" title="2.顶部布局，侧边栏布局"></a>2.顶部布局，侧边栏布局</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-container</span> <span class="attr">class</span>=<span class="string">"home-container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 头部区域 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 黑马logo --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../assets/heima.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 顶部标题 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>电商后台管理系统<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"info"</span> @<span class="attr">click</span>=<span class="string">"logout"</span>&gt;</span> 退出 <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 页面主体区域 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">"200px"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 侧边栏菜单 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-menu</span></span></span><br><span class="line"><span class="tag">            <span class="attr">background-color</span>=<span class="string">"#333744"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">text-color</span>=<span class="string">"#fff"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">active-text-color</span>=<span class="string">"#ffd04b"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 一级菜单 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 一级菜单模板 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 图标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-location"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 文本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航一<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 二级子菜单 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"1-4-1"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 二级菜单模板 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 图标 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-location"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 文本 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">span</span>&gt;</span>子菜单一<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主体结构 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-main</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-axios请求拦截器"><a href="#3-axios请求拦截器" class="headerlink" title="3.axios请求拦截器"></a>3.axios请求拦截器</h3><p>后台除了登录接口之外，都需要token权限验证，我们可以通过添加axios请求拦截器来添加token，以保证拥有获取数据的权限<br>在main.js中添加代码，在将axios挂载到vue原型之前添加下面的代码</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span></span><br><span class="line">axios<span class="selector-class">.interceptors</span><span class="selector-class">.request</span>.use(config=&gt;&#123;</span><br><span class="line">  <span class="comment">//为请求头对象，添加token验证的Authorization字段</span></span><br><span class="line">  config<span class="selector-class">.headers</span><span class="selector-class">.Authorization</span> = window<span class="selector-class">.sessionStorage</span>.getItem(<span class="string">"token"</span>)</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-请求侧边栏数据"><a href="#4-请求侧边栏数据" class="headerlink" title="4.请求侧边栏数据"></a>4.请求侧边栏数据</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 左侧菜单数据</span></span><br><span class="line">      menuList: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 在created阶段请求左侧菜单数据</span></span><br><span class="line">    <span class="keyword">this</span>.getMenuList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line">      window.sessionStorage.clear()</span><br><span class="line">      <span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    async getMenuList() &#123;</span><br><span class="line">      <span class="comment">// 发送请求获取左侧菜单数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'menus'</span>)</span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(res.meta.msg)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.menuList = res.<span class="keyword">data</span></span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>通过v-for双重循环渲染左侧菜单</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-menu</span></span></span></span><br><span class="line"><span class="xml">  background-color="#333744"</span></span><br><span class="line"><span class="xml">  text-color="#fff"</span></span><br><span class="line"><span class="xml">  active-text-color="#ffd04b"&gt;</span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 一级菜单 --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">:index</span>=<span class="string">"item.id+''"</span> <span class="attr">v-for</span>=<span class="string">"item in menuList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 一级菜单模板 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- 图标 --&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-location"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- 文本 --&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.authName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 二级子菜单 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">:index</span>=<span class="string">"subItem.id+''"</span> <span class="attr">v-for</span>=<span class="string">"subItem in item.children"</span> <span class="attr">:key</span>=<span class="string">"subItem.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- 二级菜单模板 --&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 图标 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-location"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 文本 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;subItem.authName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-设置激活子菜单样式"><a href="#5-设置激活子菜单样式" class="headerlink" title="5.设置激活子菜单样式"></a>5.设置激活子菜单样式</h3><p>通过更改el-menu的active-text-color属性可以设置侧边栏菜单中点击的激活项的文字颜色<br>通过更改菜单项模板（template）中的i标签的类名，可以将左侧菜单栏的图标进行设置，我们需要在项目中使用第三方字体图标<br>在数据中添加一个iconsObj：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">iconsObj:</span> &#123;</span><br><span class="line">        <span class="string">'125'</span>:<span class="string">'iconfont icon-user'</span>,</span><br><span class="line">        <span class="string">'103'</span>:<span class="string">'iconfont icon-tijikongjian'</span>,</span><br><span class="line">        <span class="string">'101'</span>:<span class="string">'iconfont icon-shangpin'</span>,</span><br><span class="line">        <span class="string">'102'</span>:<span class="string">'iconfont icon-danju'</span>,</span><br><span class="line">        <span class="string">'145'</span>:<span class="string">'iconfont icon-baobiao'</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>然后将图标类名进行数据绑定，绑定iconsObj中的数据：</p>
<p>为了保持左侧菜单每次只能打开一个，显示其中的子菜单，我们可以在el-menu中添加一个属性unique-opened<br>或者也可以数据绑定进行设置(此时true认为是一个bool值，而不是字符串) :unique-opened=”true”</p>
<h3 id="6-制作侧边菜单栏的伸缩功能"><a href="#6-制作侧边菜单栏的伸缩功能" class="headerlink" title="6.制作侧边菜单栏的伸缩功能"></a>6.制作侧边菜单栏的伸缩功能</h3><p>在菜单栏上方添加一个div</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 侧边栏,宽度根据是否折叠进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">:width</span>=<span class="string">"isCollapse ? '64px':'200px'"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 伸缩侧边栏按钮 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toggle-button"</span> @<span class="attr">click</span>=<span class="string">"toggleCollapse"</span>&gt;</span>|||<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 侧边栏菜单，:collapse="isCollapse"（设置折叠菜单为绑定的 isCollapse 值），:collapse-transition="false"（关闭默认的折叠动画） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-menu</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:collapse</span>=<span class="string">"isCollapse"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:collapse-transition</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">......</span></span></span><br></pre></td></tr></table></figure>
<p>然后给div添加样式，给div添加事件：</p>
<div class="toggle-button" @click="this.isCollapse ? '64px':'200px'">|||</div>

<h3 id="7-在后台首页添加子级路由"><a href="#7-在后台首页添加子级路由" class="headerlink" title="7.在后台首页添加子级路由"></a>7.在后台首页添加子级路由</h3><p>新增子级路由组件Welcome.vue<br>在router.js中导入子级路由组件，并设置路由规则以及子级路由的默认重定向<br>打开Home.vue，在main的主体结构中添加一个路由占位符</p>
<p>制作好了Welcome子级路由之后，我们需要将所有的侧边栏二级菜单都改造成子级路由链接<br>我们只需要将el-menu的router属性设置为true就可以了，此时当我们点击二级菜单的时候，就会根据菜单的index<br>属性进行路由跳转,如: /110,<br>使用index id来作为跳转的路径不合适，我们可以重新绑定index的值为  :index=”‘/‘+subItem.path”</p>
<h3 id="8-完成用户列表主体区域"><a href="#8-完成用户列表主体区域" class="headerlink" title="8.完成用户列表主体区域"></a>8.完成用户列表主体区域</h3><p>新建用户列表组件  user/Users.vue<br>在router.js中导入子级路由组件Users.vue，并设置路由规则</p>
<p>当点击二级菜单的时候，被点击的二级子菜单并没有高亮，我们需要正在被使用的功能高亮显示<br>我们可以通过设置el-menu的default-active属性来设置当前激活菜单的index<br>但是default-active属性也不能写死，固定为某个菜单值<br>所以我们可以先给所有的二级菜单添加点击事件,并将path值作为方法的参数<br>@click=”saveNavState(‘/‘+subItem.path)”<br>在saveNavState方法中将path保存到sessionStorage中<br>saveNavState( path ){<br>  //点击二级菜单的时候保存被点击的二级菜单信息<br>  window.sessionStorage.setItem(“activePath”,path);<br>  this.activePath = path;<br>}<br>然后在数据中添加一个activePath绑定数据，并将el-menu的default-active属性设置为activePath<br>最后在created中将sessionStorage中的数据赋值给activePath<br>this.activePath = window.sessionStorage.getItem(“activePath”)</p>
<h3 id="9-绘制用户列表基本结构"><a href="#9-绘制用户列表基本结构" class="headerlink" title="9.绘制用户列表基本结构"></a>9.绘制用户列表基本结构</h3><p>A.使用element-ui面包屑组件完成顶部导航路径(复制面包屑代码，在element.js中导入组件Breadcrumb,BreadcrumbItem)<br>B.使用element-ui卡片组件完成主体表格(复制卡片组件代码，在element.js中导入组件Card)，再使用element-ui输入框完成搜索框及搜索按钮，<br>此时我们需要使用栅格布局来划分结构(复制卡片组件代码，在element.js中导入组件Row，Col)，然后再使用el-button制作添加用户按钮</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户列表组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; path: '/home' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 卡片视图区域 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 搜索与添加区域 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">"20"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"7"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span> </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="10-请求用户列表数据"><a href="#10-请求用户列表数据" class="headerlink" title="10.请求用户列表数据"></a>10.请求用户列表数据</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//获取查询用户信息的参数</span></span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        query: <span class="string">''</span>,</span><br><span class="line">        pagenum: <span class="number">1</span>,</span><br><span class="line">        pagesize: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//保存请求回来的用户列表数据</span></span><br><span class="line">      userList:[],</span><br><span class="line">      total:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getUserList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getUserList() &#123;</span><br><span class="line">      <span class="comment">//发送请求获取用户列表数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; res: <span class="keyword">data</span> &#125; = await <span class="keyword">this</span>.$http.<span class="keyword">get</span>(<span class="string">'users'</span>, &#123;</span><br><span class="line">        params: <span class="keyword">this</span>.queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//如果返回状态为异常状态则报错并返回</span></span><br><span class="line">      <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'获取用户列表失败'</span>)</span><br><span class="line">      <span class="comment">//如果返回状态正常，将请求的数据保存在data中</span></span><br><span class="line">      <span class="keyword">this</span>.userList = res.<span class="keyword">data</span>.users;</span><br><span class="line">      <span class="keyword">this</span>.total = res.<span class="keyword">data</span>.total;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="11-将用户列表数据展示"><a href="#11-将用户列表数据展示" class="headerlink" title="11.将用户列表数据展示"></a>11.将用户列表数据展示</h3><p>使用表格来展示用户列表数据，使用element-ui表格组件完成列表展示数据(复制表格代码，在element.js中导入组件Table,TableColumn)<br>在渲染展示状态时，会使用作用域插槽获取每一行的数据<br>再使用switch开关组件展示状态信息(复制开关组件代码，在element.js中导入组件Switch)<br>而渲染操作列时，也是使用作用域插槽来进行渲染的，<br>在操作列中包含了修改，删除，分配角色按钮，当我们把鼠标放到分配角色按钮上时<br>希望能有一些文字提示，此时我们需要使用文字提示组件(复制文字提示组件代码，在element.js中导入组件Tooltip),将分配角色按钮包含<br>代码结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户列表(表格)区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"userList"</span> <span class="attr">border</span> <span class="attr">stripe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"姓名"</span> <span class="attr">prop</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"邮箱"</span> <span class="attr">prop</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"电话"</span> <span class="attr">prop</span>=<span class="string">"mobile"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"角色"</span> <span class="attr">prop</span>=<span class="string">"role_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"状态"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">"scope.row.mg_state"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"操作"</span> <span class="attr">width</span>=<span class="string">"180px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 修改 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">icon</span>=<span class="string">"el-icon-edit"</span> <span class="attr">size</span>=<span class="string">'mini'</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"danger"</span> <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span> <span class="attr">size</span>=<span class="string">'mini'</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 分配角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-tooltip</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">effect</span>=<span class="string">"dark"</span> <span class="attr">content</span>=<span class="string">"分配角色"</span> <span class="attr">placement</span>=<span class="string">"top"</span> <span class="attr">:enterable</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"warning"</span> <span class="attr">icon</span>=<span class="string">"el-icon-setting"</span> <span class="attr">size</span>=<span class="string">'mini'</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-tooltip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-实现用户列表分页"><a href="#12-实现用户列表分页" class="headerlink" title="12.实现用户列表分页"></a>12.实现用户列表分页</h3><p>A.使用表格来展示用户列表数据，可以使用分页组件完成列表分页展示数据(复制分页组件代码，在element.js中导入组件Pagination)<br>B.更改组件中的绑定数据</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">&lt;!-- 分页导航区域 </span><br><span class="line"><span class="variable">@size</span>-change(pagesize改变时触发) </span><br><span class="line"><span class="variable">@current</span>-change(页码发生改变时触发)</span><br><span class="line"><span class="symbol">:current-page</span>(设置当前页码)</span><br><span class="line"><span class="symbol">:page-size</span>(设置每页的数据条数)</span><br><span class="line"><span class="symbol">:total</span>(设置总页数) --&gt;</span><br><span class="line">            &lt;el-pagination <span class="variable">@size</span>-change=<span class="string">"handleSizeChange"</span> <span class="variable">@current</span>-change=<span class="string">"handleCurrentChange"</span> <span class="symbol">:current-page=<span class="string">"queryInfo.pagenum"</span></span> <span class="symbol">:page-sizes=<span class="string">"[1, 2, 5, 10]"</span></span> <span class="symbol">:page-size=<span class="string">"queryInfo.pagesize"</span></span> layout=<span class="string">"total, sizes, prev, pager, next, jumper"</span> <span class="symbol">:total=<span class="string">"total"</span>&gt;</span></span><br><span class="line">            &lt;<span class="regexp">/el-pagination&gt;</span></span><br></pre></td></tr></table></figure>
<p>C.添加两个事件的事件处理函数@size-change，@current-change</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">handleSizeChange(<span class="keyword">new</span><span class="type">Size</span>) &#123;</span><br><span class="line">  <span class="comment">//pagesize改变时触发，当pagesize发生改变的时候，我们应该</span></span><br><span class="line">  <span class="comment">//以最新的pagesize来请求数据并展示数据</span></span><br><span class="line">  <span class="comment">//   console.log(newSize)</span></span><br><span class="line">  <span class="built_in">this</span>.queryInfo.pagesize = <span class="keyword">new</span><span class="type">Size</span>;</span><br><span class="line">  <span class="comment">//重新按照pagesize发送请求，请求最新的数据</span></span><br><span class="line">  <span class="built_in">this</span>.getUserList();  </span><br><span class="line">&#125;,</span><br><span class="line">handleCurrentChange( current ) &#123;</span><br><span class="line">  <span class="comment">//页码发生改变时触发当current发生改变的时候，我们应该</span></span><br><span class="line">  <span class="comment">//以最新的current页码来请求数据并展示数据</span></span><br><span class="line">  <span class="comment">//   console.log(current)</span></span><br><span class="line">  <span class="built_in">this</span>.queryInfo.pagenum = current;</span><br><span class="line">  <span class="comment">//重新按照pagenum发送请求，请求最新的数据</span></span><br><span class="line">  <span class="built_in">this</span>.getUserList();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-实现更新用户状态"><a href="#13-实现更新用户状态" class="headerlink" title="13.实现更新用户状态"></a>13.实现更新用户状态</h3><p>当用户点击列表中的switch组件时，用户的状态应该跟随发生改变。<br>A.首先监听用户点击switch组件的事件，并将作用域插槽的数据当做事件参数进行传递</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">&lt;el-<span class="keyword">switch</span> v-model=<span class="string">"scope.row.mg_state"</span> <span class="symbol">@change</span>=<span class="string">"userStateChanged(scope.row)"</span>&gt;&lt;/el-<span class="keyword">switch</span>&gt;</span><br></pre></td></tr></table></figure>


<p>B.在事件中发送请求完成状态的更改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> userStateChanged(row) &#123;</span><br><span class="line">  <span class="comment">//发送请求进行状态修改</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.put(</span><br><span class="line">    <span class="string">`users/<span class="subst">$&#123;row.id&#125;</span>/state/<span class="subst">$&#123;row.mg_state&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">//如果返回状态为异常状态则报错并返回</span></span><br><span class="line">  <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    row.mg_state = !row.mg_state</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'修改状态失败'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$message.success(<span class="string">'更新状态成功'</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="14-实现搜索功能"><a href="#14-实现搜索功能" class="headerlink" title="14.实现搜索功能"></a>14.实现搜索功能</h3><p>添加数据绑定，添加搜索按钮的点击事件(当用户点击搜索按钮的时候，调用getUserList方法根据文本框内容重新请求用户列表数据)<br>当我们在输入框中输入内容并点击搜索之后，会按照搜索关键字搜索，我们希望能够提供一个X删除搜索关键字并重新获取所有的用户列表数据，只需要给文本框添加clearable属性并添加clear事件，在clear事件中重新请求数据即可</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">el</span>-<span class="keyword">col</span> :span=<span class="string">"7"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">el</span>-<span class="built_in">input</span> placeholder=<span class="string">"请输入内容"</span> v-model=<span class="string">"queryInfo.query"</span> clearable @clear=<span class="string">"getUserList"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">el</span>-button slot=<span class="string">"append"</span> icon=<span class="string">"el-icon-search"</span> @click=<span class="string">"getUserList"</span>&gt;&lt;/<span class="keyword">el</span>-button&gt;</span><br><span class="line">    &lt;/<span class="keyword">el</span>-<span class="built_in">input</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">el</span>-<span class="keyword">col</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="15-实现添加用户"><a href="#15-实现添加用户" class="headerlink" title="15.实现添加用户"></a>15.实现添加用户</h3><p>A.当我们点击添加用户按钮的时候，弹出一个对话框来实现添加用户的功能，首先我们需要复制对话框组件的代码并在element.js文件中引入Dialog组件</p>
<p>B.接下来我们要为“添加用户”按钮添加点击事件，在事件中将addDialogVisible设置为true，即显示对话框</p>
<p>C.更改Dialog组件中的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对话框组件  :visible.sync(设置是否显示对话框) width(设置对话框的宽度)</span></span><br><span class="line"><span class="comment">:before-close(在对话框关闭前触发的事件) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">"添加用户"</span> <span class="attr">:visible.sync</span>=<span class="string">"addDialogVisible"</span> <span class="attr">width</span>=<span class="string">"50%"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对话框主体区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"addForm"</span> <span class="attr">:rules</span>=<span class="string">"addFormRules"</span> <span class="attr">ref</span>=<span class="string">"addFormRef"</span> <span class="attr">label-width</span>=<span class="string">"70px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"用户名"</span> <span class="attr">prop</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.username"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"密码"</span> <span class="attr">prop</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.password"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"邮箱"</span> <span class="attr">prop</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.email"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"电话"</span> <span class="attr">prop</span>=<span class="string">"mobile"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addForm.mobile"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对话框底部区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"dialog-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"addDialogVisible = false"</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"addDialogVisible = false"</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>D.添加数据绑定和校验规则：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="comment">//验证邮箱的规则</span></span><br><span class="line">  var checkEmail = (rule, value, cb) =&gt; &#123;</span><br><span class="line">    const regEmail = <span class="regexp">/^\w+@\w+(\.\w+)+$/</span></span><br><span class="line">    <span class="keyword">if</span> (regEmail.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个错误提示</span></span><br><span class="line">    cb(<span class="keyword">new</span> Error(<span class="string">'请输入合法的邮箱'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//验证手机号码的规则</span></span><br><span class="line">  var checkMobile = (rule, value, cb) =&gt; &#123;</span><br><span class="line">    const regMobile = <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span></span><br><span class="line">    <span class="keyword">if</span> (regMobile.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个错误提示</span></span><br><span class="line">    cb(<span class="keyword">new</span> Error(<span class="string">'请输入合法的手机号码'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//获取查询用户信息的参数</span></span><br><span class="line"><span class="symbol">    queryInfo:</span> &#123;</span><br><span class="line">      <span class="comment">// 查询的条件</span></span><br><span class="line"><span class="symbol">      query:</span> <span class="string">''</span>,</span><br><span class="line">      <span class="comment">// 当前的页数，即页码</span></span><br><span class="line"><span class="symbol">      pagenum:</span> <span class="number">1</span>,</span><br><span class="line">      <span class="comment">// 每页显示的数据条数</span></span><br><span class="line"><span class="symbol">      pagesize:</span> <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//保存请求回来的用户列表数据</span></span><br><span class="line"><span class="symbol">    userList:</span> [],</span><br><span class="line"><span class="symbol">    total:</span> <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//是否显示添加用户弹出窗</span></span><br><span class="line"><span class="symbol">    addDialogVisible:</span> <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 添加用户的表单数据</span></span><br><span class="line"><span class="symbol">    addForm:</span> &#123;</span><br><span class="line"><span class="symbol">      username:</span> <span class="string">''</span>,</span><br><span class="line"><span class="symbol">      password:</span> <span class="string">''</span>,</span><br><span class="line"><span class="symbol">      email:</span> <span class="string">''</span>,</span><br><span class="line"><span class="symbol">      mobile:</span> <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 添加表单的验证规则对象</span></span><br><span class="line"><span class="symbol">    addFormRules:</span> &#123;</span><br><span class="line"><span class="symbol">      username:</span> [</span><br><span class="line">        &#123; <span class="string">required:</span> <span class="literal">true</span>, <span class="string">message:</span> <span class="string">'请输入用户名称'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          min:</span> <span class="number">3</span>,</span><br><span class="line"><span class="symbol">          max:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">          message:</span> <span class="string">'用户名在3~10个字符之间'</span>,</span><br><span class="line"><span class="symbol">          trigger:</span> <span class="string">'blur'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line"><span class="symbol">      password:</span> [</span><br><span class="line">        &#123; <span class="string">required:</span> <span class="literal">true</span>, <span class="string">message:</span> <span class="string">'请输入密码'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          min:</span> <span class="number">6</span>,</span><br><span class="line"><span class="symbol">          max:</span> <span class="number">15</span>,</span><br><span class="line"><span class="symbol">          message:</span> <span class="string">'用户名在6~15个字符之间'</span>,</span><br><span class="line"><span class="symbol">          trigger:</span> <span class="string">'blur'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line"><span class="symbol">      email:</span> [</span><br><span class="line">          &#123; <span class="string">required:</span> <span class="literal">true</span>, <span class="string">message:</span> <span class="string">'请输入邮箱'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span> &#125;,</span><br><span class="line">          &#123; <span class="string">validator:</span>checkEmail, <span class="string">message:</span> <span class="string">'邮箱格式不正确，请重新输入'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span>&#125;</span><br><span class="line">      ],</span><br><span class="line"><span class="symbol">      mobile:</span> [</span><br><span class="line">          &#123; <span class="string">required:</span> <span class="literal">true</span>, <span class="string">message:</span> <span class="string">'请输入手机号码'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span> &#125;,</span><br><span class="line">          &#123; <span class="string">validator:</span>checkMobile, <span class="string">message:</span> <span class="string">'手机号码不正确，请重新输入'</span>, <span class="string">trigger:</span> <span class="string">'blur'</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E.当关闭对话框时，重置表单<br>给el-dialog添加@close事件，在事件中添加重置表单的代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ....</span><br><span class="line">  addDialogClosed()&#123;</span><br><span class="line">      <span class="comment">//对话框关闭之后，重置表达</span></span><br><span class="line">      <span class="keyword">this</span>.$<span class="built_in">ref</span>s.addFormRef.resetFields();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F.点击对话框中的确定按钮，发送请求完成添加用户的操作<br>首先给确定按钮添加点击事件，在点击事件中完成业务逻辑代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ....</span><br><span class="line">  addUser()&#123;</span><br><span class="line">      <span class="comment">//点击确定按钮，添加新用户</span></span><br><span class="line">      <span class="comment">//调用validate进行表单验证</span></span><br><span class="line">      <span class="keyword">this</span>.$refs.addFormRef.validate( async valid =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span>(!valid) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">"请填写完整用户信息"</span>);</span><br><span class="line">          <span class="comment">//发送请求完成添加用户的操作</span></span><br><span class="line">          <span class="keyword">const</span> &#123;<span class="keyword">data</span>:res&#125; = await <span class="keyword">this</span>.$http.post(<span class="string">"users"</span>,<span class="keyword">this</span>.addForm)</span><br><span class="line">          <span class="comment">//判断如果添加失败，就做提示</span></span><br><span class="line">          <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'添加用户失败'</span>)</span><br><span class="line">          <span class="comment">//添加成功的提示</span></span><br><span class="line">          <span class="keyword">this</span>.$message.success(<span class="string">"添加用户成功"</span>)</span><br><span class="line">          <span class="comment">//关闭对话框</span></span><br><span class="line">          <span class="keyword">this</span>.addDialogVisible = <span class="literal">false</span></span><br><span class="line">          <span class="comment">//重新请求最新的数据</span></span><br><span class="line">          <span class="keyword">this</span>.getUserList()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/02/09/vue3-05/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.初始化项目<br>2.基于Vue技术栈进行项目开发<br>3.使用Vue的第三方组件进行项目开发<br>4.理解前后端分离开发模式</p>
<a id="more"></a>
<h3 id="1-电商业务概述"><a href="#1-电商业务概述" class="headerlink" title="1.电商业务概述"></a>1.电商业务概述</h3><p>客户使用的业务服务：PC端，小程序，移动web，移动app<br>管理员使用的业务服务：PC后台管理端。<br>PC后台管理端的功能：管理用户账号（登录，退出，用户管理，权限管理），商品管理（商品分类，分类参数，商品信息，订单），数据统计<br>电商后台管理系统采用前后端分离的开发模式<br>前端项目是基于Vue的SPA（单页应用程序）项目</p>
<p>前端技术栈:Vue,Vue-Router,Element-UI,Axios,Echarts<br>后端技术栈：Node.js,Express,Jwt(模拟session),Mysql,Sequelize(操作数据库的框架)</p>
<h3 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2.项目初始化"></a>2.项目初始化</h3><p>A.安装Vue脚手架<br>B.通过脚手架创建项目<br>C.配置路由<br>D.配置Element-UI:在插件中安装，搜索vue-cli-plugin-element<br>E.配置Axios：在依赖中安装,搜索axios(运行依赖)<br>F.初始化git仓库<br>G.将本地项目托管到github或者码云中</p>
<h3 id="3-码云相关操作"><a href="#3-码云相关操作" class="headerlink" title="3.码云相关操作"></a>3.码云相关操作</h3><p>A.注册登录码云账号<br><img src="http://q70bd5y95.bkt.clouddn.com/%E6%B3%A8%E5%86%8C%E7%A0%81%E4%BA%91.jpg" alt=""></p>
<p>B.安装git<br>    在Windows上使用Git，可以从Git官网直接下载安装程序进行安装。<br>    测试命令：git –version</p>
<p>C.点击网站右上角“登录”，登录码云，并进行账号设置<br><img src="http://q70bd5y95.bkt.clouddn.com/%E7%A0%81%E4%BA%91%E7%82%B9%E5%87%BB%E8%AE%BE%E7%BD%AE.jpg" alt=""></p>
<p>D.在本地创建公钥：在终端运行：ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com">xxx@xxx.com</a>“<br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E5%85%AC%E9%92%A5.jpg" alt=""><br>E.找到公钥地址：<br>Your identification has been saved in /c/Users/My/.ssh/id_rsa.<br>Your public key has been saved in /c/Users/My/.ssh/id_rsa.pub.<br>当我们创建公钥完毕之后，请注意打印出来的信息“Your public key has been saved in”<br>/c/Users/My/.ssh/id_rsa.pub : c盘下面的Users下面的My下面的.ssh下面的id_rsa.pub就是我们创建好的公钥了</p>
<p>E.打开id_rsa.pub文件，复制文件中的所有代码，点击码云中的SSH公钥，将生成的公钥复制到公钥中<br><img src="http://q70bd5y95.bkt.clouddn.com/pub%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/ssh%E5%85%AC%E9%92%A5.jpg" alt=""><br>G.测试公钥：打开终端，输入命令<br>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a><br><img src="http://q70bd5y95.bkt.clouddn.com/success.jpg" alt=""></p>
<p>H.将本地代码托管到码云中<br>点击码云右上角的+号-&gt;新建仓库<br><img src="http://q70bd5y95.bkt.clouddn.com/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.jpg" alt=""><br><img src="http://q70bd5y95.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%932.jpg" alt=""></p>
<p>I.进行git配置：<br><img src="http://q70bd5y95.bkt.clouddn.com/config.jpg" alt=""><br>打开项目所在位置的终端，进行git仓库关联<br><img src="http://q70bd5y95.bkt.clouddn.com/%E9%A1%B9%E7%9B%AE%E7%BB%88%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%85%B3%E8%81%94.jpg" alt=""></p>
<h3 id="4-配置后台项目"><a href="#4-配置后台项目" class="headerlink" title="4.配置后台项目"></a>4.配置后台项目</h3><p>A.安装phpStudy并导入mysql数据库数据<br><img src="http://q70bd5y95.bkt.clouddn.com/phpStudy.jpg" alt=""></p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/mysql.jpg" alt=""><br>B.安装nodeJS，配置后台项目,从终端打开后台项目vue_api_server<br>然后在终端中输入命令安装项目依赖包：npm install</p>
<p>C.使用postman测试api接口<br><img src="http://q70bd5y95.bkt.clouddn.com/postman.jpg" alt=""></p>
<h3 id="5-实现登录功能"><a href="#5-实现登录功能" class="headerlink" title="5.实现登录功能"></a>5.实现登录功能</h3><p>A.登录状态保持<br>如果服务器和客户端同源，建议可以使用cookie或者session来保持登录状态<br>如果客户端和服务器跨域了，建议使用token进行维持登录状态。</p>
<p>B.登录逻辑：<br>在登录页面输入账号和密码进行登录，将数据发送给服务器<br>服务器返回登录的结果，登录成功则返回数据中带有token<br>客户端得到token并进行保存，后续的请求都需要将此token发送给服务器，服务器会验证token以保证用户身份。</p>
<p>C.添加新分支login，在login分支中开发当前项目vue_shop：<br>打开vue_shop终端，使用git status确定当前项目状态。<br>确定当前工作目录是干净的之后，创建一个分支进行开发，开发完毕之后将其合并到master<br>git checkout -b login<br>然后查看新创建的分支：git branch<br>确定我们正在使用login分支进行开发<br><img src="http://q70bd5y95.bkt.clouddn.com/branch.jpg" alt=""></p>
<p>然后执行vue ui命令打开ui界面，然后运行serve，运行app查看当前项目效果<br><img src="http://q70bd5y95.bkt.clouddn.com/ui%E7%95%8C%E9%9D%A2%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE.jpg" alt=""></p>
<p>发现现在是一个默认页面，我们需要进行更改，打开项目的src目录，点击main.js文件（入口文件）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./plugins/element.js'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>再打开App.vue(根组件)，将根组件的内容进行操作梳理(template中留下根节点，script中留下默认导出，去掉组件，style中去掉所有样式)</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery"> <span class="built_in"> name</span>: <span class="string">'app'</span></span></span><br><span class="line"><span class="xquery">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>再打开router.js(路由)，将routes数组中的路由规则清除，然后将views删除，将components中的helloworld.vue删除</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">import Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在components文件夹中新建Login.vue组件,添加template，script，style标签,style标签中的scoped可以防止组件之间的样式冲突，没有scoped则样式是全局的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login_container"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.login_container</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-id">#2b5b6b</span>;</span></span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在router.js中导入组件并设置规则<br>在App.vue中添加路由占位符</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/'</span>, <span class="string">redirect:</span> <span class="string">'/login'</span> &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> Login &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们给Login.vue中的内容添加样式的时候，会报错“缺少less-loader”，需要配置less加载器（开发依赖），安装less(开发依赖)<br><img src="http://q70bd5y95.bkt.clouddn.com/less.jpg" alt=""><br>然后需要添加公共样式，在assets文件夹下面添加css文件夹，创建global.css文件,添加全局样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局样式表 */</span></span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-id">#app</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main.js中导入global.css，使得全局样式生效 import “./assets/css/global.css”<br>然后Login.vue中的根元素也需要设置撑满全屏（height:100%）<br>最终Login.vue文件中的代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login_container"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 登录盒子  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login_box"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 头像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"avatar_box"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../assets/logo.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"loginForm"</span> <span class="attr">ref</span>=<span class="string">"LoginFormRef"</span> <span class="attr">:rules</span>=<span class="string">"loginFormRules"</span> <span class="attr">label-width</span>=<span class="string">"0px"</span> <span class="attr">class</span>=<span class="string">"login_form"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"loginForm.username"</span> <span class="attr">prefix-icon</span>=<span class="string">"iconfont icon-user"</span> &gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">v-model</span>=<span class="string">"loginForm.password"</span> <span class="attr">prefix-icon</span>=<span class="string">"iconfont icon-3702mima"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">class</span>=<span class="string">"btns"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"info"</span> @<span class="attr">click</span>=<span class="string">"resetLoginForm"</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//数据绑定</span></span></span><br><span class="line">      loginForm: &#123;</span><br><span class="line"><span class="actionscript">        username: <span class="string">'admin'</span>,</span></span><br><span class="line"><span class="actionscript">        password: <span class="string">'123456'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      <span class="comment">//表单验证规则</span></span></span><br><span class="line">      loginFormRules: &#123;</span><br><span class="line">        username: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入登录名'</span>, trigger: <span class="string">'blur'</span> &#125;,</span></span><br><span class="line">          &#123;</span><br><span class="line">            min: 3,</span><br><span class="line">            max: 10,</span><br><span class="line"><span class="actionscript">            message: <span class="string">'登录名长度在 3 到 10 个字符'</span>,</span></span><br><span class="line"><span class="actionscript">            trigger: <span class="string">'blur'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        password: [</span><br><span class="line"><span class="actionscript">          &#123; required: <span class="literal">true</span>, message: <span class="string">'请输入密码'</span>, trigger: <span class="string">'blur'</span> &#125;,</span></span><br><span class="line">          &#123;</span><br><span class="line">            min: 6,</span><br><span class="line">            max: 15,</span><br><span class="line"><span class="actionscript">            message: <span class="string">'密码长度在 6 到 15 个字符'</span>,</span></span><br><span class="line"><span class="actionscript">            trigger: <span class="string">'blur'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  <span class="comment">//添加行为，</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">//添加表单重置方法</span></span></span><br><span class="line">    resetLoginForm() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//this=&gt;当前组件对象，其中的属性$refs包含了设置的表单ref</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//   console.log(this)</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$refs.LoginFormRef.resetFields()</span></span><br><span class="line">    &#125;,</span><br><span class="line">    login() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//点击登录的时候先调用validate方法验证表单内容是否有误</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$refs.LoginFormRef.validate(<span class="keyword">async</span> valid =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.loginFormRules)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//如果valid参数为true则验证通过</span></span></span><br><span class="line">        if (!valid) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//发送请求进行登录</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>, <span class="keyword">this</span>.loginForm)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//   console.log(res);</span></span></span><br><span class="line">        if (res.meta.status !== 200) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'登录失败:'</span> + res.meta.msg) <span class="comment">//console.log("登录失败:"+res.meta.msg)</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$message.success(<span class="string">'登录成功'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//保存token</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>, res.data.token)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 导航至/home</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.login_container</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-id">#2b5b6b</span>;</span></span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.login_box</span> &#123;</span></span><br><span class="line">  width: 450px;</span><br><span class="line">  height: 300px;</span><br><span class="line"><span class="css">  <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line"><span class="css">  <span class="selector-class">.avatar_box</span> &#123;</span></span><br><span class="line">    height: 130px;</span><br><span class="line">    width: 130px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#eee</span>;</span></span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    padding: 10px;</span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    img &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line"><span class="css">      <span class="selector-tag">background-color</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.login_form</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.btns</span> &#123;</span></span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中我们有用到一下内容，需要进行进一步处理：</p>
<p>A.添加element-ui的表单组件<br>在plugins文件夹中打开element.js文件，进行elementui的按需导入<br>import Vue from ‘vue’<br>import { Button } from ‘element-ui’<br>import { Form, FormItem } from ‘element-ui’<br>import { Input } from ‘element-ui’</p>
<p>Vue.use(Button)<br>Vue.use(Form)<br>Vue.use(FormItem)<br>Vue.use(Input)</p>
<p>B.添加第三方字体<br>复制素材中的fonts文件夹到assets中,在入口文件main.js中导入import ‘./assets/fonts/iconfont.css’<br>然后直接在 <el-input prefix-icon="iconfont icon-3702mima"></el-input><br>接着添加登录盒子</p>
<p>C.添加表单验证的步骤<br>1).给<el-form>添加属性:rules=”rules”，rules是一堆验证规则，定义在script、中<br>2).在script中添加rules：export default{ data(){return{……, rules: {<br>          name: [<br>            { required: true, message: ‘请输入活动名称’, trigger: ‘blur’ },<br>            { min: 3, max: 5, message: ‘长度在 3 到 5 个字符’, trigger: ‘blur’ }<br>          ],<br>          region: [<br>            { required: true, message: ‘请选择活动区域’, trigger: ‘change’ }<br>          ]<br>}……<br>3).通过<el-form-item>的prop属性设置验证规则<el-form-item label="活动名称" prop="name"></p>
<p>4.导入axios以发送ajax请求<br>打开main.js，import axios from ‘axios’;<br>设置请求的根路径：axios.defaults.baseURL = ‘<a href="http://127.0.0.1:8888/api/private/v1/&#39;" target="_blank" rel="noopener">http://127.0.0.1:8888/api/private/v1/&#39;</a>;<br>挂载axios：Vue.prototype.$http = axios;</p>
<p>5.配置弹窗提示：<br>在plugins文件夹中打开element.js文件，进行elementui的按需导入<br>import {Message} from ‘element-ui’<br>进行全局挂载：Vue.prototype.$message = Message;<br>在login.vue组件中编写弹窗代码：this.$message.error(‘登录失败’)</p>
<h3 id="6-登录成功之后的操作"><a href="#6-登录成功之后的操作" class="headerlink" title="6.登录成功之后的操作"></a>6.登录成功之后的操作</h3><p>A.登录成功之后，需要将后台返回的token保存到sessionStorage中<br>操作完毕之后，需要跳转到/home</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">      <span class="comment">//点击登录的时候先调用validate方法验证表单内容是否有误</span></span><br><span class="line">      <span class="keyword">this</span>.$refs.LoginFormRef.validate(async valid =&gt; &#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.loginFormRules)</span><br><span class="line">        <span class="comment">//如果valid参数为true则验证通过</span></span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送请求进行登录</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="keyword">data</span>: res &#125; = await <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>, <span class="keyword">this</span>.loginForm)</span><br><span class="line">        <span class="comment">//   console.log(res);</span></span><br><span class="line">        <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'登录失败:'</span> + res.meta.msg) <span class="comment">//console.log("登录失败:"+res.meta.msg)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.$message.success(<span class="string">'登录成功'</span>)</span><br><span class="line">        console.log(res)</span><br><span class="line">        <span class="comment">//保存token</span></span><br><span class="line">        window.sessionStorage.setItem(<span class="string">'token'</span>, res.<span class="keyword">data</span>.token)</span><br><span class="line">        <span class="comment">// 导航至/home</span></span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>添加一个组件Home.vue，并为之添加规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        this is home</span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"info"</span> @<span class="attr">click</span>=<span class="string">"logout"</span>&gt;</span> 退出 <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.sessionStorage.clear()</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">'less'</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line"><span class="symbol">  routes:</span> [</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/'</span>, <span class="string">redirect:</span> <span class="string">'/login'</span> &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/login'</span>, <span class="string">component:</span> Login &#125;,</span><br><span class="line">    &#123; <span class="string">path:</span> <span class="string">'/home'</span>, <span class="string">component:</span> Home &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>添加路由守卫<br>如果用户没有登录，不能访问/home,如果用户通过url地址直接访问，则强制跳转到登录页面<br>打开router.js</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">Login</span> <span class="keyword">from</span> <span class="string">'./components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router = <span class="built_in">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="type">path</span>:<span class="string">'/'</span>, redirect:<span class="string">'/login'</span>&#125;,</span><br><span class="line">    &#123; <span class="type">path</span>:<span class="string">'/login'</span> , component:<span class="keyword">Login</span> &#125;,</span><br><span class="line">    &#123; <span class="type">path</span>:<span class="string">'/home'</span> , component:Home&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//挂载路由导航守卫,<span class="keyword">to</span>表示将要访问的路径，<span class="keyword">from</span>表示从哪里来，next是下一个要做的操作</span><br><span class="line">router.beforeEach((<span class="keyword">to</span>,<span class="keyword">from</span>,next)=&gt;&#123; </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">to</span>.path === <span class="string">'/login'</span>)</span><br><span class="line">    <span class="keyword">return next</span>();</span><br><span class="line">  </span><br><span class="line">  //获取token</span><br><span class="line">  const tokenStr = <span class="keyword">window</span>.sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!tokenStr)</span><br><span class="line">    <span class="keyword">return next</span>(<span class="string">'/login'</span>);</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>实现退出功能<br>在Home组件中添加一个退出功能按钮,给退出按钮添加点击事件，添加事件处理代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        logout()&#123;</span><br><span class="line">            window.sessionStorage.clear();</span><br><span class="line">            this.<span class="variable">$router</span>.push(<span class="string">'/login'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>A.处理ESLint警告<br>打开脚手架面板，查看警告信息<br>[图片]<br>默认情况下，ESLint和vscode格式化工具有冲突，需要添加配置文件解决冲突。<br>在项目根目录添加 .prettierrc 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"semi"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"singleQuote"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开.eslintrc.js文件，禁用对 space-before-function-paren 的检查:</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  <span class="symbol">'no</span>-console': process.env.<span class="type">NODE_ENV</span> === <span class="symbol">'production'</span> ? <span class="symbol">'error'</span> : <span class="symbol">'off'</span>,</span><br><span class="line">  <span class="symbol">'no</span>-debugger': process.env.<span class="type">NODE_ENV</span> === <span class="symbol">'production'</span> ? <span class="symbol">'error'</span> : <span class="symbol">'off'</span>,</span><br><span class="line">  <span class="symbol">'space</span>-before-function-paren' : <span class="number">0</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>B.合并按需导入的element-ui</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import Vue from 'vue'</span><br><span class="line">import &#123; Button, Form, FormItem, Input, Message &#125; from 'element-ui'</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(Button)</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(Form)</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(FormItem)</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(Input)</span><br><span class="line"><span class="comment">// 进行全局挂载：</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>prototype.$message = Message</span><br></pre></td></tr></table></figure>

<p>C.将代码提交到码云<br>新建一个项目终端,输入命令‘git status’查看修改过的与新增的文件内容<br>将所有文件添加到暂存区：git add .<br>将所有代码提交到本地仓库：git commit -m “添加登录功能以及/home的基本结构”<br>查看分支： git branch  发现所有代码都被提交到了login分支<br>将login分支代码合并到master主分支，先切换到master：git checkout master<br>在master分支进行代码合并：git merge login<br>将本地的master推送到远端的码云：git push</p>
<p>推送本地的子分支到码云，先切换到子分支：git checkout 分支名<br>然后推送到码云：git push -u origin 远端分支名</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/02/07/vue3-04/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.能够了解模块化的相关规范<br>2.了解webpack<br>3.了解使用Vue单文件组件<br>4.能够搭建Vue脚手架<br>5.掌握Element-UI的使用 </p>
<a id="more"></a>

<h3 id="1-模块化的分类"><a href="#1-模块化的分类" class="headerlink" title="1.模块化的分类"></a>1.模块化的分类</h3><h4 id="A-浏览器端的模块化"><a href="#A-浏览器端的模块化" class="headerlink" title="A.浏览器端的模块化"></a>A.浏览器端的模块化</h4><pre><code>1).AMD(Asynchronous Module Definition,异步模块定义)
代表产品为：Require.js
2).CMD(Common Module Definition,通用模块定义)
代表产品为：Sea.js</code></pre><h4 id="B-服务器端的模块化"><a href="#B-服务器端的模块化" class="headerlink" title="B.服务器端的模块化"></a>B.服务器端的模块化</h4><pre><code>服务器端的模块化规范是使用CommonJS规范：
1).使用require引入其他模块或者包
2).使用exports或者module.exports导出模块成员
3).一个文件就是一个模块，都拥有独立的作用域</code></pre><h4 id="C-ES6模块化"><a href="#C-ES6模块化" class="headerlink" title="C.ES6模块化"></a>C.ES6模块化</h4><pre><code>ES6模块化规范中定义：
    1).每一个js文件都是独立的模块
    2).导入模块成员使用import关键字
    3).暴露模块成员使用export关键字</code></pre><p>小结：推荐使用ES6模块化，因为AMD，CMD局限使用与浏览器端，而CommonJS在服务器端使用。<br>      ES6模块化是浏览器端和服务器端通用的规范.</p>
<h3 id="2-在NodeJS中安装babel"><a href="#2-在NodeJS中安装babel" class="headerlink" title="2.在NodeJS中安装babel"></a>2.在NodeJS中安装babel</h3><h4 id="A-安装babel"><a href="#A-安装babel" class="headerlink" title="A.安装babel"></a>A.安装babel</h4><pre><code>打开终端，输入命令：npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
安装完毕之后，再次输入命令安装：npm install --save @babel/polyfill</code></pre><h4 id="B-创建babel-config-js"><a href="#B-创建babel-config-js" class="headerlink" title="B.创建babel.config.js"></a>B.创建babel.config.js</h4><pre><code>在项目目录中创建babel.config.js文件。
编辑js文件中的代码如下：
    const presets = [
        [&quot;@babel/env&quot;,{
            targets:{
                edge:&quot;17&quot;,
                firefox:&quot;60&quot;,
                chrome:&quot;67&quot;,
                safari:&quot;11.1&quot;
            }
        }]
    ]
    //暴露
    module.exports = { presets }</code></pre><h4 id="C-创建index-js文件"><a href="#C-创建index-js文件" class="headerlink" title="C.创建index.js文件"></a>C.创建index.js文件</h4><pre><code>在项目目录中创建index.js文件作为入口文件
在index.js中输入需要执行的js代码，例如：
    console.log(&quot;ok&quot;);</code></pre><h4 id="D-使用npx执行文件"><a href="#D-使用npx执行文件" class="headerlink" title="D.使用npx执行文件"></a>D.使用npx执行文件</h4><pre><code>打开终端，输入命令：npx babel-node ./index.js</code></pre><h3 id="3-设置默认导入-导出"><a href="#3-设置默认导入-导出" class="headerlink" title="3.设置默认导入/导出"></a>3.设置默认导入/导出</h3><h4 id="A-默认导出"><a href="#A-默认导出" class="headerlink" title="A.默认导出"></a>A.默认导出</h4><pre><code>export default {
    成员A,
    成员B,
    .......
},如下：
let num = 100;
export default{
    num
}</code></pre><h4 id="B-默认导入"><a href="#B-默认导入" class="headerlink" title="B.默认导入"></a>B.默认导入</h4><pre><code>import 接收名称 from &quot;模块标识符&quot;，如下：
import test from &quot;./test.js&quot;</code></pre><p>注意：在一个模块中，只允许使用export default向外默认暴露一次成员，千万不要写多个export default。<br>如果在一个模块中没有向外暴露成员，其他模块引入该模块时将会得到一个空对象 </p>
<h3 id="4-设置按需导入-导出"><a href="#4-设置按需导入-导出" class="headerlink" title="4.设置按需导入/导出"></a>4.设置按需导入/导出</h3><h4 id="A-按需导出"><a href="#A-按需导出" class="headerlink" title="A.按需导出"></a>A.按需导出</h4><pre><code>export let num = 998;
export let myName = &quot;jack&quot;;
export function fn = function(){ console.log(&quot;fn&quot;) }</code></pre><h4 id="B-按需导入"><a href="#B-按需导入" class="headerlink" title="B.按需导入"></a>B.按需导入</h4><pre><code>import { num,fn as printFn ,myName } from &quot;./test.js&quot;
//同时导入默认导出的成员以及按需导入的成员
import test,{ num,fn as printFn ,myName } from &quot;./test.js&quot;</code></pre><p>注意：一个模块中既可以按需导入也可以默认导入，一个模块中既可以按需导出也可以默认导出</p>
<h3 id="5-直接导入并执行代码"><a href="#5-直接导入并执行代码" class="headerlink" title="5.直接导入并执行代码"></a>5.直接导入并执行代码</h3><pre><code>import &quot;./test2.js&quot;;</code></pre><h3 id="6-webpack的概念"><a href="#6-webpack的概念" class="headerlink" title="6.webpack的概念"></a>6.webpack的概念</h3><p>webpack是一个流行的前端项目构建工具，可以解决目前web开发的困境。<br>webpack提供了模块化支持，代码压缩混淆，解决js兼容问题，性能优化等特性，提高了开发效率和项目的可维护性</p>
<h3 id="7-webpack的基本使用"><a href="#7-webpack的基本使用" class="headerlink" title="7.webpack的基本使用"></a>7.webpack的基本使用</h3><h4 id="A-创建项目目录并初始化"><a href="#A-创建项目目录并初始化" class="headerlink" title="A.创建项目目录并初始化"></a>A.创建项目目录并初始化</h4><pre><code>创建项目，并打开项目所在目录的终端，输入命令：
    npm init -y</code></pre><h4 id="B-创建首页及js文件"><a href="#B-创建首页及js文件" class="headerlink" title="B.创建首页及js文件"></a>B.创建首页及js文件</h4><pre><code>在项目目录中创建index.html页面，并初始化页面结构：在页面中摆放一个ul，ul里面放置几个li
在项目目录中创建js文件夹，并在文件夹中创建index.js文件</code></pre><h4 id="C-安装jQuery"><a href="#C-安装jQuery" class="headerlink" title="C.安装jQuery"></a>C.安装jQuery</h4><pre><code>打开项目目录终端，输入命令:
npm install jQuery -S</code></pre><h4 id="D-导入jQuery"><a href="#D-导入jQuery" class="headerlink" title="D.导入jQuery"></a>D.导入jQuery</h4><pre><code>打开index.js文件，编写代码导入jQuery并实现功能：
import $ from &quot;jquery&quot;;
$(function(){
    $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;cyan&quot;);
    $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;pink&quot;);
})</code></pre><p>注意：此时项目运行会有错误，因为import $ from “jquery”;这句代码属于ES6的新语法代码，在浏览器中可能会存在兼容性问题<br>所以我们需要webpack来帮助我们解决这个问题。</p>
<h4 id="E-安装webpack"><a href="#E-安装webpack" class="headerlink" title="E.安装webpack"></a>E.安装webpack</h4><pre><code>1).打开项目目录终端，输入命令:
npm install webpack webpack-cli -D
2).然后在项目根目录中，创建一个 webpack.config.js 的配置文件用来配置webpack
在 webpack.config.js 文件中编写代码进行webpack配置，如下：
module.exports = {
    mode:&quot;development&quot;//可以设置为development(开发模式)，production(发布模式)
}
补充：mode设置的是项目的编译模式。
如果设置为development则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些
如果设置为production则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些
3).修改项目中的package.json文件添加运行脚本dev，如下：
&quot;scripts&quot;:{
    &quot;dev&quot;:&quot;webpack&quot;
}
注意：scripts节点下的脚本，可以通过 npm run 运行，如：
运行终端命令：npm run dev
将会启动webpack进行项目打包
4).运行dev命令进行项目打包，并在页面中引入项目打包生成的js文件
打开项目目录终端，输入命令:
npm run dev
等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。
浏览页面查看效果。</code></pre><h3 id="8-设置webpack的打包入口-出口"><a href="#8-设置webpack的打包入口-出口" class="headerlink" title="8.设置webpack的打包入口/出口"></a>8.设置webpack的打包入口/出口</h3><pre><code>在webpack 4.x中，默认会将src/index.js 作为默认的打包入口js文件
                 默认会将dist/main.js 作为默认的打包输出js文件
如果不想使用默认的入口/出口js文件，我们可以通过改变 webpack.config.js 来设置入口/出口的js文件，如下：
const path = require(&quot;path&quot;);
module.exports = {
    mode:&quot;development&quot;,
    //设置入口文件路径
    entry: path.join(__dirname,&quot;./src/xx.js&quot;),
    //设置出口文件
    output:{
        //设置路径
        path:path.join(__dirname,&quot;./dist&quot;),
        //设置文件名
        filename:&quot;res.js&quot;
    }
}</code></pre><h3 id="9-设置webpack的自动打包"><a href="#9-设置webpack的自动打包" class="headerlink" title="9.设置webpack的自动打包"></a>9.设置webpack的自动打包</h3><pre><code>默认情况下，我们更改入口js文件的代码，需要重新运行命令打包webpack，才能生成出口的js文件
那么每次都要重新执行命令打包，这是一个非常繁琐的事情，那么，自动打包可以解决这样繁琐的操作。
实现自动打包功能的步骤如下：
    A.安装自动打包功能的包:webpack-dev-server
        npm install webpack-dev-server -D
    B.修改package.json中的dev指令如下：
        &quot;scripts&quot;:{
            &quot;dev&quot;:&quot;webpack-dev-server&quot;
        }
    C.将引入的js文件路径更改为：&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
    D.运行npm run dev，进行打包
    E.打开网址查看效果：http://localhost:8080

注意：webpack-dev-server自动打包的输出文件，默认放到了服务器的根目录中.</code></pre><p>补充：<br>在自动打包完毕之后，默认打开服务器网页，实现方式就是打开package.json文件，修改dev命令：<br>    “dev”: “webpack-dev-server –open –host 127.0.0.1 –port 9999”</p>
<h3 id="10-配置html-webpack-plugin"><a href="#10-配置html-webpack-plugin" class="headerlink" title="10.配置html-webpack-plugin"></a>10.配置html-webpack-plugin</h3><pre><code>使用html-webpack-plugin 可以生成一个预览页面。
因为当我们访问默认的 http://localhost:8080/的时候，看到的是一些文件和文件夹，想要查看我们的页面
还需要点击文件夹点击文件才能查看，那么我们希望默认就能看到一个页面，而不是看到文件夹或者目录。
实现默认预览页面功能的步骤如下：
    A.安装默认预览功能的包:html-webpack-plugin
        npm install html-webpack-plugin -D
    B.修改webpack.config.js文件，如下：
        //导入包
        const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
        //创建对象
        const htmlPlugin = new HtmlWebpackPlugin({
            //设置生成预览页面的模板文件
            template:&quot;./src/index.html&quot;,
            //设置生成的预览页面名称
            filename:&quot;index.html&quot;
        })
    C.继续修改webpack.config.js文件，添加plugins信息：
        module.exports = {
            ......
            plugins:[ htmlPlugin ]
        }</code></pre><h3 id="11-webpack中的加载器"><a href="#11-webpack中的加载器" class="headerlink" title="11.webpack中的加载器"></a>11.webpack中的加载器</h3><pre><code>通过loader打包非js模块：默认情况下，webpack只能打包js文件，如果想要打包非js文件，需要调用loader加载器才能打包
    loader加载器包含：
        1).less-loader
        2).sass-loader
        3).url-loader:打包处理css中与url路径有关的文件
        4).babel-loader:处理高级js语法的加载器
        5).postcss-loader
        6).css-loader,style-loader

注意：指定多个loader时的顺序是固定的，而调用loader的顺序是从后向前进行调用

A.安装style-loader,css-loader来处理样式文件
    1).安装包
        npm install style-loader css-loader -D
    2).配置规则：更改webpack.config.js的module中的rules数组
    module.exports = {
        ......
        plugins:[ htmlPlugin ],
        module : {
            rules:[
                {
                    //test设置需要匹配的文件类型，支持正则
                    test:/\.css$/,
                    //use表示该文件类型需要调用的loader
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;]
                }
            ]
        }
    }
B.安装less,less-loader处理less文件
    1).安装包
        npm install less-loader less -D
    2).配置规则：更改webpack.config.js的module中的rules数组
    module.exports = {
        ......
        plugins:[ htmlPlugin ],
        module : {
            rules:[
                {
                    //test设置需要匹配的文件类型，支持正则
                    test:/\.css$/,
                    //use表示该文件类型需要调用的loader
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;]
                },
                {
                    test:/\.less$/,
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]
                }
            ]
        }
    }
C.安装sass-loader,node-sass处理less文件
    1).安装包
        npm install sass-loader node-sass -D
    2).配置规则：更改webpack.config.js的module中的rules数组
    module.exports = {
        ......
        plugins:[ htmlPlugin ],
        module : {
            rules:[
                {
                    //test设置需要匹配的文件类型，支持正则
                    test:/\.css$/,
                    //use表示该文件类型需要调用的loader
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;]
                },
                {
                    test:/\.less$/,
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]
                },
                {
                    test:/\.scss$/,
                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]
                }
            ]
        }
    }

    补充：安装sass-loader失败时，大部分情况是因为网络原因，详情参考：
    https://segmentfault.com/a/1190000010984731?utm_source=tag-newest

D.安装post-css自动添加css的兼容性前缀（-ie-,-webkit-）
1).安装包
    npm install postcss-loader autoprefixer -D
2).在项目根目录创建并配置postcss.config.js文件
const autoprefixer = require(&quot;autoprefixer&quot;);
module.exports = {
    plugins:[ autoprefixer ]
}
3).配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
    ......
    plugins:[ htmlPlugin ],
    module : {
        rules:[
            {
                //test设置需要匹配的文件类型，支持正则
                test:/\.css$/,
                //use表示该文件类型需要调用的loader
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;postcss-loader&apos;]
            },
            {
                test:/\.less$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]
            },
            {
                test:/\.scss$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]
            }
        ]
    }
}

E.打包样式表中的图片以及字体文件
在样式表css中有时候会设置背景图片和设置字体文件，一样需要loader进行处理
使用url-loader和file-loader来处理打包图片文件以及字体文件
1).安装包
    npm install url-loader file-loader -D
2).配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
    ......
    plugins:[ htmlPlugin ],
    module : {
        rules:[
            {
                //test设置需要匹配的文件类型，支持正则
                test:/\.css$/,
                //use表示该文件类型需要调用的loader
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;]
            },
            {
                test:/\.less$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]
            },
            {
                test:/\.scss$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]
            },{
                test:/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/,
                //limit用来设置字节数，只有小于limit值的图片，才会转换
                //为base64图片
                use:&quot;url-loader?limit=16940&quot;
            }
        ]
    }
}

F.打包js文件中的高级语法：在编写js的时候，有时候我们会使用高版本的js语法
有可能这些高版本的语法不被兼容，我们需要将之打包为兼容性的js代码
我们需要安装babel系列的包
A.安装babel转换器
    npm install babel-loader @babel/core @babel/runtime -D
B.安装babel语法插件包
    npm install @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D
C.在项目根目录创建并配置babel.config.js文件

    module.exports = {
        presets:[&quot;@babel/preset-env&quot;],
        plugins:[ &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-proposal-class-properties&quot; ]
    }
D.配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
    ......
    plugins:[ htmlPlugin ],
    module : {
        rules:[
            {
                //test设置需要匹配的文件类型，支持正则
                test:/\.css$/,
                //use表示该文件类型需要调用的loader
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;]
            },
            {
                test:/\.less$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]
            },
            {
                test:/\.scss$/,
                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]
            },{
                test:/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/,
                //limit用来设置字节数，只有小于limit值的图片，才会转换
                //为base64图片
                use:&quot;url-loader?limit=16940&quot;
            },{
                test:/\.js$/,
                use:&quot;babel-loader&quot;,
                //exclude为排除项，意思是不要处理node_modules中的js文件
                exclude:/node_modules/
            }
        ]
    }
}</code></pre><h3 id="12-Vue单文件组件"><a href="#12-Vue单文件组件" class="headerlink" title="12.Vue单文件组件"></a>12.Vue单文件组件</h3><p>传统Vue组件的缺陷：<br>全局定义的组件不能重名，字符串模板缺乏语法高亮，不支持css(当html和js组件化时，css没有参与其中)<br>没有构建步骤限制，只能使用H5和ES5，不能使用预处理器（babel）<br>解决方案：<br>使用Vue单文件组件，每个单文件组件的后缀名都是.vue<br>每一个Vue单文件组件都由三部分组成<br>1).template组件组成的模板区域<br>2).script组成的业务逻辑区域<br>3).style样式区域</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    组件代码区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    js代码区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    样式代码区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>补充：安装Vetur插件可以使得.vue文件中的代码高亮</p>
<p>配置.vue文件的加载器<br>A.安装vue组件的加载器<br>    npm install vue-loader vue-template-compiler -D<br>B.配置规则：更改webpack.config.js的module中的rules数组<br>    const VueLoaderPlugin = require(“vue-loader/lib/plugin”);<br>    const vuePlugin = new VueLoaderPlugin();<br>    module.exports = {<br>        ……<br>        plugins:[ htmlPlugin, vuePlugin  ],<br>        module : {<br>            rules:[<br>                …//其他规则<br>                {<br>                    test:/.vue$/,<br>                    loader:”vue-loader”,</p>
<pre><code>            }
        ]
    }
}</code></pre><h3 id="13-在webpack中使用vue"><a href="#13-在webpack中使用vue" class="headerlink" title="13.在webpack中使用vue"></a>13.在webpack中使用vue</h3><p>上一节我们安装处理了vue单文件组件的加载器，想要让vue单文件组件能够使用，我们必须要安装vue<br>并使用vue来引用vue单文件组件。<br>A.安装Vue<br>    npm install vue -S<br>B.在index.js中引入vue：import Vue from “vue”<br>C.创建Vue实例对象并指定el，最后使用render函数渲染单文件组件<br>    const vm = new Vue({<br>        el:”#first”,<br>        render:h=&gt;h(app)<br>    })</p>
<h3 id="14-使用webpack打包发布项目"><a href="#14-使用webpack打包发布项目" class="headerlink" title="14.使用webpack打包发布项目"></a>14.使用webpack打包发布项目</h3><p>在项目上线之前，我们需要将整个项目打包并发布。<br>A.配置package.json<br>    “scripts”:{<br>        “dev”:”webpack-dev-server”,<br>        “build”:”webpack -p”<br>    }<br>B.在项目打包之前，可以将dist目录删除，生成全新的dist目录</p>
<h3 id="15-Vue脚手架"><a href="#15-Vue脚手架" class="headerlink" title="15.Vue脚手架"></a>15.Vue脚手架</h3><p>Vue脚手架可以快速生成Vue项目基础的架构。<br>A.安装3.x版本的Vue脚手架：<br>    npm install -g @vue/cli<br>B.基于3.x版本的脚手架创建Vue项目：<br>    1).使用命令创建Vue项目<br>        命令：vue create my-project<br>        选择Manually select features(选择特性以创建项目)<br>        勾选特性可以用空格进行勾选。<br>        是否选用历史模式的路由：n<br>        ESLint选择：ESLint + Standard config<br>        何时进行ESLint语法校验：Lint on save<br>        babel，postcss等配置文件如何放置：In dedicated config files(单独使用文件进行配置)<br>        是否保存为模板：n<br>        使用哪个工具安装包：npm<br>    2).基于ui界面创建Vue项目<br>        命令：vue ui<br>        在自动打开的创建项目网页中配置项目信息。<br>    3).基于2.x的旧模板，创建Vue项目<br>        npm install -g @vue/cli-init<br>        vue init webpack my-project</p>
<p>C.分析Vue脚手架生成的项目结构<br>    node_modules:依赖包目录<br>    public：静态资源目录<br>    src：源码目录<br>    src/assets:资源目录<br>    src/components：组件目录<br>    src/views:视图组件目录<br>    src/App.vue:根组件<br>    src/main.js:入口js<br>    src/router.js:路由js<br>    babel.config.js:babel配置文件<br>    .eslintrc.js:</p>
<h3 id="16-Vue脚手架的自定义配置"><a href="#16-Vue脚手架的自定义配置" class="headerlink" title="16.Vue脚手架的自定义配置"></a>16.Vue脚手架的自定义配置</h3><pre><code>A.通过 package.json 进行配置 [不推荐使用]
    &quot;vue&quot;:{
        &quot;devServer&quot;:{
            &quot;port&quot;:&quot;9990&quot;,
            &quot;open&quot;:true
        }
    }
B.通过单独的配置文件进行配置，创建vue.config.js
    module.exports = {
        devServer:{
            port:8888,
            open:true
        }
    }</code></pre><h3 id="17-Element-UI的基本使用"><a href="#17-Element-UI的基本使用" class="headerlink" title="17.Element-UI的基本使用"></a>17.Element-UI的基本使用</h3><p>Element-UI:一套基于2.0的桌面端组件库<br>官网地址：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a><br>A.安装：<br>    npm install element-ui -S<br>B.导入使用：<br>    import ElementUI from “element-ui”;<br>    import “element-ui/lib/theme-chalk/index.css”;</p>
<pre><code>Vue.use(ElementUI)</code></pre>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/01/25/vue3-03/</url>
    <content><![CDATA[<h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><p>1.能够说出什么是路由<br>2.能够说出前端路由的实现原理<br>3.能够使用Vue-Router实现前端路由<br>4.能够实现嵌套路由，动态路由<br>5.能够实现命名路由以及编程式导航<br>6.理解并实现后台管理案例</p>
<a id="more"></a>
<h3 id="1-路由的概念"><a href="#1-路由的概念" class="headerlink" title="1.路由的概念"></a>1.路由的概念</h3><p>路由的本质就是一种对应关系，比如说我们在url地址中输入我们要访问的url地址之后，浏览器要去请求这个url地址对应的资源。<br>那么url地址和真实的资源之间就有一种对应的关系，就是路由。</p>
<p>路由分为前端路由和后端路由<br>1).后端路由是由服务器端进行实现，并完成资源的分发<br>2).前端路由是依靠hash值(锚链接)的变化进行实现 </p>
<p>后端路由性能相对前端路由来说较低，所以，我们接下来主要学习的是前端路由<br>前端路由的基本概念：根据不同的事件来显示不同的页面内容，即事件与事件处理函数之间的对应关系<br>前端路由主要做的事情就是监听事件并分发执行事件处理函数</p>
<h3 id="2-前端路由的初体验"><a href="#2-前端路由的初体验" class="headerlink" title="2.前端路由的初体验"></a>2.前端路由的初体验</h3><p>前端路由是基于hash值的变化进行实现的（比如点击页面中的菜单或者按钮改变URL的hash值，根据hash值的变化来控制组件的切换）<br>核心实现依靠一个事件，即监听hash值变化的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//location.hash可以获取到最新的hash值</span></span><br><span class="line">    location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端路由实现tab栏切换：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入 vue 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./lib/vue_2.5.22.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 被 vue 实例控制的 div 区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切换组件的超链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/zhuye"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/keji"</span>&gt;</span>科技<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/caijing"</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/yule"</span>&gt;</span>娱乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据 :is 属性指定的组件名称，把对应的组件渲染到 component 标签所在的位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以把 component 标签当做是【组件的占位符】 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// #region 定义需要被切换的 4 个组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 主页组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> zhuye = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>主页信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 科技组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> keji = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>科技信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 财经组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> caijing = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>财经信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 娱乐组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> yule = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>娱乐信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// #endregion</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// #region vue 实例对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">        comName: <span class="string">'zhuye'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">// 注册私有组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        zhuye,</span><br><span class="line">        keji,</span><br><span class="line">        caijing,</span><br><span class="line">        yule</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    <span class="comment">// #endregion</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过 location.hash 获取到最新的 hash 值</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">switch</span>(location.hash.slice(<span class="number">1</span>))&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/zhuye'</span>:</span></span><br><span class="line"><span class="actionscript">            vm.comName = <span class="string">'zhuye'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/keji'</span>:</span></span><br><span class="line"><span class="actionscript">            vm.comName = <span class="string">'keji'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/caijing'</span>:</span></span><br><span class="line"><span class="actionscript">            vm.comName = <span class="string">'caijing'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/yule'</span>:</span></span><br><span class="line"><span class="actionscript">            vm.comName = <span class="string">'yule'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">break</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>案例效果图：</p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/01%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%281%29.pngimages/01%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.png" alt=""></p>
<p>点击每个超链接之后，会进行相应的内容切换，如下：</p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/01%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt=""></p>
<p>核心思路：<br>在页面中有一个vue实例对象，vue实例对象中有四个组件，分别是tab栏切换需要显示的组件内容<br>在页面中有四个超链接，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/zhuye"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/keji"</span>&gt;</span>科技<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/caijing"</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/yule"</span>&gt;</span>娱乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们点击这些超链接的时候，就会改变url地址中的hash值，当hash值被改变时，就会触发onhashchange事件<br>在触发onhashchange事件的时候，我们根据hash值来让不同的组件进行显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 location.hash 获取到最新的 hash 值</span></span><br><span class="line">    <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">    <span class="keyword">switch</span>(location.hash.slice(<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/zhuye'</span>:</span><br><span class="line">        <span class="comment">//通过更改数据comName来指定显示的组件</span></span><br><span class="line">        <span class="comment">//因为 &lt;component :is="comName"&gt;&lt;/component&gt; ，组件已经绑定了comName</span></span><br><span class="line">        vm.comName = <span class="string">'zhuye'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/keji'</span>:</span><br><span class="line">        vm.comName = <span class="string">'keji'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/caijing'</span>:</span><br><span class="line">        vm.comName = <span class="string">'caijing'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/yule'</span>:</span><br><span class="line">        vm.comName = <span class="string">'yule'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Vue-Router简介"><a href="#3-Vue-Router简介" class="headerlink" title="3.Vue Router简介"></a>3.Vue Router简介</h3><p>它是一个Vue.js官方提供的路由管理器。是一个功能更加强大的前端路由器，推荐使用。<br>Vue Router和Vue.js非常契合，可以一起方便的实现SPA(single page web application,单页应用程序)应用程序的开发。<br>Vue Router依赖于Vue，所以需要先引入Vue，再引入Vue Router</p>
<p>Vue Router的特性：<br>支持H5历史模式或者hash模式<br>支持嵌套路由<br>支持路由参数<br>支持编程式路由<br>支持命名路由<br>支持路由导航守卫<br>支持路由过渡动画特效<br>支持路由懒加载<br>支持路由滚动行为</p>
<h3 id="4-Vue-Router的使用步骤-★★★"><a href="#4-Vue-Router的使用步骤-★★★" class="headerlink" title="4.Vue Router的使用步骤(★★★)"></a>4.Vue Router的使用步骤(★★★)</h3><p>A.导入js文件</p>
<script src="lib/vue_2.5.22.js"></script>
<script src="lib/vue-router_3.0.2.js"></script>
<p>B.添加路由链接:<router-link>是路由中提供的标签，默认会被渲染为a标签，to属性默认被渲染为href属性，<br>to属性的值会被渲染为#开头的hash地址<br><router-link to="/user">User</router-link><br><router-link to="/login">Login</router-link><br>C.添加路由填充位（路由占位符）<br><router-view></router-view><br>D.定义路由组件<br>var User = { template:”<div>This is User</div>“ }<br>var Login = { template:”<div>This is Login</div>“ }<br>E.配置路由规则并创建路由实例<br>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes:[<br>        //每一个路由规则都是一个对象，对象中至少包含path和component两个属性<br>        //path表示  路由匹配的hash地址，component表示路由规则对应要展示的组件对象<br>        {path:”/user”,component:User},<br>        {path:”/login”,component:Login}<br>    ]<br>})<br>F.将路由挂载到Vue实例中<br>new Vue({<br>    el:”#app”,<br>    //通过router属性挂载路由对象<br>    router:myRouter<br>})</p>
<p>小结：<br>Vue Router的使用步骤还是比较清晰的，按照步骤一步一步就能完成路由操作<br>A.导入js文件<br>B.添加路由链接<br>C.添加路由占位符(最后路由展示的组件就会在占位符的位置显示)<br>D.定义路由组件<br>E.配置路由规则并创建路由实例<br>F.将路由挂载到Vue实例中</p>
<p>补充：<br>路由重定向：可以通过路由重定向为页面设置默认展示的组件<br>在路由规则中添加一条路由规则即可，如下：<br>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //path设置为/表示页面最初始的地址 / ,redirect表示要被重定向的新地址，设置为一个路由即可<br>        { path:”/“,redirect:”/user”},<br>        { path: “/user”, component: User },<br>        { path: “/login”, component: Login }<br>    ]<br>})</p>
<h3 id="5-嵌套路由，动态路由的实现方式"><a href="#5-嵌套路由，动态路由的实现方式" class="headerlink" title="5.嵌套路由，动态路由的实现方式"></a>5.嵌套路由，动态路由的实现方式</h3><h4 id="A-嵌套路由的概念-★★★"><a href="#A-嵌套路由的概念-★★★" class="headerlink" title="A.嵌套路由的概念(★★★)"></a>A.嵌套路由的概念(★★★)</h4><p>当我们进行路由的时候显示的组件中还有新的子级路由链接以及内容。</p>
<p>嵌套路由最关键的代码在于理解子级路由的概念：<br>比如我们有一个/login的路由<br>那么/login下面还可以添加子级路由，如:<br>/login/account<br>/login/phone</p>
<p>参考代码如下：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">var User = &#123; template: <span class="string">"&lt;div&gt;This is User&lt;/div&gt;"</span> &#125;</span><br><span class="line">//Login组件中的模板代码里面包含了子级路由链接以及子级路由的占位符</span><br><span class="line">    var Login = &#123; template: `<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login/account"</span>&gt;</span>账号密码登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login/phone"</span>&gt;</span>扫码登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 子路由组件将会在router-view中显示 --&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml">` &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    //定义两个子级路由组件</span></span><br><span class="line"><span class="xml">    var account = </span><span class="xquery">&#123; template:<span class="string">"&lt;div&gt;账号：&lt;input&gt;&lt;br&gt;密码：&lt;input&gt;&lt;/div&gt;"</span>&#125;</span><span class="xml">;</span></span><br><span class="line"><span class="xml">    var phone = </span><span class="xquery">&#123; template:<span class="string">"&lt;h1&gt;扫我二维码&lt;/h1&gt;"</span>&#125;</span><span class="xml">;</span></span><br><span class="line"><span class="xml">    var myRouter = new VueRouter(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">        //routes是路由规则数组</span></span><br><span class="line"><span class="xquery">        routes: [</span></span><br><span class="line"><span class="xquery">            &#123;<span class="built_in"> path</span>:<span class="string">"/"</span>,redirect:<span class="string">"/user"</span>&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">            </span><span class="xquery">&#123;<span class="built_in"> path</span>: <span class="string">"/user"</span>, component: User &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">            </span><span class="xquery">&#123; </span></span><br><span class="line"><span class="xquery">               <span class="built_in"> path</span>: <span class="string">"/login"</span>, </span></span><br><span class="line"><span class="xquery">                component: Login,</span></span><br><span class="line"><span class="xquery">                //通过children属性为/login添加子路由规则</span></span><br><span class="line"><span class="xquery">                children:[</span></span><br><span class="line"><span class="xquery">                    &#123;<span class="built_in"> path</span>: <span class="string">"/login/account"</span>, component: account &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">                    </span><span class="xquery">&#123;<span class="built_in"> path</span>: <span class="string">"/login/phone"</span>, component: phone &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">                ]</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        ]</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    var vm = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="xquery">        data: &#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        methods: </span><span class="xquery">&#123;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        router:myRouter</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br></pre></td></tr></table></figure>

<p>页面效果大致如下：</p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/03%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt=""></p>
<h4 id="B-动态路由匹配-★★★"><a href="#B-动态路由匹配-★★★" class="headerlink" title="B.动态路由匹配(★★★)"></a>B.动态路由匹配(★★★)</h4><p>var User = { template:”<div>用户：</div>“}</p>
<p>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //通过/:参数名  的形式传递参数<br>        { path: “/user/:id”, component: User },</p>
<pre><code>]</code></pre><p>})</p>
<p>补充：<br>如果使用$route.params.id来获取路径传参的数据不够灵活。<br>1.我们可以通过props来接收参数<br>var User = {<br>    props:[“id”],<br>    template:”<div>用户：{{id}}</div>“<br>    }</p>
<p>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //通过/:参数名  的形式传递参数<br>        //如果props设置为true，route.params将会被设置为组件属性<br>        { path: “/user/:id”, component: User,props:true },</p>
<pre><code>]</code></pre><p>})</p>
<p>2.还有一种情况，我们可以将props设置为对象，那么就直接将对象的数据传递给<br>组件进行使用<br>var User = {<br>    props:[“username”,”pwd”],<br>    template:”<div>用户：—</div>“<br>    }</p>
<p>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //通过/:参数名  的形式传递参数<br>        //如果props设置为对象，则传递的是对象中的数据给组件<br>        { path: “/user/:id”, component: User,props:{username:”jack”,pwd:123} },</p>
<pre><code>]</code></pre><p>})</p>
<p>3.如果想要获取传递的参数值还想要获取传递的对象数据，那么props应该设置为<br>函数形式。<br>var User = {<br>    props:[“username”,”pwd”,”id”],<br>    template:”<div>用户：{{id}} -&gt; {{username}}—{{pwd}}</div>“<br>    }</p>
<p>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //通过/:参数名  的形式传递参数<br>        //如果props设置为函数，则通过函数的第一个参数获取路由对象<br>        //并可以通过路由对象的params属性获取传递的参数<br>        //<br>        { path: “/user/:id”, component: User,props:(route)=&gt;{<br>            return {username:”jack”,pwd:123,id:route.params.id}<br>            }<br>        },</p>
<pre><code>]</code></pre><p>})</p>
<h3 id="7-命名路由以及编程式导航"><a href="#7-命名路由以及编程式导航" class="headerlink" title="7.命名路由以及编程式导航"></a>7.命名路由以及编程式导航</h3><h4 id="A-命名路由：给路由取别名"><a href="#A-命名路由：给路由取别名" class="headerlink" title="A.命名路由：给路由取别名"></a>A.命名路由：给路由取别名</h4><p>案例：</p>
<p>var myRouter = new VueRouter({<br>    //routes是路由规则数组<br>    routes: [<br>        //通过name属性为路由添加一个别名<br>        { path: “/user/:id”, component: User, name:”user”},</p>
<pre><code>]</code></pre><p>})</p>
<p>//添加了别名之后，可以使用别名进行跳转<br><router-link to="/user">User</router-link><br><router-link :to="{ name:'user' , params: {id:123} }">User</router-link></p>
<p>//还可以编程式导航<br>myRouter.push( { name:’user’ , params: {id:123} } )</p>
<h4 id="B-编程式导航-★★★"><a href="#B-编程式导航-★★★" class="headerlink" title="B.编程式导航(★★★)"></a>B.编程式导航(★★★)</h4><p>页面导航的两种方式：<br>A.声明式导航：通过点击链接的方式实现的导航<br>B.编程式导航：调用js的api方法实现导航</p>
<p>Vue-Router中常见的导航方式：<br>this.$router.push(“hash地址”);<br>this.$router.push(“/login”);<br>this.$router.push({ name:’user’ , params: {id:123} });<br>this.$router.push({ path:”/login” });<br>this.$router.push({ path:”/login”,query:{username:”jack”} });</p>
<p>this.$router.go( n );//n为数字，参考history.go<br>this.$router.go( -1 );</p>
<h3 id="8-实现后台管理案例-★★★"><a href="#8-实现后台管理案例-★★★" class="headerlink" title="8.实现后台管理案例(★★★)"></a>8.实现后台管理案例(★★★)</h3><p>案例效果：</p>
<p><img src="http://q70bd5y95.bkt.clouddn.com/02%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.png" alt=""></p>
<p>点击左侧的”用户管理”,”权限管理”,”商品管理”,”订单管理”,”系统设置”都会出现对应的组件并展示内容</p>
<p>其中”用户管理”组件展示的效果如上图所示，在用户管理区域中的详情链接也是可以点击的，点击之后将会显示用户详情信息。</p>
<p>案例思路：<br>1).先将素材文件夹中的11.基于vue-router的案例.html复制到我们自己的文件夹中。<br>看一下这个文件中的代码编写了一些什么内容，<br>这个页面已经把后台管理页面的基本布局实现了<br>2).在页面中引入vue，vue-router<br>3).创建Vue实例对象，准备开始编写代码实现功能<br>4).希望是通过组件的形式展示页面的主体内容，而不是写死页面结构，所以我们可以定义一个根组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//只需要把原本页面中的html代码设置为组件中的模板内容即可</span><br><span class="line">const app = &#123;</span><br><span class="line">    template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 头部区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>传智后台管理系统<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 中间主体区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 左侧菜单栏 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content left"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>权限管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>订单管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>系统设置<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 右侧内容区域 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-content"</span>&gt;</span>添加用户表单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 尾部区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>版权信息<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>5).当我们访问页面的时候，默认需要展示刚刚创建的app根组件，我们可以<br>创建一个路由对象来完成这个事情,然后将路由挂载到Vue实例对象中即可</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const myRouter = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    route<span class="variable">s:</span>[</span><br><span class="line">        &#123;path:<span class="string">"/"</span>,componen<span class="variable">t:app</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">"#app"</span>,</span><br><span class="line">    dat<span class="variable">a:</span>&#123;&#125;,</span><br><span class="line">    method<span class="variable">s:</span>&#123;&#125;,</span><br><span class="line">    router:myRouter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>补充：到此为止，基本的js代码都处理完毕了，我们还需要设置一个路由占位符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6).此时我们打开页面应该就可以得到一个VueRouter路由出来的根组件了<br>我们需要在这个根组件中继续路由实现其他的功能子组件<br>先让我们更改根组件中的模板：更改左侧li为子级路由链接，并在右侧内容区域添加子级组件占位符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">const app = &#123;</span><br><span class="line">    template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        ........</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 左侧菜单栏 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content left"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 注意：我们把所有li都修改为了路由链接 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/users"</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/accesses"</span>&gt;</span>权限管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/goods"</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/orders"</span>&gt;</span>订单管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/systems"</span>&gt;</span>系统设置<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 右侧内容区域 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-content"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 在 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        .......</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们要为子级路由创建并设置需要显示的子级组件</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议创建的组件首字母大写，和其他内容区分</span></span><br><span class="line">const Users = &#123;template:`<span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;h3&gt;</span>用户管理<span class="params">&lt;/h3&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span>`&#125;</span><br><span class="line">const Access = &#123;template:`<span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;h3&gt;</span>权限管理<span class="params">&lt;/h3&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span>`&#125;</span><br><span class="line">const Goods = &#123;template:`<span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;h3&gt;</span>商品管理<span class="params">&lt;/h3&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span>`&#125;</span><br><span class="line">const Orders = &#123;template:`<span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;h3&gt;</span>订单管理<span class="params">&lt;/h3&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span>`&#125;</span><br><span class="line">const Systems = &#123;template:`<span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;h3&gt;</span>系统管理<span class="params">&lt;/h3&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span>`&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加子组件的路由规则</span></span><br><span class="line">const myRouter = new VueRouter(&#123;</span><br><span class="line"><span class="symbol">    routes:</span>[</span><br><span class="line">        &#123;path:<span class="string">"/"</span>,component:app , children:[</span><br><span class="line">            &#123; path:<span class="string">"/users"</span>,component:Users &#125;,</span><br><span class="line">            &#123; path:<span class="string">"/accesses"</span>,component:Access &#125;,</span><br><span class="line">            &#123; path:<span class="string">"/goods"</span>,component:Goods &#125;,</span><br><span class="line">            &#123; path:<span class="string">"/orders"</span>,component:Orders &#125;,</span><br><span class="line">            &#123; path:<span class="string">"/systems"</span>,component:Systems &#125;,</span><br><span class="line">        ]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const vm = new Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span><span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">    methods:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">    router:</span>myRouter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>7).展示用户信息列表：<br>    A.为Users组件添加私有数据,并在模板中循环展示私有数据<br>    ​<code>const Users = {
    data(){
        return {
            userList:[
                {id:1,name:&quot;zs&quot;,age:18},
                {id:2,name:&quot;ls&quot;,age:19},
                {id:3,name:&quot;wang&quot;,age:20},
                {id:4,name:&quot;jack&quot;,age:21},
            ]
        }
    },
    template:`&lt;div&gt;
        &lt;h3&gt;用户管理&lt;/h3&gt;
        &lt;table&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;编号&lt;/th&gt;
                    &lt;th&gt;姓名&lt;/th&gt;
                    &lt;th&gt;年龄&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;tr :key=&quot;item.id&quot; v-for=&quot;item in userList&quot;&gt;
                    &lt;td&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;详情&lt;/a&gt;&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;`}
    ​</code></p>
<p>8.当用户列表展示完毕之后，我们可以点击列表中的详情来显示用户详情信息，首先我们需要创建一个组件，用来展示详情信息</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">const UserInfo = &#123;</span><br><span class="line"><span class="symbol">    props:</span>[<span class="string">"id"</span>],</span><br><span class="line"><span class="symbol">    template:</span>`<span class="params">&lt;div&gt;</span></span><br><span class="line">      <span class="params">&lt;h5&gt;</span>用户详情<span class="params">&lt;/h5&gt;</span></span><br><span class="line">      <span class="params">&lt;p&gt;</span>查看 &#123;&#123;id&#125;&#125; 号用户信息<span class="params">&lt;/p&gt;</span></span><br><span class="line">      <span class="params">&lt;button @click="goBack"&gt;</span>返回用户详情页<span class="params">&lt;/button&gt;</span></span><br><span class="line">    <span class="params">&lt;/div&gt;</span> `,</span><br><span class="line"><span class="symbol">    methods:</span>&#123;</span><br><span class="line">      goBack()&#123;</span><br><span class="line">        <span class="comment">//当用户点击按钮，后退一页</span></span><br><span class="line">        this.$router.go(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要设置这个组件的路由规则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">const myRouter = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">    routes:</span>[</span><br><span class="line">        &#123;<span class="string">path:</span><span class="string">"/"</span>,<span class="string">component:</span>app , <span class="string">children:</span>[</span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/users"</span>,<span class="string">component:</span>Users &#125;,</span><br><span class="line">            <span class="comment">//添加一个/userinfo的路由规则</span></span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/userinfo/:id"</span>,<span class="string">component:</span>UserInfo,<span class="string">props:</span><span class="literal">true</span>&#125;,</span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/accesses"</span>,<span class="string">component:</span>Access &#125;,</span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/goods"</span>,<span class="string">component:</span>Goods &#125;,</span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/orders"</span>,<span class="string">component:</span>Orders &#125;,</span><br><span class="line">            &#123; <span class="string">path:</span><span class="string">"/systems"</span>,<span class="string">component:</span>Systems &#125;,</span><br><span class="line">        ]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span><span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">    methods:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">    router:</span>myRouter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>再接着给用户列表中的详情a连接添加事件</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">const Users = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            userList:[</span><br><span class="line">                <span class="built_in">&#123;id</span>:<span class="number">1</span><span class="built_in">,name</span>:<span class="string">"zs"</span>,age:<span class="number">18</span>&#125;,</span><br><span class="line">                <span class="built_in">&#123;id</span>:<span class="number">2</span><span class="built_in">,name</span>:<span class="string">"ls"</span>,age:<span class="number">19</span>&#125;,</span><br><span class="line">                <span class="built_in">&#123;id</span>:<span class="number">3</span><span class="built_in">,name</span>:<span class="string">"wang"</span>,age:<span class="number">20</span>&#125;,</span><br><span class="line">                <span class="built_in">&#123;id</span>:<span class="number">4</span><span class="built_in">,name</span>:<span class="string">"jack"</span>,age:<span class="number">21</span>&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:`<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">v-for</span>=<span class="string">"item in userList"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.id</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span><span class="built_in">.name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="type">item</span>.age&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> @<span class="attr">click</span>=<span class="string">"goDetail(item.id)"</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;`,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        goDetail<span class="built_in">(id</span>)&#123;</span><br><span class="line">            this.<span class="variable">$router</span>.push(<span class="string">"/userinfo/"</span><span class="built_in">+id</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电商管理后台 API 接口文档</title>
    <url>/2020/01/24/vue3-02/</url>
    <content><![CDATA[<h1 id="1-电商管理后台-API-接口文档"><a href="#1-电商管理后台-API-接口文档" class="headerlink" title="1. 电商管理后台 API 接口文档"></a>1. 电商管理后台 API 接口文档</h1><h2 id="1-1-API-V1-接口说明"><a href="#1-1-API-V1-接口说明" class="headerlink" title="1.1. API V1 接口说明"></a>1.1. API V1 接口说明</h2><ul>
<li>接口基准地址：<code>http://127.0.0.1:8888/api/private/v1/</code></li>
<li>服务端已开启 CORS 跨域支持</li>
<li>API V1 认证统一使用 Token 认证</li>
<li>需要授权的 API ，必须在请求头中使用 <code>Authorization</code> 字段提供 <code>token</code> 令牌</li>
<li>使用 HTTP Status Code 标识状态</li>
<li>数据返回格式统一使用 JSON<a id="more"></a>

</li>
</ul>
<h3 id="1-1-1-支持的请求方法"><a href="#1-1-1-支持的请求方法" class="headerlink" title="1.1.1. 支持的请求方法"></a>1.1.1. 支持的请求方法</h3><ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<h3 id="1-1-2-通用返回状态说明"><a href="#1-1-2-通用返回状态说明" class="headerlink" title="1.1.2. 通用返回状态说明"></a>1.1.2. 通用返回状态说明</h3><table>
<thead>
<tr>
<th><em>状态码</em></th>
<th><em>含义</em></th>
<th><em>说明</em></th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td>201</td>
<td>CREATED</td>
<td>创建成功</td>
</tr>
<tr>
<td>204</td>
<td>DELETED</td>
<td>删除成功</td>
</tr>
<tr>
<td>400</td>
<td>BAD REQUEST</td>
<td>请求的地址不存在或者包含不支持的参数</td>
</tr>
<tr>
<td>401</td>
<td>UNAUTHORIZED</td>
<td>未授权</td>
</tr>
<tr>
<td>403</td>
<td>FORBIDDEN</td>
<td>被禁止访问</td>
</tr>
<tr>
<td>404</td>
<td>NOT FOUND</td>
<td>请求的资源不存在</td>
</tr>
<tr>
<td>422</td>
<td>Unprocesable entity</td>
<td>[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误</td>
</tr>
<tr>
<td>500</td>
<td>INTERNAL SERVER ERROR</td>
<td>内部错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="1-2-登录"><a href="#1-2-登录" class="headerlink" title="1.2. 登录"></a>1.2. 登录</h2><h3 id="1-2-1-登录验证接口"><a href="#1-2-1-登录验证接口" class="headerlink" title="1.2.1. 登录验证接口"></a>1.2.1. 登录验证接口</h3><ul>
<li>请求路径：login</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>用户名</td>
<td>不能为空</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>不能为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td></td>
</tr>
<tr>
<td>rid</td>
<td>用户角色 ID</td>
<td></td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
<td></td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td></td>
</tr>
<tr>
<td>token</td>
<td>令牌</td>
<td>基于 jwt 的令牌</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="attr">"rid"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"123"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"123@qq.com"</span>,</span><br><span class="line">        <span class="attr">"token"</span>: <span class="string">"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"登录成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-用户管理"><a href="#1-3-用户管理" class="headerlink" title="1.3. 用户管理"></a>1.3. 用户管理</h2><h3 id="1-3-1-用户数据列表"><a href="#1-3-1-用户数据列表" class="headerlink" title="1.3.1. 用户数据列表"></a>1.3.1. 用户数据列表</h3><ul>
<li>请求路径：users</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>查询参数</td>
<td>可以为空</td>
</tr>
<tr>
<td>pagenum</td>
<td>当前页码</td>
<td>不能为空</td>
</tr>
<tr>
<td>pagesize</td>
<td>每页显示条数</td>
<td>不能为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>totalpage</td>
<td>总记录数</td>
<td></td>
</tr>
<tr>
<td>pagenum</td>
<td>当前页码</td>
<td></td>
</tr>
<tr>
<td>users</td>
<td>用户数据集合</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"totalpage"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"pagenum"</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">"users"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">25</span>,</span><br><span class="line">                <span class="attr">"username"</span>: <span class="string">"tige117"</span>,</span><br><span class="line">                <span class="attr">"mobile"</span>: <span class="string">"18616358651"</span>,</span><br><span class="line">                <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"email"</span>: <span class="string">"tige112@163.com"</span>,</span><br><span class="line">                <span class="attr">"create_time"</span>: <span class="string">"2017-11-09T20:36:26.000Z"</span>,</span><br><span class="line">                <span class="attr">"mg_state"</span>: <span class="literal">true</span>, <span class="comment">// 当前用户的状态</span></span><br><span class="line">                <span class="attr">"role_name"</span>: <span class="string">"炒鸡管理员"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-添加用户"><a href="#1-3-2-添加用户" class="headerlink" title="1.3.2. 添加用户"></a>1.3.2. 添加用户</h3><ul>
<li>请求路径：users</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>用户名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>不能为空</td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td>可以为空</td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td></td>
</tr>
<tr>
<td>rid</td>
<td>用户角色 ID</td>
<td></td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
<td></td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">28</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"tige1200"</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"test"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"openid"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"test@test.com"</span>,</span><br><span class="line">        <span class="attr">"create_time"</span>: <span class="string">"2017-11-10T03:47:13.533Z"</span>,</span><br><span class="line">        <span class="attr">"modify_time"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"is_delete"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"is_active"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"用户创建成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-修改用户状态"><a href="#1-3-3-修改用户状态" class="headerlink" title="1.3.3. 修改用户状态"></a>1.3.3. 修改用户状态</h3><ul>
<li>请求路径：users/:uId/state/:type</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>uId</td>
<td>用户 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>type</td>
<td>用户状态</td>
<td>不能为空<code>携带在url中</code>，值为 true 或者 false</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">566</span>,</span><br><span class="line">    <span class="attr">"rid"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">    <span class="attr">"mobile"</span>: <span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"bb@itcast.com"</span>,</span><br><span class="line">    <span class="attr">"mg_state"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"meta"</span>: &#123;</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"设置状态成功"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-根据-ID-查询用户信息"><a href="#1-3-4-根据-ID-查询用户信息" class="headerlink" title="1.3.4. 根据 ID 查询用户信息"></a>1.3.4. 根据 ID 查询用户信息</h3><ul>
<li>请求路径：users/:id</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td></td>
</tr>
<tr>
<td>role_id</td>
<td>角色 ID</td>
<td></td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">503</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin3"</span>,</span><br><span class="line">        <span class="attr">"role_id"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"00000"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"new@new.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"查询成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-编辑用户提交"><a href="#1-3-5-编辑用户提交" class="headerlink" title="1.3.5. 编辑用户提交"></a>1.3.5. 编辑用户提交</h3><ul>
<li>请求路径：users/:id</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 id</td>
<td>不能为空 <code>参数是url参数:id</code></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td>可以为空</td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td></td>
</tr>
<tr>
<td>role_id</td>
<td>角色 ID</td>
<td></td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 200表示成功，500表示失败 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">503</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin3"</span>,</span><br><span class="line">        <span class="attr">"role_id"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"111"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"123@123.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-6-删除单个用户"><a href="#1-3-6-删除单个用户" class="headerlink" title="1.3.6. 删除单个用户"></a>1.3.6. 删除单个用户</h3><ul>
<li>请求路径：users/:id</li>
<li>请求方法：delete</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 id</td>
<td>不能为空<code>参数是url参数:id</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"删除成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-7-分配用户角色"><a href="#1-3-7-分配用户角色" class="headerlink" title="1.3.7. 分配用户角色"></a>1.3.7. 分配用户角色</h3><ul>
<li>请求路径：users/:id/role</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td>不能为空<code>参数是url参数:id</code></td>
</tr>
<tr>
<td>rid</td>
<td>角色 id</td>
<td>不能为空<code>参数body参数</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td></td>
</tr>
<tr>
<td>role_id</td>
<td>角色 ID</td>
<td></td>
</tr>
<tr>
<td>mobile</td>
<td>手机号</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">508</span>,</span><br><span class="line">        <span class="attr">"rid"</span>: <span class="string">"30"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"asdf1"</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"123123"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"adfsa@qq.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"设置角色成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-权限管理"><a href="#1-4-权限管理" class="headerlink" title="1.4. 权限管理"></a>1.4. 权限管理</h2><h3 id="1-4-1-所有权限列表"><a href="#1-4-1-所有权限列表" class="headerlink" title="1.4.1. 所有权限列表"></a>1.4.1. 所有权限列表</h3><ul>
<li>请求路径：rights/:type</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>类型</td>
<td>值 list 或 tree , list 列表显示权限, tree 树状显示权限,<code>参数是url参数:type</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>权限 ID</td>
<td></td>
</tr>
<tr>
<td>authName</td>
<td>权限说明</td>
<td></td>
</tr>
<tr>
<td>level</td>
<td>权限层级</td>
<td></td>
</tr>
<tr>
<td>pid</td>
<td>权限父 ID</td>
<td></td>
</tr>
<tr>
<td>path</td>
<td>对应访问路径</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据 type=list</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">"authName"</span>: <span class="string">"商品管理"</span>,</span><br><span class="line">            <span class="attr">"level"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"path"</span>: <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">102</span>,</span><br><span class="line">            <span class="attr">"authName"</span>: <span class="string">"订单管理"</span>,</span><br><span class="line">            <span class="attr">"level"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"path"</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取权限列表成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type=tree</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: 101,</span><br><span class="line">      authName: '商品管理',</span><br><span class="line">      path: null,</span><br><span class="line">      pid: 0,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 104,</span><br><span class="line">          authName: '商品列表',</span><br><span class="line">          path: null,</span><br><span class="line">          pid: 101,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: 105,</span><br><span class="line">              authName: '添加商品',</span><br><span class="line">              path: null,</span><br><span class="line">              pid: '104,101'</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  meta: &#123;</span><br><span class="line">    msg: '获取权限列表成功',</span><br><span class="line">    status: 200</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-左侧菜单权限"><a href="#1-4-2-左侧菜单权限" class="headerlink" title="1.4.2. 左侧菜单权限"></a>1.4.2. 左侧菜单权限</h3><ul>
<li>请求路径：menus</li>
<li>请求方法：get</li>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">"authName"</span>: <span class="string">"商品管理"</span>,</span><br><span class="line">            <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"id"</span>: <span class="number">104</span>,</span><br><span class="line">                    <span class="attr">"authName"</span>: <span class="string">"商品列表"</span>,</span><br><span class="line">                    <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"children"</span>: []</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="string">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取菜单列表成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-角色管理"><a href="#1-5-角色管理" class="headerlink" title="1.5. 角色管理"></a>1.5. 角色管理</h2><h3 id="1-5-1-角色列表"><a href="#1-5-1-角色列表" class="headerlink" title="1.5.1. 角色列表"></a>1.5.1. 角色列表</h3><ul>
<li><p>请求路径：roles</p>
</li>
<li><p>请求方法：get</p>
</li>
<li><p>响应数据说明</p>
<ul>
<li>第一层为角色信息</li>
</ul>
<ul>
<li>第二层开始为权限说明，权限一共有 3 层权限</li>
<li>最后一层权限，不包含 <code>children</code> 属性</li>
</ul>
</li>
<li><p>响应数据</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="attr">"roleName"</span>: <span class="string">"主管"</span>,</span><br><span class="line">            <span class="attr">"roleDesc"</span>: <span class="string">"技术负责人"</span>,</span><br><span class="line">            <span class="attr">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">                    <span class="attr">"authName"</span>: <span class="string">"商品管理"</span>,</span><br><span class="line">                    <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"children"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"id"</span>: <span class="number">104</span>,</span><br><span class="line">                            <span class="attr">"authName"</span>: <span class="string">"商品列表"</span>,</span><br><span class="line">                            <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">"children"</span>: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">"id"</span>: <span class="number">105</span>,</span><br><span class="line">                                    <span class="attr">"authName"</span>: <span class="string">"添加商品"</span>,</span><br><span class="line">                                    <span class="attr">"path"</span>: <span class="literal">null</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-添加角色"><a href="#1-5-2-添加角色" class="headerlink" title="1.5.2. 添加角色"></a>1.5.2. 添加角色</h3><ul>
<li>请求路径：roles</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>roleName</td>
<td>角色名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>roleDesc</td>
<td>角色描述</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>roleId</td>
<td>角色 ID</td>
<td></td>
</tr>
<tr>
<td>roleName</td>
<td>角色名称</td>
<td></td>
</tr>
<tr>
<td>roleDesc</td>
<td>角色描述</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"roleId"</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">"roleName"</span>: <span class="string">"admin2"</span>,</span><br><span class="line">        <span class="attr">"roleDesc"</span>: <span class="string">"admin2Desc"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-根据-ID-查询角色"><a href="#1-5-3-根据-ID-查询角色" class="headerlink" title="1.5.3. 根据 ID 查询角色"></a>1.5.3. 根据 ID 查询角色</h3><ul>
<li>请求路径：roles/:id</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>角色 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>roleId</td>
<td>角色 ID</td>
<td></td>
</tr>
<tr>
<td>roleName</td>
<td>角色名称</td>
<td></td>
</tr>
<tr>
<td>roleDesc</td>
<td>角色描述</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"roleId"</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="attr">"roleName"</span>: <span class="string">"测试角色"</span>,</span><br><span class="line">        <span class="attr">"roleDesc"</span>: <span class="string">"测试负责人"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-编辑提交角色"><a href="#1-5-4-编辑提交角色" class="headerlink" title="1.5.4. 编辑提交角色"></a>1.5.4. 编辑提交角色</h3><ul>
<li>请求路径：roles/:id</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>角色 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>roleName</td>
<td>角色名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>roleDesc</td>
<td>角色描述</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"roleId"</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="attr">"roleName"</span>: <span class="string">"测试角色"</span>,</span><br><span class="line">        <span class="attr">"roleDesc"</span>: <span class="string">"测试角色描述"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-5-删除角色"><a href="#1-5-5-删除角色" class="headerlink" title="1.5.5. 删除角色"></a>1.5.5. 删除角色</h3><ul>
<li>请求路径：roles/:id</li>
<li>请求方法：delete</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>角色 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"删除成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-6-角色授权"><a href="#1-5-6-角色授权" class="headerlink" title="1.5.6. 角色授权"></a>1.5.6. 角色授权</h3><ul>
<li>请求路径：roles/:roleId/rights</li>
<li>请求方法：post</li>
<li>请求参数：通过 <code>请求体</code> 发送给后端</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:roleId</td>
<td>角色 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>rids</td>
<td>权限 ID 列表（字符串）</td>
<td>以 <code>,</code> 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点）</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-7-删除角色指定权限"><a href="#1-5-7-删除角色指定权限" class="headerlink" title="1.5.7. 删除角色指定权限"></a>1.5.7. 删除角色指定权限</h3><ul>
<li><p>请求路径：roles/:roleId/rights/:rightId</p>
</li>
<li><p>请求方法：delete</p>
</li>
<li><p>请求参数</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:roleId</td>
<td>角色 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>:rightId</td>
<td>权限 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
</li>
<li><p>响应数据说明 </p>
<ul>
<li>返回的data, 是当前角色下最新的权限数据</li>
</ul>
</li>
<li><p>响应数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">"authName"</span>: <span class="string">"商品管理"</span>,</span><br><span class="line">            <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"id"</span>: <span class="number">104</span>,</span><br><span class="line">                    <span class="attr">"authName"</span>: <span class="string">"商品列表"</span>,</span><br><span class="line">                    <span class="attr">"path"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"children"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"id"</span>: <span class="number">105</span>,</span><br><span class="line">                            <span class="attr">"authName"</span>: <span class="string">"添加商品"</span>,</span><br><span class="line">                            <span class="attr">"path"</span>: <span class="literal">null</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"id"</span>: <span class="number">116</span>,</span><br><span class="line">                            <span class="attr">"authName"</span>: <span class="string">"修改"</span>,</span><br><span class="line">                            <span class="attr">"path"</span>: <span class="literal">null</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"取消权限成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-6-商品分类管理"><a href="#1-6-商品分类管理" class="headerlink" title="1.6. 商品分类管理"></a>1.6. 商品分类管理</h2><h3 id="1-6-1-商品分类数据列表"><a href="#1-6-1-商品分类数据列表" class="headerlink" title="1.6.1. 商品分类数据列表"></a>1.6.1. 商品分类数据列表</h3><ul>
<li>请求路径：categories</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>[1,2,3]</td>
<td>值：1，2，3 分别表示显示一层二层三层分类列表<br />【可选参数】如果不传递，则默认获取所有级别的分类</td>
</tr>
<tr>
<td>pagenum</td>
<td>当前页码值</td>
<td>【可选参数】如果不传递，则默认获取所有分类</td>
</tr>
<tr>
<td>pagesize</td>
<td>每页显示多少条数据</td>
<td>【可选参数】如果不传递，则默认获取所有分类</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>cat_id</td>
<td>分类 ID</td>
<td></td>
</tr>
<tr>
<td>cat_name</td>
<td>分类名称</td>
<td></td>
</tr>
<tr>
<td>cat_pid</td>
<td>分类父 ID</td>
<td></td>
</tr>
<tr>
<td>cat_level</td>
<td>分类当前层级</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cat_id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"cat_name"</span>: <span class="string">"大家电"</span>,</span><br><span class="line">            <span class="attr">"cat_pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"cat_level"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"cat_deleted"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"cat_id"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"cat_name"</span>: <span class="string">"电视"</span>,</span><br><span class="line">                    <span class="attr">"cat_pid"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"cat_level"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"cat_deleted"</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">"children"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"cat_id"</span>: <span class="number">6</span>,</span><br><span class="line">                            <span class="attr">"cat_name"</span>: <span class="string">"曲面电视"</span>,</span><br><span class="line">                            <span class="attr">"cat_pid"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"cat_level"</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">"cat_deleted"</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"cat_id"</span>: <span class="number">7</span>,</span><br><span class="line">                            <span class="attr">"cat_name"</span>: <span class="string">"海信"</span>,</span><br><span class="line">                            <span class="attr">"cat_pid"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"cat_level"</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">"cat_deleted"</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-添加分类"><a href="#1-6-2-添加分类" class="headerlink" title="1.6.2. 添加分类"></a>1.6.2. 添加分类</h3><ul>
<li>请求路径：categories</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>cat_pid</td>
<td>分类父 ID</td>
<td>不能为空，如果要添加1级分类，则父分类Id应该设置为  <code>0</code></td>
</tr>
<tr>
<td>cat_name</td>
<td>分类名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>cat_level</td>
<td>分类层级</td>
<td>不能为空，<code>0</code>表示一级分类；<code>1</code>表示二级分类；<code>2</code>表示三级分类</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="number">62</span>,</span><br><span class="line">        <span class="attr">"cat_name"</span>: <span class="string">"相框"</span>,</span><br><span class="line">        <span class="attr">"cat_pid"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"cat_level"</span>: <span class="string">"1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-根据-id-查询分类"><a href="#1-6-3-根据-id-查询分类" class="headerlink" title="1.6.3. 根据 id 查询分类"></a>1.6.3. 根据 id 查询分类</h3><ul>
<li>请求路径：categories/:id</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"cat_name"</span>: <span class="string">"厨卫电器"</span>,</span><br><span class="line">        <span class="attr">"cat_pid"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"cat_level"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-4-编辑提交分类"><a href="#1-6-4-编辑提交分类" class="headerlink" title="1.6.4. 编辑提交分类"></a>1.6.4. 编辑提交分类</h3><ul>
<li>请求路径：categories/:id</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>cat_name</td>
<td>分类名称</td>
<td>不能为空【此参数，放到请求体中】</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"cat_name"</span>: <span class="string">"自拍杆"</span>,</span><br><span class="line">        <span class="attr">"cat_pid"</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="attr">"cat_level"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-5-删除分类"><a href="#1-6-5-删除分类" class="headerlink" title="1.6.5. 删除分类"></a>1.6.5. 删除分类</h3><ul>
<li>请求路径：categories/:id</li>
<li>请求方法：delete</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"删除成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-分类参数管理"><a href="#1-7-分类参数管理" class="headerlink" title="1.7. 分类参数管理"></a>1.7. 分类参数管理</h2><h3 id="1-7-1-参数列表"><a href="#1-7-1-参数列表" class="headerlink" title="1.7.1. 参数列表"></a>1.7.1. 参数列表</h3><ul>
<li>请求路径：categories/:id/attributes</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>sel</td>
<td>[only,many]</td>
<td>不能为空,通过 only 或 many 来获取分类静态参数还是动态参数</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>attr_id</td>
<td>分类参数 ID</td>
<td></td>
</tr>
<tr>
<td>attr_name</td>
<td>分类参数名称</td>
<td></td>
</tr>
<tr>
<td>cat_id</td>
<td>分类参数所属分类</td>
<td></td>
</tr>
<tr>
<td>attr_sel</td>
<td>only:输入框(唯一) many:后台下拉列表/前台单选框</td>
<td></td>
</tr>
<tr>
<td>attr_write</td>
<td>manual:手工录入 list:从列表选择</td>
<td></td>
</tr>
<tr>
<td>attr_vals</td>
<td>如果 attr_write:list,那么有值，该值以逗号分隔</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"attr_id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"attr_name"</span>: <span class="string">"cpu"</span>,</span><br><span class="line">            <span class="attr">"cat_id"</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">"attr_sel"</span>: <span class="string">"only"</span>,</span><br><span class="line">            <span class="attr">"attr_write"</span>: <span class="string">"manual"</span>,</span><br><span class="line">            <span class="attr">"attr_vals"</span>: <span class="string">"ffff"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-2-添加动态参数或者静态属性"><a href="#1-7-2-添加动态参数或者静态属性" class="headerlink" title="1.7.2. 添加动态参数或者静态属性"></a>1.7.2. 添加动态参数或者静态属性</h3><ul>
<li>请求路径：categories/:id/attributes</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>attr_name</td>
<td>参数名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>attr_sel</td>
<td>[only,many]</td>
<td>不能为空</td>
</tr>
<tr>
<td>attr_vals</td>
<td>如果是 many 就需要填写值的选项，以逗号分隔</td>
<td>【可选参数】</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"attr_id"</span>: <span class="number">44</span>,</span><br><span class="line">        <span class="attr">"attr_name"</span>: <span class="string">"测试参数"</span>,</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">        <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">        <span class="attr">"attr_vals"</span>: <span class="string">"a,b,c"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-删除参数"><a href="#1-7-3-删除参数" class="headerlink" title="1.7.3. 删除参数"></a>1.7.3. 删除参数</h3><ul>
<li>请求路径： categories/:id/attributes/:attrid</li>
<li>请求方法：delete</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>:attrid</td>
<td>参数 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"删除成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-4-根据-ID-查询参数"><a href="#1-7-4-根据-ID-查询参数" class="headerlink" title="1.7.4. 根据 ID 查询参数"></a>1.7.4. 根据 ID 查询参数</h3><ul>
<li>请求路径：categories/:id/attributes/:attrId</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>:attrId</td>
<td>属性 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>attr_sel</td>
<td>[only,many]</td>
<td>不能为空</td>
</tr>
<tr>
<td>attr_vals</td>
<td>如果是 many 就需要填写值的选项，以逗号分隔</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"attr_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"attr_name"</span>: <span class="string">"cpu"</span>,</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"attr_sel"</span>: <span class="string">"only"</span>,</span><br><span class="line">        <span class="attr">"attr_write"</span>: <span class="string">"manual"</span>,</span><br><span class="line">        <span class="attr">"attr_vals"</span>: <span class="string">"ffff"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-5-编辑提交参数"><a href="#1-7-5-编辑提交参数" class="headerlink" title="1.7.5. 编辑提交参数"></a>1.7.5. 编辑提交参数</h3><ul>
<li>请求路径：categories/:id/attributes/:attrId</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>:id</td>
<td>分类 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>:attrId</td>
<td>属性 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>attr_name</td>
<td>新属性的名字</td>
<td>不能为空，携带在<code>请求体</code>中</td>
</tr>
<tr>
<td>attr_sel</td>
<td>属性的类型[many或only]</td>
<td>不能为空，携带在<code>请求体</code>中</td>
</tr>
<tr>
<td>attr_vals</td>
<td>参数的属性值</td>
<td>可选参数，携带在<code>请求体</code>中</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"attr_id"</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="attr">"attr_name"</span>: <span class="string">"测试更新"</span>,</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="string">"43"</span>,</span><br><span class="line">        <span class="attr">"attr_sel"</span>: <span class="string">"only"</span>,</span><br><span class="line">        <span class="attr">"attr_write"</span>: <span class="string">"manual"</span>,</span><br><span class="line">        <span class="attr">"attr_vals"</span>: <span class="string">"abc"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-商品管理"><a href="#1-8-商品管理" class="headerlink" title="1.8. 商品管理"></a>1.8. 商品管理</h2><h3 id="1-8-1-商品列表数据"><a href="#1-8-1-商品列表数据" class="headerlink" title="1.8.1. 商品列表数据"></a>1.8.1. 商品列表数据</h3><ul>
<li>请求路径：goods</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>查询参数</td>
<td>可以为空</td>
</tr>
<tr>
<td>pagenum</td>
<td>当前页码</td>
<td>不能为空</td>
</tr>
<tr>
<td>pagesize</td>
<td>每页显示条数</td>
<td>不能为空</td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>总共商品条数</td>
<td></td>
</tr>
<tr>
<td>pagenum</td>
<td>当前商品页数</td>
<td></td>
</tr>
<tr>
<td>goods_id</td>
<td>商品 ID</td>
<td></td>
</tr>
<tr>
<td>goods_name</td>
<td>商品名称</td>
<td></td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td></td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_state</td>
<td>商品状态</td>
<td>商品状态 0: 未通过 1: 审核中 2: 已审核</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td></td>
</tr>
<tr>
<td>upd_time</td>
<td>更新时间</td>
<td></td>
</tr>
<tr>
<td>hot_mumber</td>
<td>热销品数量</td>
<td></td>
</tr>
<tr>
<td>is_promote</td>
<td>是否是热销品</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">"pagenum"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"goods"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">144</span>,</span><br><span class="line">                <span class="attr">"goods_name"</span>: <span class="string">"asfdsd"</span>,</span><br><span class="line">                <span class="attr">"goods_price"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"goods_number"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"goods_weight"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"goods_state"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"add_time"</span>: <span class="number">1512954923</span>,</span><br><span class="line">                <span class="attr">"upd_time"</span>: <span class="number">1512954923</span>,</span><br><span class="line">                <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"is_promote"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-2-添加商品"><a href="#1-8-2-添加商品" class="headerlink" title="1.8.2. 添加商品"></a>1.8.2. 添加商品</h3><ul>
<li>请求路径：goods</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>goods_name</td>
<td>商品名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_cat</td>
<td>以为’,’分割的分类列表</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_introduce</td>
<td>介绍</td>
<td>可以为空</td>
</tr>
<tr>
<td>pics</td>
<td>上传的图片临时路径（对象）</td>
<td>可以为空</td>
</tr>
<tr>
<td>attrs</td>
<td>商品的参数（数组），包含 <code>动态参数</code> 和 <code>静态属性</code></td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>请求数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"goods_name"</span>:<span class="string">"test_goods_name2"</span>,</span><br><span class="line">  <span class="attr">"goods_cat"</span>: <span class="string">"1,2,3"</span>,</span><br><span class="line">  <span class="attr">"goods_price"</span>:<span class="number">20</span>,</span><br><span class="line">  <span class="attr">"goods_number"</span>:<span class="number">30</span>,</span><br><span class="line">  <span class="attr">"goods_weight"</span>:<span class="number">40</span>,</span><br><span class="line">  <span class="attr">"goods_introduce"</span>:<span class="string">"abc"</span>,</span><br><span class="line">  <span class="attr">"pics"</span>:[</span><br><span class="line">    &#123;<span class="attr">"pic"</span>:<span class="string">"/tmp_uploads/30f08d52c551ecb447277eae232304b8"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">"attrs"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"attr_id"</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">"attr_value"</span>:<span class="string">"ddd"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"attr_id"</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">"attr_value"</span>:<span class="string">"eee"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>总共商品条数</td>
<td></td>
</tr>
<tr>
<td>pagenum</td>
<td>当前商品页数</td>
<td></td>
</tr>
<tr>
<td>goods_id</td>
<td>商品 ID</td>
<td></td>
</tr>
<tr>
<td>goods_cat</td>
<td>以为’,’分割的分类列表</td>
<td></td>
</tr>
<tr>
<td>goods_name</td>
<td>商品名称</td>
<td></td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td></td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_state</td>
<td>商品状态</td>
<td>商品状态 0: 未通过 1: 审核中 2: 已审核</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td></td>
</tr>
<tr>
<td>upd_time</td>
<td>更新时间</td>
<td></td>
</tr>
<tr>
<td>hot_mumber</td>
<td>热销品数量</td>
<td></td>
</tr>
<tr>
<td>is_promote</td>
<td>是否是热销品</td>
<td></td>
</tr>
<tr>
<td>pics</td>
<td>上传的图片临时路径（对象）</td>
<td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td>
</tr>
<tr>
<td>attrs</td>
<td>商品的参数（数组）</td>
<td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"test_goods_name2"</span>,</span><br><span class="line">        <span class="attr">"goods_price"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"cat_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"goods_number"</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="attr">"goods_weight"</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">"goods_introduce"</span>: <span class="string">"abc"</span>,</span><br><span class="line">        <span class="attr">"goods_big_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_small_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_state"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"add_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"upd_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_promote"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pics_id"</span>: <span class="number">397</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"pics_big"</span>: <span class="string">"uploads/goodspics/big_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_mid"</span>: <span class="string">"uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_sma"</span>: <span class="string">"uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"attrs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"ddd"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"eee"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建商品成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-根据-ID-查询商品"><a href="#1-8-3-根据-ID-查询商品" class="headerlink" title="1.8.3. 根据 ID 查询商品"></a>1.8.3. 根据 ID 查询商品</h3><ul>
<li>请求路径：goods/:id</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>商品 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>总共商品条数</td>
<td></td>
</tr>
<tr>
<td>pagenum</td>
<td>当前商品页数</td>
<td></td>
</tr>
<tr>
<td>goods_id</td>
<td>商品 ID</td>
<td></td>
</tr>
<tr>
<td>goods_name</td>
<td>商品名称</td>
<td></td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td></td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_state</td>
<td>商品状态</td>
<td>商品状态 0: 未通过 1: 审核中 2: 已审核</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td></td>
</tr>
<tr>
<td>upd_time</td>
<td>更新时间</td>
<td></td>
</tr>
<tr>
<td>hot_mumber</td>
<td>热销品数量</td>
<td></td>
</tr>
<tr>
<td>is_promote</td>
<td>是否是热销品</td>
<td></td>
</tr>
<tr>
<td>pics</td>
<td>上传的图片临时路径（对象）</td>
<td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td>
</tr>
<tr>
<td>attrs</td>
<td>商品的参数（数组）</td>
<td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"test_goods_name2"</span>,</span><br><span class="line">        <span class="attr">"goods_price"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"goods_number"</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="attr">"goods_weight"</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">"goods_introduce"</span>: <span class="string">"abc"</span>,</span><br><span class="line">        <span class="attr">"goods_big_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_small_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_state"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"add_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"upd_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_promote"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pics_id"</span>: <span class="number">397</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"pics_big"</span>: <span class="string">"uploads/goodspics/big_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_mid"</span>: <span class="string">"uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_sma"</span>: <span class="string">"uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"attrs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"ddd"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"eee"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建商品成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-4-编辑提交商品"><a href="#1-8-4-编辑提交商品" class="headerlink" title="1.8.4. 编辑提交商品"></a>1.8.4. 编辑提交商品</h3><ul>
<li>请求路径：goods/:id</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>商品 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>goods_name</td>
<td>商品名称</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_introduce</td>
<td>介绍</td>
<td>可以为空</td>
</tr>
<tr>
<td>pics</td>
<td>上传的图片临时路径（对象）</td>
<td>可以为空</td>
</tr>
<tr>
<td>attrs</td>
<td>商品的参数（数组）</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>请求数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"goods_name"</span>:<span class="string">"test_goods_name2"</span>,</span><br><span class="line">  <span class="attr">"goods_price"</span>:<span class="number">20</span>,</span><br><span class="line">  <span class="attr">"goods_number"</span>:<span class="number">30</span>,</span><br><span class="line">  <span class="attr">"goods_weight"</span>:<span class="number">40</span>,</span><br><span class="line">  <span class="attr">"goods_introduce"</span>:<span class="string">"abc"</span>,</span><br><span class="line">  <span class="attr">"pics"</span>:[</span><br><span class="line">    &#123;<span class="attr">"pic"</span>:<span class="string">"/tmp_uploads/30f08d52c551ecb447277eae232304b8"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">"attrs"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"attr_id"</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">"attr_value"</span>:<span class="string">"ddd"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"attr_id"</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">"attr_value"</span>:<span class="string">"eee"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>总共商品条数</td>
<td></td>
</tr>
<tr>
<td>pagenum</td>
<td>当前商品页数</td>
<td></td>
</tr>
<tr>
<td>goods_id</td>
<td>商品 ID</td>
<td></td>
</tr>
<tr>
<td>goods_name</td>
<td>商品名称</td>
<td></td>
</tr>
<tr>
<td>goods_price</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>goods_number</td>
<td>数量</td>
<td></td>
</tr>
<tr>
<td>goods_weight</td>
<td>重量</td>
<td>不能为空</td>
</tr>
<tr>
<td>goods_state</td>
<td>商品状态</td>
<td>商品状态 0: 未通过 1: 审核中 2: 已审核</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td></td>
</tr>
<tr>
<td>upd_time</td>
<td>更新时间</td>
<td></td>
</tr>
<tr>
<td>hot_mumber</td>
<td>热销品数量</td>
<td></td>
</tr>
<tr>
<td>is_promote</td>
<td>是否是热销品</td>
<td></td>
</tr>
<tr>
<td>pics</td>
<td>上传的图片临时路径（对象）</td>
<td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td>
</tr>
<tr>
<td>attrs</td>
<td>商品的参数（数组）</td>
<td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"test_goods_name2"</span>,</span><br><span class="line">        <span class="attr">"goods_price"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"goods_number"</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="attr">"goods_weight"</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">"goods_introduce"</span>: <span class="string">"abc"</span>,</span><br><span class="line">        <span class="attr">"goods_big_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_small_logo"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"goods_state"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"add_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"upd_time"</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_promote"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pics_id"</span>: <span class="number">397</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"pics_big"</span>: <span class="string">"uploads/goodspics/big_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_mid"</span>: <span class="string">"uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8"</span>,</span><br><span class="line">                <span class="attr">"pics_sma"</span>: <span class="string">"uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"attrs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"ddd"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"eee"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"创建商品成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-5-删除商品"><a href="#1-8-5-删除商品" class="headerlink" title="1.8.5. 删除商品"></a>1.8.5. 删除商品</h3><ul>
<li>请求路径：goods/:id</li>
<li>请求方法：delete</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>商品 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"删除成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###同步商品图片</p>
<ul>
<li>请求路径：goods/:id/pics</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>商品 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>pics</td>
<td>商品图片集合</td>
<td>如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据</td>
</tr>
</tbody></table>
<ul>
<li>请求数据</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; pic: 'tmp_uploads/db28f<span class="number">6316835836</span>e<span class="number">9765</span>3b5c75e418be.png' &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    pics_id: <span class="number">397</span>,</span><br><span class="line">    goods_id: <span class="number">145</span>,</span><br><span class="line">    pics_big: 'uploads/goodspics/big_30f08d52c551ecb<span class="number">447277</span>eae<span class="number">232304</span>b8',</span><br><span class="line">    pics_mid: 'uploads/goodspics/mid_30f08d52c551ecb<span class="number">447277</span>eae<span class="number">232304</span>b8',</span><br><span class="line">    pics_sma: 'uploads/goodspics/sma_30f08d52c551ecb<span class="number">447277</span>eae<span class="number">232304</span>b8'</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"iphoneXX"</span>,</span><br><span class="line">        <span class="attr">"goods_price"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"goods_number"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"goods_weight"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"goods_introduce"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"goods_big_logo"</span>: <span class="string">"./uploads/goods/20171113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg"</span>,</span><br><span class="line">        <span class="attr">"goods_small_logo"</span>: <span class="string">"./uploads/goods/20171113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg"</span>,</span><br><span class="line">        <span class="attr">"goods_state"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_del"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"add_time"</span>: <span class="number">1510045904</span>,</span><br><span class="line">        <span class="attr">"upd_time"</span>: <span class="number">1512635159</span>,</span><br><span class="line">        <span class="attr">"delete_time"</span>: <span class="number">1512635159</span>,</span><br><span class="line">        <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_promote"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pics_id"</span>: <span class="number">383</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"pics_big"</span>: <span class="string">"uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg"</span>,</span><br><span class="line">                <span class="attr">"pics_mid"</span>: <span class="string">"uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg"</span>,</span><br><span class="line">                <span class="attr">"pics_sma"</span>: <span class="string">"uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"attrs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"eee"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"ddd"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###同步商品属性</p>
<ul>
<li>请求路径：goods/:id/attributes</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>商品 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>请求数据</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">;[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">attr_id:</span> <span class="number">15</span><span class="string">,</span></span><br><span class="line">    <span class="attr">attr_value:</span> <span class="string">'ddd'</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">attr_id:</span> <span class="number">15</span><span class="string">,</span></span><br><span class="line">    <span class="attr">attr_value:</span> <span class="string">'eee'</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"iphoneXX"</span>,</span><br><span class="line">        <span class="attr">"goods_price"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"goods_number"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"goods_weight"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"goods_introduce"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"goods_big_logo"</span>: <span class="string">"./uploads/goods/20171113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg"</span>,</span><br><span class="line">        <span class="attr">"goods_small_logo"</span>: <span class="string">"./uploads/goods/20171113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg"</span>,</span><br><span class="line">        <span class="attr">"goods_state"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_del"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"add_time"</span>: <span class="number">1510045904</span>,</span><br><span class="line">        <span class="attr">"upd_time"</span>: <span class="number">1512635159</span>,</span><br><span class="line">        <span class="attr">"delete_time"</span>: <span class="number">1512635159</span>,</span><br><span class="line">        <span class="attr">"hot_mumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"is_promote"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pics_id"</span>: <span class="number">383</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"pics_big"</span>: <span class="string">"uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg"</span>,</span><br><span class="line">                <span class="attr">"pics_mid"</span>: <span class="string">"uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg"</span>,</span><br><span class="line">                <span class="attr">"pics_sma"</span>: <span class="string">"uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"attrs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"eee"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"attr_id"</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">"attr_value"</span>: <span class="string">"ddd"</span>,</span><br><span class="line">                <span class="attr">"add_price"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"attr_name"</span>: <span class="string">"fffffff"</span>,</span><br><span class="line">                <span class="attr">"attr_sel"</span>: <span class="string">"many"</span>,</span><br><span class="line">                <span class="attr">"attr_write"</span>: <span class="string">"list"</span>,</span><br><span class="line">                <span class="attr">"attr_vals"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"更新成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###商品图片处理必须安装 GraphicsMagick</p>
<ul>
<li>linux</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install GraphicsMagick</span><br></pre></td></tr></table></figure>

<ul>
<li>Mac OS X</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>GraphicsMagick</span><br></pre></td></tr></table></figure>

<ul>
<li>Windows <a href="https://sourceforge.net/projects/graphicsmagick/files/graphicsmagick-binaries/1.3.27/GraphicsMagick-1.3.27-Q8-win64-dll.exe/download" target="_blank" rel="noopener">点击下载</a></li>
</ul>
<h2 id="1-9-图片上传"><a href="#1-9-图片上传" class="headerlink" title="1.9. 图片上传"></a>1.9. 图片上传</h2><ul>
<li>请求路径：upload</li>
<li>请求方法：post</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td>上传文件</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"tmp_path"</span>: <span class="string">"tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:8888tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"上传成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-订单管理"><a href="#1-10-订单管理" class="headerlink" title="1.10. 订单管理"></a>1.10. 订单管理</h2><h3 id="1-10-1-订单数据列表"><a href="#1-10-1-订单数据列表" class="headerlink" title="1.10.1. 订单数据列表"></a>1.10.1. 订单数据列表</h3><ul>
<li>请求路径：orders</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>查询参数</td>
<td>可以为空</td>
</tr>
<tr>
<td>pagenum</td>
<td>当前页码</td>
<td>不能为空</td>
</tr>
<tr>
<td>pagesize</td>
<td>每页显示条数</td>
<td>不能为空</td>
</tr>
<tr>
<td>user_id</td>
<td>用户 ID</td>
<td>可以为空</td>
</tr>
<tr>
<td>pay_status</td>
<td>支付状态</td>
<td>可以为空</td>
</tr>
<tr>
<td>is_send</td>
<td>是否发货</td>
<td>可以为空</td>
</tr>
<tr>
<td>order_fapiao_title</td>
<td>[‘个人’,’公司’]</td>
<td>可以为空</td>
</tr>
<tr>
<td>order_fapiao_company</td>
<td>公司名称</td>
<td>可以为空</td>
</tr>
<tr>
<td>order_fapiao_content</td>
<td>发票内容</td>
<td>可以为空</td>
</tr>
<tr>
<td>consignee_addr</td>
<td>发货地址</td>
<td>可以为空</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"pagenum"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"goods"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"order_id"</span>: <span class="number">47</span>,</span><br><span class="line">                <span class="attr">"user_id"</span>: <span class="number">133</span>,</span><br><span class="line">                <span class="attr">"order_number"</span>: <span class="string">"itcast-59e7502d7993d"</span>,</span><br><span class="line">                <span class="attr">"order_price"</span>: <span class="number">322</span>,</span><br><span class="line">                <span class="attr">"order_pay"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"is_send"</span>: <span class="string">"是"</span>,</span><br><span class="line">                <span class="attr">"trade_no"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"order_fapiao_title"</span>: <span class="string">"个人"</span>,</span><br><span class="line">                <span class="attr">"order_fapiao_company"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"order_fapiao_content"</span>: <span class="string">"办公用品"</span>,</span><br><span class="line">                <span class="attr">"consignee_addr"</span>: <span class="string">"a:7:&#123;s:6:\"cgn_id\";i:1;s:7:\"user_id\";i:133;s:8:\"cgn_name\";s:9:\"王二柱\";s:11:\"cgn_address\";s:51:\"北京市海淀区苏州街长远天地大厦305室\";s:7:\"cgn_tel\";s:11:\"13566771298\";s:8:\"cgn_code\";s:6:\"306810\";s:11:\"delete_time\";N;&#125;"</span>,</span><br><span class="line">                <span class="attr">"pay_status"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"create_time"</span>: <span class="number">1508331565</span>,</span><br><span class="line">                <span class="attr">"update_time"</span>: <span class="number">1508331565</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-2-修改订单状态"><a href="#1-10-2-修改订单状态" class="headerlink" title="1.10.2. 修改订单状态"></a>1.10.2. 修改订单状态</h3><ul>
<li>请求路径：orders/:id</li>
<li>请求方法：put</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>订单 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
<tr>
<td>is_send</td>
<td>订单是否发货</td>
<td>1:已经发货，0:未发货</td>
</tr>
<tr>
<td>order_pay</td>
<td>订单支付</td>
<td>支付方式 0 未支付 1 支付宝 2 微信 3 银行卡</td>
</tr>
<tr>
<td>order_price</td>
<td>订单价格</td>
<td></td>
</tr>
<tr>
<td>order_number</td>
<td>订单数量</td>
<td></td>
</tr>
<tr>
<td>pay_status</td>
<td>支付状态</td>
<td>订单状态： 0 未付款、1 已付款</td>
</tr>
</tbody></table>
<ul>
<li>请求数据说明<ul>
<li>所有请求数据都是增量更新，如果参数不填写，就不会更新该字段</li>
</ul>
</li>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"order_number"</span>: <span class="string">"itcast-g7kmck71vjaujfgoi"</span>,</span><br><span class="line">        <span class="attr">"order_price"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"order_pay"</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="attr">"is_send"</span>: <span class="string">"否"</span>,</span><br><span class="line">        <span class="attr">"trade_no"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_title"</span>: <span class="string">"个人"</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_company"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_content"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"consignee_addr"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"pay_status"</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="attr">"create_time"</span>: <span class="number">1512533560</span>,</span><br><span class="line">        <span class="attr">"update_time"</span>: <span class="number">1512533560</span>,</span><br><span class="line">        <span class="attr">"goods"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">82</span>,</span><br><span class="line">                <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"goods_price"</span>: <span class="number">333</span>,</span><br><span class="line">                <span class="attr">"goods_number"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"goods_total_price"</span>: <span class="number">999</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">83</span>,</span><br><span class="line">                <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">"goods_price"</span>: <span class="number">666</span>,</span><br><span class="line">                <span class="attr">"goods_number"</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">"goods_total_price"</span>: <span class="number">999</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-3-查看订单详情"><a href="#1-10-3-查看订单详情" class="headerlink" title="1.10.3. 查看订单详情"></a>1.10.3. 查看订单详情</h3><ul>
<li>请求路径：orders/:id</li>
<li>请求方法：get</li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>订单 ID</td>
<td>不能为空<code>携带在url中</code></td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"order_number"</span>: <span class="string">"itcast-g7kmck71vjaujfgoi"</span>,</span><br><span class="line">        <span class="attr">"order_price"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"order_pay"</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="attr">"is_send"</span>: <span class="string">"否"</span>,</span><br><span class="line">        <span class="attr">"trade_no"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_title"</span>: <span class="string">"个人"</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_company"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"order_fapiao_content"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"consignee_addr"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"pay_status"</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="attr">"create_time"</span>: <span class="number">1512533560</span>,</span><br><span class="line">        <span class="attr">"update_time"</span>: <span class="number">1512533560</span>,</span><br><span class="line">        <span class="attr">"goods"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">82</span>,</span><br><span class="line">                <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">96</span>,</span><br><span class="line">                <span class="attr">"goods_price"</span>: <span class="number">333</span>,</span><br><span class="line">                <span class="attr">"goods_number"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"goods_total_price"</span>: <span class="number">999</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">83</span>,</span><br><span class="line">                <span class="attr">"order_id"</span>: <span class="number">67</span>,</span><br><span class="line">                <span class="attr">"goods_id"</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">"goods_price"</span>: <span class="number">666</span>,</span><br><span class="line">                <span class="attr">"goods_number"</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">"goods_total_price"</span>: <span class="number">999</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-10-4-修改地址"><a href="#1-10-4-修改地址" class="headerlink" title="1.10.4. 修改地址"></a>1.10.4. 修改地址</h3><ol>
<li><a href="https://github.com/iceyangcc/provinces-china" target="_blank" rel="noopener">省市区/县联动效果 - 结合ElementUI的 el-cascader 组件</a></li>
</ol>
<h3 id="1-10-5-查看物流信息"><a href="#1-10-5-查看物流信息" class="headerlink" title="1.10.5. 查看物流信息"></a>1.10.5. 查看物流信息</h3><ul>
<li><p>请求路径：/kuaidi/:id</p>
</li>
<li><p>请求方法：get</p>
</li>
<li><p>供测试的物流单号：1106975712662</p>
</li>
<li><p>响应数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-10 09:39:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-10 09:39:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"已签收,感谢使用顺丰,期待再次为您服务"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-10 08:23:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-10 08:23:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"[北京市]北京海淀育新小区营业点派件员 顺丰速运 95338正在为您派件"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-10 07:32:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-10 07:32:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"快件到达 [北京海淀育新小区营业点]"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-10 02:03:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-10 02:03:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"快件在[北京顺义集散中心]已装车,准备发往 [北京海淀育新小区营业点]"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-09 23:05:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-09 23:05:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"快件到达 [北京顺义集散中心]"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-09 21:21:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-09 21:21:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"快件在[北京宝胜营业点]已装车,准备发往 [北京顺义集散中心]"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-09 13:07:00"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-09 13:07:00"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"顺丰速运 已收取快件"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-09 12:25:03"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-09 12:25:03"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"卖家发货"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-09 12:22:24"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-09 12:22:24"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"您的订单将由HLA（北京海淀区清河中街店）门店安排发货。"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"time"</span>: <span class="string">"2018-05-08 21:36:04"</span>,</span><br><span class="line">      <span class="attr">"ftime"</span>: <span class="string">"2018-05-08 21:36:04"</span>,</span><br><span class="line">      <span class="attr">"context"</span>: <span class="string">"商品已经下单"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"meta"</span>: &#123; <span class="attr">"status"</span>: <span class="number">200</span>, <span class="attr">"message"</span>: <span class="string">"获取物流信息成功！"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="1-11-数据统计"><a href="#1-11-数据统计" class="headerlink" title="1.11. 数据统计"></a>1.11. 数据统计</h2><h3 id="1-11-1-基于时间统计的折线图"><a href="#1-11-1-基于时间统计的折线图" class="headerlink" title="1.11.1.  基于时间统计的折线图"></a>1.11.1.  基于时间统计的折线图</h3><ul>
<li><p>请求路径：reports/type/1</p>
</li>
<li><p>请求方法：get</p>
</li>
<li><p>响应数据</p>
</li>
<li><p>需要合并的选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: <span class="string">'用户来源'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">'axis'</span>,</span><br><span class="line">          axisPointer: &#123;</span><br><span class="line">            type: <span class="string">'cross'</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              backgroundColor: <span class="string">'#E9EEF3'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: <span class="string">'3%'</span>,</span><br><span class="line">          right: <span class="string">'4%'</span>,</span><br><span class="line">          bottom: <span class="string">'3%'</span>,</span><br><span class="line">          containLabel: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            boundaryGap: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        yAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: <span class="string">'value'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>API接口文档</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_shop项目构建笔记</title>
    <url>/2020/01/10/vue3-01/</url>
    <content><![CDATA[<h2 id="插件和依赖的区别"><a href="#插件和依赖的区别" class="headerlink" title="插件和依赖的区别"></a>插件和依赖的区别</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>运行时开发时都需要用到的jar包，比如项目中需要一个json的jar包，就需要一个依赖，这个依赖在项目运行时也需要，因此在项目打包时需要把这些依赖也打包进项目里</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>在项目的开发时需要，但是在项目运行时不需要，因此在项目开发完成后就不需要把插件打包进项目中。</p>
<a id="more"></a>

<h2 id="Vue-packages-version-mismatch版本问题的解决"><a href="#Vue-packages-version-mismatch版本问题的解决" class="headerlink" title="Vue packages version mismatch版本问题的解决"></a>Vue packages version mismatch版本问题的解决</h2><p>初始化我的vue_shop项目的时候，出现了以下的错误：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error </span>in .src/components/mobile/SeniorDetail.vue</span><br><span class="line">Module build failed: Error:</span><br><span class="line">Vue packages version mismatch:</span><br><span class="line">vue@2.5.13</span><br><span class="line">vue-template-compiler@2.5.17</span><br></pre></td></tr></table></figure>
<p>根据提示，是版本不匹配的问题，直接将我的本地全局的vue进行更新就好了，也就是直接在终端运行<code>npm i -g vue</code>就完成了vue的升级。</p>
<h2 id="登录-退出功能"><a href="#登录-退出功能" class="headerlink" title="登录/退出功能"></a>登录/退出功能</h2><h3 id="登录业务流程"><a href="#登录业务流程" class="headerlink" title="登录业务流程"></a>登录业务流程</h3><ul>
<li>在登录页面输入用户名和密码</li>
<li>调用后台接口进行验证</li>
<li>通过验证之后，根据后台的响应状态跳转到项目主页</li>
</ul>
<h3 id="登录业务的相关技术点"><a href="#登录业务的相关技术点" class="headerlink" title="登录业务的相关技术点"></a>登录业务的相关技术点</h3><ul>
<li>http是无状态的</li>
<li>通过cookie在客户端记录状态</li>
<li>通过session在服务端记录状态</li>
<li>通过token方式维持状态</li>
</ul>
<p>如果前端和后端不存在跨域问题，推荐只有cookie和session结合的方式，如果前端和服务器之间存在跨域问题推荐使用token方式。</p>
<h4 id="登录–token原理分析"><a href="#登录–token原理分析" class="headerlink" title="登录–token原理分析"></a>登录–token原理分析</h4><ul>
<li>客户端-&gt;服务器：登录页面输入用户名和密码进行登录</li>
<li>服务器-&gt;客户端：服务器验证通过之后生成该用户的token并返回</li>
<li>客户端：存储该token</li>
<li>客户端-&gt;服务器：后续所有的请求都携带该token发送请求</li>
<li>服务器会验证token是否通过</li>
</ul>
<h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul>
<li>通过Element-UI组件实现布局<ul>
<li>el-form</li>
<li>el-form-item</li>
<li>el-input</li>
<li>el-button</li>
<li>字体图标</li>
</ul>
</li>
</ul>
<h3 id="退出功能实现原理"><a href="#退出功能实现原理" class="headerlink" title="退出功能实现原理"></a>退出功能实现原理</h3><p>基于token的方式实现退出比较简单，只需要销毁本地的token即可，这样后续的请求就不会携带token，必须重新登录生成一个新的token之后才可以访问页面。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空token </span></span><br><span class="line"><span class="keyword">window</span>.sessionStorage.<span class="keyword">clear</span>()</span><br><span class="line"><span class="comment">//跳转登录页</span></span><br><span class="line">this.$router.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h3><p>1、换行</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error  </span>Newline required at end of file but not found</span><br></pre></td></tr></table></figure>
<p>原因就是需要在子组件的末尾添加换行。<br>并且在子组件中有一些空行也是不允许的<br>2、出现错误如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Missing <span class="literal">space</span> <span class="keyword">before</span> <span class="function"><span class="keyword">function</span> <span class="title">parentheses</span></span></span><br></pre></td></tr></table></figure>
<p>解决办法：修改项目根目录下.eslintrc.js文件，在rules节点下增加<code>&quot;space-before-function-paren&quot;: 0,</code>,再次运行即可</p>
<h2 id="路由导航首位控制访问权限"><a href="#路由导航首位控制访问权限" class="headerlink" title="路由导航首位控制访问权限"></a>路由导航首位控制访问权限</h2><p>如果用户没有登录，但是直接通过url访问特定页面，需要重新导航到登录页面。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为路由对象，添加beforeEach导航守卫</span></span><br><span class="line">router.beforeEach((to,<span class="keyword">from</span>,<span class="keyword">next</span>) =&gt; &#123;</span><br><span class="line">	<span class="comment">//如果用户访问的登录页直接放行</span></span><br><span class="line">	<span class="keyword">if</span>(to.path === <span class="string">'/login'</span>) <span class="keyword">return</span> <span class="keyword">next</span>()</span><br><span class="line">	<span class="comment">//从sessionStorage中获取到保存的token值</span></span><br><span class="line">	const tokenStr = window.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">	<span class="comment">//没有token，强制跳转到登录页</span></span><br><span class="line">	<span class="keyword">if</span>(!tokenStr) <span class="keyword">return</span> <span class="keyword">next</span>(<span class="string">'/login'</span>)</span><br><span class="line">	<span class="keyword">next</span>()</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function"><span class="params">(to, <span class="keyword">from</span>, <span class="built_in">next</span>)</span> =&gt;</span> &#123;</span><br><span class="line">  // to表示将要访问的路径</span><br><span class="line">  // <span class="keyword">from</span>代表从哪个路径跳转而来</span><br><span class="line">  // <span class="built_in">next</span>是一个函数，表示放行</span><br><span class="line">  // <span class="built_in">next</span>()放行   <span class="built_in">next</span>(<span class="string">'/login'</span>)强制放行</span><br><span class="line">  <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) <span class="keyword">return</span> <span class="built_in">next</span>()</span><br><span class="line">  // 获取token</span><br><span class="line">  const tokenStr = window.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!tokenStr) <span class="keyword">return</span> <span class="built_in">next</span>(<span class="string">'/login'</span>)</span><br><span class="line">  <span class="built_in">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通过接口获取菜单数据"><a href="#通过接口获取菜单数据" class="headerlink" title="通过接口获取菜单数据"></a>通过接口获取菜单数据</h2><p>通过axios请求拦截器添加token，博正拥有获取数据的权限</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios请求拦截，相当于是一个预处理器，预处理这次请求</span></span><br><span class="line">axios<span class="selector-class">.interceptors</span><span class="selector-class">.request</span>.use(config =&gt; &#123;</span><br><span class="line">	<span class="comment">//为请求头对象，添加token验证的authorization字段</span></span><br><span class="line">	config<span class="selector-class">.headers</span><span class="selector-class">.Authorization</span> = window<span class="selector-class">.sessionStorage</span>.getItem(<span class="string">'token'</span>)</span><br><span class="line">	return config</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>需要授权的 API ，必须在请求头中使用 <code>Authorization</code> 字段提供 <code>token</code> 令牌</li>
<li>使用 HTTP Status Code 标识状态</li>
<li>数据返回格式统一使用 JSON</li>
</ul>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限管理业务分析"><a href="#权限管理业务分析" class="headerlink" title="权限管理业务分析"></a>权限管理业务分析</h3><p>通过axios请求拦截器添加token，博正拥有获取数据的权限权限管理模块控制不同的用户可以进行哪些操作，具体可以通过角色的方式进行控制，即每个用户分配一个特定的角色，角色包括不同的功能权限。<br>就是给用户不同的角色，而不同的角色拥有不同的权限，只要一个用户拥有该角色，那么他就拥有该角色对应的权限。</p>
<h3 id="使用elementUI中的cascader插件出现的问题"><a href="#使用elementUI中的cascader插件出现的问题" class="headerlink" title="使用elementUI中的cascader插件出现的问题"></a>使用elementUI中的cascader插件出现的问题</h3><p>步骤跟着视频中的走，但是最后出现的结果就是显示出来的级联选择框出现了空白和高度不够的情况，最后找到的解决办法 就是，在全局的css样式也就是global.css文件中给el-cascader-panel添加高度。最后添加的代码就是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-cascader-panel</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h2><p>商品参数用于显示商品的固定的特征信息，可以通过电商平台商品详情页面直观的看到。</p>
<h2 id="安装配置vue-qill-editor"><a href="#安装配置vue-qill-editor" class="headerlink" title="安装配置vue-qill-editor"></a>安装配置vue-qill-editor</h2><p>这款插件是用来安装在项目中进行网页内富文本编辑</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>vue_shop</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue_shop项目构建笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2--脚手架</title>
    <url>/2020/01/02/vue2-05/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Vue脚手架用于快速生成Vue项目基础架构，其官网为：(<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/</a>) 用于让程序员直接上手写代码，而不用去管项目的配置。相当于省去了哪些配置项目插件的步骤。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>安装3.x的vue脚手架<code>npm install -g @vue/cli</code><ul>
<li>输入<code>vue -V</code>查看是否安装成功</li>
</ul>
</li>
</ul>
<p>创建步骤：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、基于交互式命令行的方式，创建新版vue项目</span></span><br><span class="line">vue create my-project</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、基于图形化界面的方式，创建新版vue项目</span></span><br><span class="line">vue ui</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、基于2.x堵塞旧模板，创建旧版vue项目</span></span><br><span class="line">npm i -g <span class="meta">@vue</span>/cli-<span class="keyword">init</span></span><br><span class="line">vue <span class="keyword">init</span> webpack my-project</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Vue脚手架的自定义配置"><a href="#Vue脚手架的自定义配置" class="headerlink" title="Vue脚手架的自定义配置"></a>Vue脚手架的自定义配置</h3><p>1、通过package.json配置项目，新增的代码如下</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="string">"vue"</span>: &#123;</span><br><span class="line">	<span class="string">"devServer"</span>: &#123;</span><br><span class="line">		<span class="string">"port"</span>: <span class="string">"8888"</span>,</span><br><span class="line">		<span class="string">"open"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>不推荐这种配置方式。因为package.json主要用来管理包的配置信息；为了方便维护，推荐将vue脚手架相关的配置，单独定义到<code>vue.config.js</code>配置文件中。</p>
<p>2、通过单独的配置文件配置项目</p>
<ul>
<li>在项目的根目录创建文件vue.config.js</li>
<li>在该文件中进行相关配置，从而覆盖默认配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="attr">devServer:</span> <span class="string">&#123;</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">8888</span><span class="string">,</span></span><br><span class="line">		<span class="attr">open:</span> <span class="literal">true</span><span class="string">//自动打开浏览器</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a>Element-UI</h2><p>Element-UI是一套为开发者、设计师和产品经理准备的基于Vue2.0的桌面端组件库。官网地址(<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a>) </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="基于命令行方式手动安装"><a href="#基于命令行方式手动安装" class="headerlink" title="基于命令行方式手动安装"></a>基于命令行方式手动安装</h4><ul>
<li>安装依赖包<code>npm i element-ui -S</code></li>
<li>导入Element-UI相关资源<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入组件库</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="comment">//导入组件相关样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="comment">//配置Vue插件</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基于图形化界面自动安装"><a href="#基于图形化界面自动安装" class="headerlink" title="基于图形化界面自动安装"></a>基于图形化界面自动安装</h4><ul>
<li>运行vue ui命令，打开图形化界面</li>
<li>通过Vue项目管理器，进入具体的项目配置面板</li>
<li>点击插件 -&gt; 添加插件，进入插件查询面板</li>
<li>搜索vue-cli-plugin-element并安装</li>
<li>配置插件，实现按需导入，从而减少打包后项目的体积</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2--webpack&amp;&amp;单文件组件</title>
    <url>/2019/12/27/vue2-04/</url>
    <content><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul>
<li>文件依赖关系复杂</li>
<li>静态资源请求效率低</li>
<li>模块化支持并不友好</li>
<li>浏览器对高级js特性兼容程度低</li>
</ul>
<h3 id="在项目中安装webpack"><a href="#在项目中安装webpack" class="headerlink" title="在项目中安装webpack"></a>在项目中安装webpack</h3><ul>
<li>项目初始化：<code>npm init -y</code></li>
<li>运行npm i webpack webpack-cli -D命令，安装webpack相关的包</li>
<li>在项目根目录创建名为webpack.config.js的webpack配置文件</li>
<li>在webpack配置文件中初始化如下基本配置：<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">	mode: <span class="string">'development'</span><span class="comment">//mode用于指定构建模式，该值表示转换出来的代码不会进行压缩和转换，转换时间短一些，如果是production就会对转换出来的代码进行压缩和转换，相对应转换时间长一些</span></span><br><span class="line">	<span class="comment">//开发阶段一般是指定为development，上线了就转换为production</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在package.json文件中配置文件中的scripts节点下，新增dev脚本：<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack"</span> //在script节点下的脚本，可以通过npm <span class="keyword">run</span><span class="bash"> 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在终端中运行<code>npm run dev</code>命令，可以启动webpack进行项目打包</li>
</ul>
<h3 id="配置文件的入口与出口"><a href="#配置文件的入口与出口" class="headerlink" title="配置文件的入口与出口"></a>配置文件的入口与出口</h3><ul>
<li>在webpack的4.x版本中默认约定：打包的入口文件为src -&gt; index.js</li>
<li>打包的输出文件为dist -&gt; main.js</li>
<li>如果需要修改打包的入口与出口，可以在webpack.config.js中新增如下配置信息：<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>) <span class="comment">//导入node.js中专门操作路径的模块</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	entry: path.<span class="built_in">join</span>(<span class="variable">__dirname</span>,<span class="string">'./src/index.js'</span>),<span class="comment">//打包入口文件的路径</span></span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.<span class="built_in">join</span>(<span class="variable">__dirname</span>,<span class="string">'./dist'</span>),<span class="comment">//输出文件的存放路径</span></span><br><span class="line">		filename: <span class="string">'bundle.js'</span><span class="comment">//输出文件的名称</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置自动打包功能"><a href="#配置自动打包功能" class="headerlink" title="配置自动打包功能"></a>配置自动打包功能</h3><ul>
<li>运行npm i webpack-dev-server -D命令，安装支持项目自动打包的工具</li>
<li>修改package.json -&gt; scripts中的dev命令如下：<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span> //scripts下的脚本，可以通过npm <span class="keyword">run</span><span class="bash">执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将src -&gt; index.html中scripts脚本的引用路径修改为”/bundle.js”（打包后的根路径下的js文件的位置）</li>
<li>运行 npm run dev命令，重新进行打包</li>
<li>在浏览器中访问<code>http://localhost:8080</code>地址，查看自动打包效果（是该文件的根目录中的页面）</li>
<li>该方法运行生成的根目录下虚拟的一个存在与虚拟磁盘上的bundle.js文件（不存在物理磁盘上）</li>
<li>所以上述步骤中脚本引用路径修改一定要是在根路径下的任意js文件</li>
</ul>
<p><b>注意：</b></p>
<ul>
<li>webpack-dev-server会启动一个实时打包的http服务器</li>
<li>webpack-dev-server打包生成的输出文件，默认放到了项目根目录，而且是虚拟的、看不见的，没有存在物理磁盘上，但是在运行以后的项目中可以访问到</li>
<li>该方法只是将文件的路径放到了网页上，但是并没有将页面放到页面上</li>
</ul>
<p>直接运行完以后弹出浏览器运行页面：<br>需要配置自动打包的相关参数：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json中的配置</span></span><br><span class="line"><span class="comment">//--open打包完成后项目自动打开浏览器页面</span></span><br><span class="line"><span class="comment">//--host配置ip地址</span></span><br><span class="line"><span class="comment">//--port配置端口</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 8080"</span> <span class="comment">//scripts下的脚本，可以通过npm run执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置html-webpack-plugin生成预览页面"><a href="#配置html-webpack-plugin生成预览页面" class="headerlink" title="配置html-webpack-plugin生成预览页面"></a>配置html-webpack-plugin生成预览页面</h3><p>主要思想：只要把src中的index.html文件放到根目录下面就可以了，只要一进入该文件路径，发现index.html就会直接打开该文件</p>
<ul>
<li>运行<code>npm i html-webpack-plugin -D</code>命令，安装生成预览页面的插件</li>
<li>修改webpack.config.js文件头部区域，添加如下配置信息：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入生成预览页面的插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">	<span class="comment">//创建插件的实例对象</span></span><br><span class="line">	template: <span class="string">'./src/index.html'</span>,<span class="comment">//指定要用到的模板文件</span></span><br><span class="line">	filename: <span class="string">'index.html'</span> <span class="comment">//指定生成的文件名称，该文件存在于内存中，在目录中不显示</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure></li>
<li>修改webpack.config.js文件向外暴露的配置对象，新增如下配置节点：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">	plugins: [ htmlPlugin ]<span class="comment">//plugins数组是webpack打包期间会用到的一些插件列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="webpack加载器"><a href="#webpack加载器" class="headerlink" title="webpack加载器"></a>webpack加载器</h3><p>在实际开发过程中，webpack默认只能打包处理以.js后缀名结尾的模块，其他非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包，否则报错！！</p>
<p>loader、加载器会协助webpack打包处理待定的文件模块，比如：</p>
<ul>
<li>less-loader可以打包处理.less相关的文件</li>
<li>sass-loader可以打包处理.sass相关的文件</li>
<li>url-loader可以打包处理css中与url路径相关的文件</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="打包处理css文件："><a href="#打包处理css文件：" class="headerlink" title="打包处理css文件："></a>打包处理css文件：</h5><ul>
<li>运行npm<code>npm i style-loader css-loader -D</code>命令，安装处理css文件中的loader</li>
<li>在webpack.config.js的module -&gt; rules数组中，添加loader规则如下：<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有第三方模块的匹配规则</span></span><br><span class="line"><span class="comment">//test表示匹配的文件类型，正则表达式；use表示对应要调用的loader</span></span><br><span class="line"><span class="string">module:</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">	rules:</span> [</span><br><span class="line">	&#123; <span class="string">test:</span> <span class="regexp">/\.css$/</span>, <span class="string">use:</span> [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意事项：<ul>
<li>use数组中指定的loader顺序是固定的</li>
<li>多个loader的调用顺序是：从后往前调用</li>
</ul>
</li>
</ul>
<h5 id="打包处理less文件"><a href="#打包处理less文件" class="headerlink" title="打包处理less文件"></a>打包处理less文件</h5><ul>
<li>运行<code>npm i less-loader less -D</code>命令</li>
<li>在webpack.config.js的module -&gt; rules数组中，添加loader规则如下：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">	<span class="attribute">rules</span>: [</span><br><span class="line">	&#123; test: /\.less$/, use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>],[<span class="string">'less-loader'</span>] &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="配置postCSS自动添加css的兼容前缀"><a href="#配置postCSS自动添加css的兼容前缀" class="headerlink" title="配置postCSS自动添加css的兼容前缀"></a>配置postCSS自动添加css的兼容前缀</h5><ul>
<li>运行<code>npm i postcss-loader autoprefixer -D</code>命令</li>
<li>在项目根目录中创建postcss的配置文件postcss.config.js。并初始化如下配置：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = require(<span class="string">'autoprefixer'</span>)<span class="comment">//导入自动添加前缀的插件</span></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">	plugins: [ autoprefixer ]<span class="comment">//挂载插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在webpack.config.js的module -&gt; rules数组中，添加loader规则如下：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: </span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">rules</span>: [</span><br><span class="line">	&#123; test: /\.css$/, use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'postcss-loader'</span>] &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="打包样式表中的图片和字体文件"><a href="#打包样式表中的图片和字体文件" class="headerlink" title="打包样式表中的图片和字体文件"></a>打包样式表中的图片和字体文件</h5><ul>
<li>运行<code>npm i url-loader file-loader -D</code>命令</li>
<li>在webpack.config.js的module -&gt; rules数组中，添加loader规则如下：<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">module: </span><br><span class="line">&#123;</span><br><span class="line">	rules: [</span><br><span class="line">	&#123; test: /\.jpg|<span class="type">png</span>|<span class="type">gif</span>|<span class="type">bmp</span>|<span class="type">ttf</span>|<span class="type">eot</span>|<span class="type">svg</span>|<span class="type">woff</span>|<span class="type">woff2</span>$/, </span><br><span class="line">	  use: ['url-loader?limit=<span class="number">16940</span>'] &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中？之后的是loader的参数项。limit用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为base64图片。</li>
</ul>
<h5 id="打包处理js中的高级语法"><a href="#打包处理js中的高级语法" class="headerlink" title="打包处理js中的高级语法"></a>打包处理js中的高级语法</h5><ul>
<li>安装babel转换器相关的包：<code>npm i babel-loader @babel/core @babel/runtime -D</code></li>
<li>安装babel语法插件相关的包：<code>npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D</code></li>
<li>在项目根目录创建Babel配置文件<code>babel.config.js</code>并初始化如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">	presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">	plugins: [ <span class="string">'@babel/plugin-transform-runtime'</span>, <span class="string">'@babel/plugin-proposal-class-properties'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在webpack.config.js的module-&gt;rules数组中，添加loader规则如下：<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exclude为排除项，表示babel-loader不需要处理node_modules中的js文件</span></span><br><span class="line"><span class="comment">//因为node_modules中的js都是第三方包提供的，我们只需要转换用户自己写的js文件</span></span><br><span class="line">&#123; <span class="string">test:</span> <span class="regexp">/\.js$/</span>,<span class="string">use:</span> <span class="string">'babel-loader'</span>, <span class="string">exclude:</span> <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>传统组件的问题：</p>
<ul>
<li>全局定义的组件必须保证组件的名称不重复</li>
<li>字符串模板缺乏语法高亮，在HTML有多行的时候，需要用到丑陋的\ </li>
<li>不支持css意味着当HTML和js组件化时，css被明显遗漏</li>
<li>没有构建步骤限制，只能使用HTML和ES5js，而不能使用预处理器</li>
</ul>
<p>正对针对上述问题提出了Vue单文件组件。每个单文件组件的后缀名都是.vue<br>组成结构：</p>
<ul>
<li>template：组件的模板区域</li>
<li>script：业务逻辑区域</li>
<li>style：样式区域</li>
</ul>
<h4 id="webpack配置vue组件的加载器"><a href="#webpack配置vue组件的加载器" class="headerlink" title="webpack配置vue组件的加载器"></a>webpack配置vue组件的加载器</h4><ul>
<li>运行<code>npm i vue-loader vue-template-compiler -D</code></li>
<li>在webpack.config.js配置文件中，添加vue-loader的配置项<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="keyword">module</span>:&#123;</span><br><span class="line">		rules: [</span><br><span class="line">		&#123; test: <span class="regexp">/\.vue$/</span>, use: <span class="string">'vue-loader'</span>&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">	<span class="keyword">new</span> VueLoaderPlugin()<span class="comment">//确保导入这个插件</span></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在webpack项目中使用vue"><a href="#在webpack项目中使用vue" class="headerlink" title="在webpack项目中使用vue"></a>在webpack项目中使用vue</h4><ul>
<li>运行<code>npm i vue -S</code>安装vue</li>
<li>在src -&gt; index.js入口文件，通过import Vue from ‘vue’来导入vue构造函数</li>
<li>导入根组件</li>
<li>创建vue的实例对象，并指定要控制的el区域</li>
<li>通过render函数渲染App根组件</li>
</ul>
<h4 id="webpack的打包发布"><a href="#webpack的打包发布" class="headerlink" title="webpack的打包发布"></a>webpack的打包发布</h4><p>上线之前通过webpack将应用进行整体打包，可以通过package.json文件配置打包命令：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在package.json文件中配置webpack打包命令</span></span><br><span class="line"><span class="comment">//该命令默认加载项目根目录中的webpack.config.js配置文件</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="comment">//用于打包的命令</span></span><br><span class="line">	<span class="string">"build"</span>: <span class="string">"webpack -p"</span>,</span><br><span class="line">	<span class="comment">//用于开发调试的命令</span></span><br><span class="line">	<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host --127.0.0.1 --port 3000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包后的文件会自动加入dist目录中，所以打包之前可以先将dist目录删除。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>webpack配置</tag>
        <tag>单文件组件</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2-路由&amp;&amp;模块化规范</title>
    <url>/2019/12/25/vue2-03/</url>
    <content><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>概念：路由是一个比较广义和抽象的概念，路由的本质就是对应关系</p>
<ul>
<li>后端路由<ul>
<li>概念：根据不同的用户<code>url请求</code>，返回不同的内容</li>
<li>本质：url请求地址域服务器资源之间的对应关系</li>
<li>根据不同的url地址分发不同的资源</li>
</ul>
</li>
<li>SPA<ul>
<li>后端渲染（存在渲染问题）</li>
<li>Ajax前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）<a id="more"></a></li>
<li>单页面程序spa：整个网站只有一个页面，内容的变化通过ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作</li>
<li>实现原理之一：实现原理之一：基于url的hash（hash的变化会导致浏览器记录访问历史的变化、但是hash的变化不会触发新的url请求）</li>
<li>在实现spa过程中，最关键的技术就是前端路由</li>
</ul>
</li>
<li>前端路由<ul>
<li>概念：根据不同的<code>用户事件</code>，显示不同的页面内容</li>
<li>本质：用户事件域事件处理函数之间的对应关系</li>
<li>负责事件监听，触发事件后，通过事件函数渲染不同内容</li>
</ul>
</li>
</ul>
<h3 id="前端路由的基本概念和原理"><a href="#前端路由的基本概念和原理" class="headerlink" title="前端路由的基本概念和原理"></a>前端路由的基本概念和原理</h3><p>基于URL中的hash实现（点击菜单的时候改变URL的hash，根据hash的变化控制组件的切换）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听window的onhashchange事件，根据获取到的最新的hash值，切换要显示的组建的名称</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//通过location.hash获取到最新的hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p>包括的功能：</p>
<ul>
<li>支持HTML5历史模式或hash模式</li>
<li>支持嵌套路由</li>
<li>支持路由参数</li>
<li>支持编程式路由</li>
<li>支持命名路由</li>
</ul>
<p>使用基本步骤</p>
<ul>
<li>引入相关的库文件</li>
<li>添加路由连接</li>
<li>添加路由填充位</li>
<li>定义路由组件</li>
<li>配置路由规则并创建路由实例（！！！）</li>
<li>把路由挂载到根实例中</li>
</ul>
<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="动态路由参数"><a href="#动态路由参数" class="headerlink" title="动态路由参数"></a>动态路由参数</h4><p>通过动态路由参数的模式进行路由匹配。动态路由参数，在写路由匹配规则的时候，在路由最后的参数由：开头。而对应匹配的路由组件，可以通过<code>$route.params.id</code>获取路由参数：<code></code>。</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>$route与对应路由形成高度耦合，不够灵活，所以可以使用props将组件和路由解耦</p>
<ul>
<li>props的值为布尔值。<ul>
<li>如果props被设置为true，route.params将会被设置为组件属性。需要在子组件中定义<code>props:[&#39;id&#39;]</code>来使用props接收路由参数。</li>
</ul>
</li>
<li>props的值为对象类型时<ul>
<li>如果props是一个对象，它会被按原样设置为组件属性<code>props:{ uname:&#39;lisi&#39;,age:12 }</code></li>
<li>在子组件中：<code>props:[&#39;uname&#39;,&#39;age&#39;]</code>。</li>
<li>就相当于传参传递多个参数，但是不能访问通过<code>$route.params.id</code>获取到的值</li>
</ul>
</li>
<li>peops使得值为 函数类型<ul>
<li>如果props是一个函数，则这个函数接收route对象为自己的形参<code>props: route =&gt; ({unam:&#39;zs&#39;,age:20,id:route.params.id })</code></li>
<li>子组件访问的时候<code>props:[&#39;id&#39;,&#39;uname&#39;,&#39;age&#39;]</code></li>
<li>该方法相当于是上述两种方法的结合</li>
</ul>
</li>
</ul>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>为了更方便的表示路由的路径，可以给路由规则起一个别名，即命名路由。即在定义路由匹配规则中添加一个name属性即可。<br>即我们跳转路由的时候，可以在router-link中添加一个：to的对象为该命名路由。改成命名路由方式跳转</p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul>
<li>声明式导航：通过点击连接实现导航的方式，叫做声明式导航。<ul>
<li>普通网页中的<code>&lt;a&gt;&lt;/a&gt;</code>连接</li>
<li>Vue中的<code>&lt;router-link&gt;&lt;/router-link&gt;</code></li>
</ul>
</li>
<li>编程式导航：通过js形式的API实现导航的方式，叫做编程式导航<ul>
<li>location.href</li>
</ul>
</li>
</ul>
<p>Vue中的编程式导航常用的API：</p>
<ul>
<li>this.$router.push(‘hash地址’)//用来进行跳转</li>
<li>this.$router.go(n)//经常用来前进后退</li>
</ul>
<h4 id="router-push方法参数规则"><a href="#router-push方法参数规则" class="headerlink" title="router.push方法参数规则"></a>router.push方法参数规则</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(<span class="string">'/home'</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123;<span class="attribute">path</span>:<span class="string">'/home'</span>&#125;)</span><br><span class="line"><span class="comment">//命名的路由（传参）</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123;<span class="attribute">name</span>:<span class="string">'/user'</span>,<span class="attribute">params</span>:&#123;<span class="attribute">userId</span>:<span class="number">123</span>&#125;&#125;)</span><br><span class="line"><span class="comment">//带查询参数，变成/register？unam=lisi</span></span><br><span class="line"><span class="selector-tag">router</span><span class="selector-class">.push</span>(&#123;<span class="attribute">name</span>:<span class="string">'/user'</span>,<span class="attribute">query</span>:&#123;<span class="attribute">uname</span>:<span class="string">'lisi'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul>
<li>传统开发模式的主要问题：命名冲突、文件依赖</li>
<li>模块化就是把单独的一个功能封装到一个模块（文件）中，模块之间相互隔离，但是可以通过特定的接口公开内部成员也可以依赖别的模块</li>
<li>方便代码重用，易于代码维护</li>
</ul>
<h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><ul>
<li>浏览器模块化规范<ul>
<li>AMD<ul>
<li>require.js</li>
</ul>
</li>
<li>CMD<ul>
<li>Sea.js</li>
</ul>
</li>
</ul>
</li>
<li>服务器模块化规范<ul>
<li>CommonJS规范<ul>
<li>模块分为单文件模块与包</li>
<li>模块成员导出：module.exports和exports</li>
<li>模块成员导入：require(‘模块标识符’)</li>
</ul>
</li>
</ul>
</li>
<li>大一统的ES6模块化规范<ul>
<li>以上提出的AMD、CMD、CommonJS存在一定的差异性和局限性，并不是浏览器与服务器通用的模块化标准</li>
<li>AMD和CMD只适用与浏览器端的js模块化</li>
<li>CommonJS适用于服务器端的js模块化</li>
<li>是浏览器端与服务器端通用的模块化开发规范</li>
</ul>
</li>
<li>ES6中模块定义<ul>
<li>每个js文件都是一个独立的模块</li>
<li>导入模块成员使用import关键字</li>
<li>暴露模块成员使用export关键字</li>
</ul>
</li>
</ul>
<h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><h4 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h4><ul>
<li>npm i –save-dev @babel/core @babel/cli @babel/preset-env @babel/node</li>
<li>npm i –save @babel/polyfill</li>
<li>项目根目录创建文件babel.config.js</li>
<li>babel.config.js文件内容添加<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">const presets = [</span><br><span class="line">[<span class="string">"@babel/env"</span>,&#123;</span><br><span class="line"><span class="symbol">	targets:</span> &#123;</span><br><span class="line"><span class="symbol">	edge:</span> <span class="string">"17"</span>,</span><br><span class="line"><span class="symbol">	firefox:</span> <span class="string">"60"</span>,</span><br><span class="line"><span class="symbol">	chrome:</span> <span class="string">"67"</span>,</span><br><span class="line"><span class="symbol">	safari:</span> <span class="string">"11.1"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">];</span><br><span class="line">module.exports = &#123;presets&#125;;</span><br></pre></td></tr></table></figure></li>
<li>通过npx babe-node index.js执行代码</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>默认导出 export default{}（只能用一次）</li>
<li>默认导入import 接受名称 from ‘模块标识符’</li>
<li>按需导出：export let sl = 10</li>
<li>按需导入：import { sl } from ‘模块标识符’</li>
<li>有时候，我们只想单纯执行某个模块中的代码，并不需要得到模块向外暴露的成员，此时可以直接导入并执行模块代码 import ‘./m2.js’</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue路由</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2-组件和前后端交互模式</title>
    <url>/2019/12/21/vue2-02/</url>
    <content><![CDATA[<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>注意事项：</p>
<ul>
<li>data必须返回一个函数（保证每个组件的数据是相互独立的）</li>
<li>组件的模板必须是只有一个根元素</li>
<li>组件模板内容可以是模板字符串（内容复杂，增强代码可读性）</li>
<li>组件命名方式：驼峰式和中间-式如果使用驼峰式命名组件，那么在使用的时候，只能在字符串模中（定义的时候）用驼峰的方式使用组件，但是在普通的标签模板中（使用的时候），必须使用短横线的方式使用组件</li>
<li>全局组件中不能使用局部组件，局部注册的组件只能在它注册了的父组件中使用<a id="more"></a></li>
<li>组件内部使用props数组接收父组件传递过来的值，该传递的值需要在父组件中利用属性绑定来进行传递当然也可以用写死的属性值，但是我们一般都用动态绑定的属性值。</li>
<li>在props中使用驼峰方式，在模板中使用的时候需要使用短横线方式（因为浏览器DOM不区分大小写），就是说定义的时候可以使用驼峰式，使用时候必须短横线</li>
<li>在模板字符串中props属性传值没有这个限制</li>
</ul>
<h3 id="props属性值类型"><a href="#props属性值类型" class="headerlink" title="props属性值类型"></a>props属性值类型</h3><ul>
<li>字符串</li>
<li>number，如果希望是原始数据类型的话，那么父组件传值的时候需要使用属性绑定，不适用属性绑定就是一般的字符串类型</li>
<li>布尔值 （去掉：就是字符串类型，加上就是布尔值，跟number一样）</li>
<li>数组</li>
<li>对象</li>
</ul>
<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ul>
<li>props传递数据是单向数据流</li>
<li>子组件给点击事件添加一个$emit的自定义事件</li>
<li>父组件中需要监听这个事件，所以直接事件绑定事件名称，然后后面是事件逻辑</li>
<li>名称要保持一致，函数方法逻辑是在父组件的methods里面定义的，然后是由子组件来进行触发，父组件进行监听</li>
<li>子组件传递过去的参数，在父组件中使用$event来进行传递，就是正常的传值规律</li>
</ul>
<h3 id="非父子组件间传值"><a href="#非父子组件间传值" class="headerlink" title="非父子组件间传值"></a>非父子组件间传值</h3><ul>
<li>单独的事件中心管理组件间的通信（自定义一个vue实例）<code>var hb = new Vue()</code></li>
<li>该事件中心进行监听事件和销毁事件<code>hb.$on(&#39;add&#39;,add)</code>,<code>hb.$off(&#39;add&#39;)</code></li>
<li>该事件中心再来进行触发事件<code>hb.$emit(&#39;add&#39;,id)</code></li>
</ul>
<h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h3><p>1、 作用<br>父组件向子组件传递内容（传递的是模板中的内容）<br>2、位置：位于子组件的模板中<br>3、插槽内容：通过模板标签，将需要传递的内容放置在模板标签中，进行传递，这样传递的内容就会在插槽的位置进行显示。<br>4、相当于给传递内容预留了一个位置<br>5、作用域插槽：应用场景：父组件对子组件的内容进行相关加工处理；一般用在v-for里面，在v-for里面添加一个slot语句，在里面绑定一个属性对其进行操作，最后在使用的时候，使用template标签进行包裹</p>
<h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>接口调用方式：</p>
<ul>
<li>原生ajax</li>
<li>基于jquery的ajax</li>
<li>fetch</li>
<li>axios</li>
</ul>
<p>url地址形式：</p>
<ul>
<li>传统的url地址协议</li>
<li>restful形式的url</li>
</ul>
<p>注意：前端渲染和服务端渲染的区别，前后端交互在vue里面指的是前端渲染。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>实例化Promise对象，构造函数中传递函数，该函数中用于处理异步任务</li>
<li>resolve和reject两个参数用于处理成功和失败两种情况，并通过p.then获取处理结果</li>
<li>一个then是一次请求（包括成功和失败）</li>
</ul>
<h4 id="then参数中的函数返回值"><a href="#then参数中的函数返回值" class="headerlink" title="then参数中的函数返回值"></a>then参数中的函数返回值</h4><ul>
<li>返回Promise实例对象<ul>
<li>返回的该对象实例会调用下一个then（如调用多个ajax）</li>
</ul>
</li>
<li>返回普通值<ul>
<li>返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值，也就是下一个then直接调用上一个return的结果</li>
</ul>
</li>
</ul>
<h4 id="Promise常用的API"><a href="#Promise常用的API" class="headerlink" title="Promise常用的API"></a>Promise常用的API</h4><ul>
<li>实例方法<ul>
<li>p.then()得到异步任务的正确结果</li>
<li>p.catch()获取异常信息</li>
<li>p.finally()成功与否都会执行（尚且不是正是标准）</li>
</ul>
</li>
<li>对象方法<ul>
<li>Promise.all()并发处理多个异步任务，所有任务都执行完成才能得到结果</li>
<li>Promise.rece()并发处理多个异步任务，只要有一个任务完成就能得到结果</li>
</ul>
</li>
</ul>
<h3 id="fetch接口用法"><a href="#fetch接口用法" class="headerlink" title="fetch接口用法"></a>fetch接口用法</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><ul>
<li>基本特性<ul>
<li>更加简单的数据获取方式，功能更强大、更灵活、可以看作是xhr的升级版</li>
<li>基于Promise实现</li>
</ul>
</li>
<li>语法格式：<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(url)</span>.<span class="title">then</span><span class="params">(fn2)</span></span></span><br><span class="line"><span class="function">          .<span class="title">then</span><span class="params">(fn3)</span></span></span><br><span class="line"><span class="function">          ...</span></span><br><span class="line"><span class="function">          .<span class="title">catch</span><span class="params">(fn)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据<br>常用配置选项：</p>
<ul>
<li>method（string）：HTTP请求方法，默认为GET（GET、POST、PUT、DELETE）</li>
<li>body（string）：HTTP的请求参数</li>
<li>headers（Object）：HTTP的请求头，默认为{}</li>
</ul>
<h4 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h4><p>数据格式：</p>
<ul>
<li>text():将返回体处理成字符串类型</li>
<li>json()：将返回结果和JSON.parse(response.Text)一样</li>
</ul>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>是一个基于Promise用于浏览器和Node.js的HTTP客户端<br>它具有如下特性：</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
</ul>
<p>获取的数据是通过.dat来获取的，并且该属性是确定的。</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li>get： 查询数据<ul>
<li>通过url传参，获取的时候使用query.id</li>
<li>通过params传参，获取的时候使用params.id</li>
</ul>
</li>
<li>post：添加数据<ul>
<li>通过选项传递参数（默认传递的是json格式的数据），获取使用body属性</li>
<li>通过URLSearchParams传递参数</li>
</ul>
</li>
<li>put：修改数据<ul>
<li>传参方式和post相似</li>
</ul>
</li>
<li>delete：删除数据<ul>
<li>传参方式和get相似</li>
</ul>
</li>
</ul>
<h4 id="响应结果-1"><a href="#响应结果-1" class="headerlink" title="响应结果"></a>响应结果</h4><ul>
<li>data：实际响应回来的数据（可以直接当作对象来使用）</li>
<li>headers：响应头消息</li>
<li>status： 响应状态码</li>
<li>statusText：响应状态信息</li>
</ul>
<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><ul>
<li>axios.defaults.timeout = 3000; //超时时间</li>
<li>axios.defaults.baseURL = ‘http:.localhost:3000/app’; //默认地址，设置请求的基准地址</li>
<li>axios.defaults.headers[‘mytoken’] = ‘aaaa’;//设置请求头</li>
</ul>
<p>拦截器就相当于过滤器的作用。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>是ES7引入的新语法，可以更加方便的进行异步操作</li>
<li>async关键字用于函数上（async函数的返回值是Promise实例对象）</li>
<li>await关键字用于async函数当中（await可以得到异步的结果）</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6--05</title>
    <url>/2019/12/10/ECMAScript6-05/</url>
    <content><![CDATA[<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from()方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括ES6新增的数据结构set和map）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">	<span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">	<span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">	<span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">	length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); <span class="regexp">//</span>[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="regexp">//</span>ES6的写法</span><br><span class="line">var arr2 = Array.from(arrayLike);<span class="regexp">//</span>[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>实际应用中，常见的类似数组对象都是DOM操作返回得到NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>ECMAScript6入门（阮一峰）</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6--04</title>
    <url>/2019/12/10/ECMAScript6-04/</url>
    <content><![CDATA[<h2 id="数值的扩展方法"><a href="#数值的扩展方法" class="headerlink" title="数值的扩展方法"></a>数值的扩展方法</h2><h3 id="Number-isFinite-、Number-isNaN"><a href="#Number-isFinite-、Number-isNaN" class="headerlink" title="Number.isFinite()、Number.isNaN()"></a>Number.isFinite()、Number.isNaN()</h3><ul>
<li>在数值上提供这两种方法来检查infinite和NaN这两个特殊值。</li>
<li>它们和传统的全局方法isFinite和isNaN方法的区别在于，传统方法先调用Number将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</li>
</ul>
<h3 id="Number-parseInt-、Number-parseFloat"><a href="#Number-parseInt-、Number-parseFloat" class="headerlink" title="Number.parseInt()、Number.parseFloat()"></a>Number.parseInt()、Number.parseFloat()</h3><ul>
<li>ES将全局方法parseInt和parseFloat移植到Number对象上面，行为完全保持不变。</li>
<li>这样做的目的是逐步减少全局性方法，使得语言逐步模块化。<a id="more"></a>

</li>
</ul>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p>该方法用来判断一个值是否是整数。特别注意的是：<code>再js内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值</code></p>
<h3 id="完全整数和Number-isSafeInteger"><a href="#完全整数和Number-isSafeInteger" class="headerlink" title="完全整数和Number.isSafeInteger()"></a>完全整数和Number.isSafeInteger()</h3><ul>
<li>js能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，就无法精确表示这个值。</li>
<li>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</li>
<li>Number.isSafeInteger()是用来判断一个整数是否是落在这个范围之内</li>
<li>注意：验证运算结果是否落在安全整数范围时，不要只验证运算结果，而要同时验证参与运算的每个值<code>Number.isSafeInteger(Number.MAX_SAFE_INTEGER - 1) //false</code></li>
</ul>
<h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><ul>
<li>Math.trunc方法用于去除一个数的小数部分，返回整数部分；对于非数值，Math.trunc内部使用Number方法将其先转为数值，对于空值和无法截取整数的值，返回NaN</li>
<li>Math.sign方法用来判断一个数到底是正数、负数还是零。它会返回五种值：<ul>
<li>参数为正数，返回+1</li>
<li>参数为负数，返回-1</li>
<li>参数为0，返回0</li>
<li>参数为-0，返回-0</li>
<li>其他值，返回NaN</li>
</ul>
</li>
<li>Math.cbrt方法用于计算一个数的立方根，对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为其他数值</li>
<li>Math.clz32：js的整数使用32位二进制表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0（也就是第一个非零数之前的零的个数）</li>
<li>Math.imul方法返回了两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数<code>Math.imul(2,-2) //-4</code>。如果只考虑最后32位，大多数情况下，该方法域a* b的结果是一样的，该方法等同于（a* b）|0的效果（超过32位的溢出）。之所以需要这个方法，是因为js有精度限制，超过2的53次方的值无法精确表示。这就是说，对于哪些很大数的乘法，低位数值往往都是不精确的，而该方法可以返回正确的低位数值</li>
<li>Math.found方法返回一个数的单精度浮点数形式。对于整数来说，Math.found方法返回结果不会有任何不同，区别主要是哪些无法使用64个二进制位精确表示的小数。这时，Math.found方法会返回最接近这个小数的单精度浮点数。</li>
<li>Math.hypot方法返回所有参数的平方和的平方根<code>Math.hypot(3,4)//5</code>如果参数不是数值，Math.hypot先将其转为数值。只要有一个参数无法转为数值，就会返回NaN</li>
<li>Math.expml返回e^x-1即Math.exp（x）-1</li>
<li>Math.log1p返回l+x的自然对数，即Math.log（1+x）。如果x小于-1，返回NaN</li>
<li>Math.log0返回以10为底 的x的对数。如果x小于0，则返回NaN</li>
<li>Math.log2返回以2为底的x的对数。如果x小于零，则返回NaN</li>
<li>三角函数方法<ul>
<li>Math.sinh(x)返回x的双曲正弦</li>
<li>Math.cosh(x)返回x的双曲余弦</li>
<li>Math.tanh(x)返回x的双曲正切</li>
<li>Math.asinh(x)返回x的反双曲正弦 </li>
<li>Math.acosh(x)返回x的反双曲余弦</li>
<li>Math.atanh(x)返回x的反双曲正切</li>
</ul>
</li>
</ul>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES7新增了一个指数运算符（** ），目前Babel转码器已经支持</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span>** <span class="number">2</span> //<span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span>** <span class="number">3</span> //<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>指数运算符可以和等号结合，形成一个新的赋值运算符（* * = ）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let b=<span class="number">3</span>；</span><br><span class="line">b** =<span class="number">3</span>；</span><br><span class="line"><span class="comment">//等同于b=b*b*b</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>ECMAScript6入门（阮一峰）</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6--字符串的扩展</title>
    <url>/2019/12/09/ECMAScript6-03/</url>
    <content><![CDATA[<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="确定字符串是否在另一个字符串中"><a href="#确定字符串是否在另一个字符串中" class="headerlink" title="确定字符串是否在另一个字符串中"></a>确定字符串是否在另一个字符串中</h3><ul>
<li>includes（）：返回布尔值，表示是否找到了参数字符串</li>
<li>startsWith（）： 返回布尔值，表示参数字符串是否在源字符串的头部</li>
<li>endsWith（）：返回布尔值，表示参数字符串是否在源字符串的尾部</li>
</ul>
<p>注意：<code>使用第二个参数n时，endsWith的行为和其他两个不一样，endsWith针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束</code></p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>该方法返回一个新的字符串，表示将原字符串重复n次</p>
<a id="more"></a>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.<span class="keyword">repeat</span><span class="comment">(3)</span> <span class="comment">//'xxx'</span></span><br><span class="line"><span class="string">'hello'</span>.<span class="keyword">repeat</span><span class="comment">(2)</span> <span class="comment">//'hellohello'</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(0)</span> <span class="comment">//''</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(2.9)</span> <span class="comment">//'nana'如果是小数，会被取整，参数如果是infinity或者负数会报错</span></span><br></pre></td></tr></table></figure>
<p><b>但是，如果参数是0到-1之间的小数，则等同于0</b>，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0.<br><b>参数NaN等同于0</b><br><b>如果repeat的参数是字符串，则会先转换成数字</b></p>
<h3 id="padStart-、padEnd"><a href="#padStart-、padEnd" class="headerlink" title="padStart()、padEnd()"></a>padStart()、padEnd()</h3><p>ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>,<span class="string">'ab'</span>) <span class="regexp">//</span><span class="string">'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>,<span class="string">'ab'</span>) <span class="regexp">//</span><span class="string">'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>,<span class="string">'ab'</span>) <span class="regexp">//</span><span class="string">'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>,<span class="string">'ab'</span>) <span class="regexp">//</span><span class="string">'xaba'</span></span><br></pre></td></tr></table></figure>
<p>这两个方法一共接收两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">'xxxx'</span>.padStart(<span class="number">3</span>,<span class="string">'ab'</span>) <span class="regexp">//</span><span class="string">'xxxx'</span></span><br></pre></td></tr></table></figure>
<p>如果忽略第二个参数，则会用<code>空格</code>补全长度</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>是增强版的字符串，用反引号<code>`</code>表示。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通字符串</span></span><br><span class="line"><span class="string">`hello`</span></span><br><span class="line"><span class="comment">//多行字符串</span></span><br><span class="line"><span class="string">`hello</span></span><br><span class="line"><span class="string">hello`</span></span><br><span class="line"><span class="comment">//字符串嵌入变量</span></span><br><span class="line"><span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果在模板字符串中需要使用反引号，可以用反斜杠转义。<code>\`</code>。</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</li>
<li>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>中</li>
<li>大括号内部可以放入任意的js表达式，可以进行运算，以及引用对象属性。<code>${y*2}</code>,<code>${x:1}</code></li>
<li>模板字符串之中还可以调用函数<code>`foo ${fn()} `</code></li>
<li>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如大括号中是一个对象，将默认调用对象的toString方法。</li>
<li>如果模板字符串中的变量没有声明，将报错</li>
<li>由于模板字符串的大括号内部就是执行js代码，因此如果大括号内部是一个字符串，将会按照原样输出。</li>
<li>如果需要引用模板字符串本身，需要在模板字符串加’’</li>
</ul>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串的功能，它可以跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。<br>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”只得就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p>这是原生的String方法提供的raw方法。该方法往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。<br>该方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>ECMAScript6入门（阮一峰）</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2-01</title>
    <url>/2019/12/08/vue2-01/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这一部分是针对于vue1进行的一些补充。这是看了视频VUE全家桶做的一些补充。</p>
<ul>
<li>声明式编程：<ul>
<li>模板的结构和最终显示的效果基本一致 </li>
</ul>
</li>
</ul>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>v-cloak背后的原理：先通过样式隐藏内容，然后再内存中进行值的替换，替换好以后再显示最终的结果</li>
<li>v-text 相比较v-cloak更加简洁</li>
<li>v-html 不安全，本站内部数据可以使用，来自第三方数据不可使用</li>
<li>v-pre 显示原始信息，跳过编译过程<a id="more"></a>

</li>
</ul>
<h3 id="数据响应式"><a href="#数据响应式" class="headerlink" title="数据响应式"></a>数据响应式</h3><ul>
<li>理解数据响应式<ul>
<li>html5中的响应式（屏幕尺寸改变导致样式的变化）</li>
<li>数据的响应式（数据的变化会导致页面内容的变化）</li>
</ul>
</li>
<li>什么是数据绑定<ul>
<li>数据绑定：将数据填充到标签中</li>
</ul>
</li>
<li>v-once只编译一次<ul>
<li>显示内容之后不再具有响应式的功能</li>
<li>应用场景：如果现实的信息后续不需要修改，这样可以提高性能（如果使用方法会不停的监听）</li>
</ul>
</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数</li>
<li>如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，并且事件对象的名称是$event</li>
<li>事件默认是由冒泡的</li>
<li>v-model的底层实现原理：<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">input</span> v-<span class="keyword">bind</span>:value=<span class="string">"msg"</span> v-on:<span class="keyword">input</span>=<span class="string">"msg=$event.target.value"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方法</span></span><br><span class="line">&lt;<span class="keyword">input</span> v-<span class="keyword">bind</span>:value=<span class="string">"msg"</span> v-on:<span class="keyword">input</span>=<span class="string">"handle"</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	data:&#123;</span><br><span class="line">		msg:''</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		handle: <span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</span><br><span class="line">			<span class="comment">//使用输入域中最新的数据覆盖原来的数据</span></span><br><span class="line">			<span class="keyword">this</span><span class="variable">.msg</span> = <span class="keyword">event</span><span class="variable">.target</span><span class="variable">.value</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><p>相关细节：</p>
<ul>
<li>对象绑定和数组绑定可以结合使用 [class1,class2,[class3:isTrue]]</li>
<li>class绑定的值可以简化操作</li>
<li>默认的class如何处理(默认的不会被覆盖，只会被合并)</li>
</ul>
<p>class绑定的样式类样式，style绑定的是内联样式。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>v-for循环中key的作用：帮助vue区分不同的元素，从而提高性能。</li>
<li>v-if和v-for可以结合使用</li>
</ul>
<h2 id="Vue常用特性"><a href="#Vue常用特性" class="headerlink" title="Vue常用特性"></a>Vue常用特性</h2><p>表单操作、自定义指令、计算属性、监听器、过滤器、生命周期</p>
<h3 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h3><ul>
<li>input单行文本</li>
<li>textarea 多行文本</li>
<li>select 下拉选择框</li>
<li>radio 单选框</li>
<li>checkbox 多选框</li>
</ul>
<h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><ul>
<li>number 将输入的转化为数值</li>
<li>trim 去掉开始和结尾的空格</li>
<li>lazy 将input事件转换为change事件（change事件是要失去焦点的时候才会触发，而input只要是有变化就触发）<ul>
<li>一般用来注册用户名，输入完了再去验证</li>
</ul>
</li>
</ul>
<p><b>lazy事件可以用来验证用户注册名字，是否被占用</b></p>
<h3 id="computed-VS-methods"><a href="#computed-VS-methods" class="headerlink" title="computed VS methods"></a>computed VS methods</h3><ul>
<li>computed 是基于依赖的，具有缓存特性，优化内存特性</li>
<li>methods方法不进行缓存</li>
</ul>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><ul>
<li>数据一旦发生变化就通知侦听器所绑定方法。</li>
<li>应用场景：数据变化时执行异步或开销较大的操作</li>
<li>是对数据本身添加一个方法，来对其进行监听改变，而计算属性是添加一个格外的方法来返回一个方法结果</li>
</ul>
<p>案例：验证用户名是否被注册<br>步骤：</p>
<ul>
<li>采用侦听器监听用户名的变化</li>
<li>调用后台接口进行验证</li>
<li>根据验证的结果调整提示信息</li>
<li>使用表单的lazy修饰符来改变事件触发时间 </li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	checkName: <span class="function"><span class="keyword">function</span><span class="params">(uname)</span></span>&#123;</span><br><span class="line">		<span class="comment">//调用接口，但是可以调用定时任务的方式模拟接口调用</span></span><br><span class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//模拟接口调用</span></span><br><span class="line">			<span class="keyword">if</span>(uname == <span class="string">'admin'</span>)&#123;</span><br><span class="line">				that.tip = <span class="string">'用户名已经存在，请更换一个'</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				that.tip = <span class="string">'用户名可以使用'</span></span><br><span class="line">			&#125;</span><br><span class="line">			&#125;,<span class="number">2000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">	uname: <span class="function"><span class="keyword">function</span><span class="params">(val)</span></span>&#123;</span><br><span class="line">		<span class="comment">//调用后台接口验证用户名的合法性</span></span><br><span class="line">		<span class="keyword">this</span>.checkName(val);</span><br><span class="line">		<span class="comment">//修改提示信息</span></span><br><span class="line">		<span class="keyword">this</span>.tip = <span class="string">'正在验证'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>作用：格式化数据，比如字符串格式转化为首字母大写，将日期格式转化为指定的格式等。</li>
<li>插值表达式和绑定属性都可以使用</li>
<li>可以传参，第一个是默认参数指向这个元素，第二个就可以是传过来的参数。</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>挂载（初始化相关属性）<ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted（模板内容已经填充完毕，一般用于从后台获取数据挂载到模板中，已经挂载到实例上）</li>
</ul>
</li>
<li>更新（元素或组件的变更操作）<ul>
<li>beforeUpdate</li>
<li>updated</li>
</ul>
</li>
<li>销毁（销毁相关属性）<ul>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
</li>
</ul>
<h3 id="补充-数组相关API"><a href="#补充-数组相关API" class="headerlink" title="补充(数组相关API)"></a>补充(数组相关API)</h3><p>数据的变化会影响页面的变化（通过编译方法来实现的）。而替换数组的方式的话就需要对原始数组进行赋值来实现页面数据的更新。也就是说使用替换数组的方法，都不会影响原始数组的数据，页面也就不会进行改变，要想改变页面只有重新将新的数组赋值给原始数组。</p>
<ul>
<li>变异方法（修改原有数据）<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
</li>
<li>替换数组（生成新的数组）<ul>
<li>filter()</li>
<li>concat()</li>
<li>slice()</li>
</ul>
</li>
</ul>
<h4 id="数组的响应式变化"><a href="#数组的响应式变化" class="headerlink" title="数组的响应式变化"></a>数组的响应式变化</h4><p><b>用索引修改数组的方式不是响应式的</b><br><b>直接在data中的数据添加属性或者添加值都不是响应式的，也就是页面不会随着该数据的改变而改变</b>，所以以下两个API既可以对数组进行响应式添加数据也可以对数据进行响应式添加数据<br>修改响应式数据：</p>
<ul>
<li>Vue.set(vm.items,indexOfItem,newValue)</li>
<li>vm.$set(vm.items,indexOfItem,newValue)<ul>
<li>参数一标识要处理的数组名称</li>
<li>参数二标识要处理的数组索引</li>
<li>参数三要处理的数组的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6--变量的解构赋值</title>
    <url>/2019/11/25/ECMAScript6-02/</url>
    <content><![CDATA[<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这称为<code>解构</code>。<br>以前为变量赋值只能直接指定值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var a</span> = 1;</span><br><span class="line"><span class="attribute">var b</span> = 2;</span><br><span class="line"><span class="attribute">var c</span> = 3;</span><br></pre></td></tr></table></figure>
<p>ES6允许写成这样：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>可以表示，可以从数组中提取值，按照对应位置，对变量赋值。<br>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同左边的变量就会被赋予对应的值。</p>
<a id="more"></a>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [h,...t] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">h <span class="comment">//1</span></span><br><span class="line">t <span class="comment">// [2,3,4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let [a,s,...d] = [a]</span><br><span class="line">a<span class="comment">//a</span></span><br><span class="line">s<span class="comment">//undefined</span></span><br><span class="line">d<span class="comment">//[]</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于undefined。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">var <span class="comment">[foo]</span> = <span class="comment">[]</span>;</span><br><span class="line">var <span class="comment">[bar,foo]</span> = <span class="comment">[1]</span>;</span><br></pre></td></tr></table></figure>
<p>这两种情况都是属于解构不成功，foo的值都等于undefined。<br>另一种情况是不完全解构，即等号左边的模式只匹配一部分的等号右边的数组。这种情况下，解构也是可以成功</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// x 1; y 2</span></span><br><span class="line"></span><br><span class="line">let [x,[y],z] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>]</span><br><span class="line"><span class="comment">// x 1; y 2; z 4</span></span><br></pre></td></tr></table></figure>
<p>都属于解构不完全但是可以成功。<br>如果等号的右边不是数组（或者说不是可遍历的解构）那么将会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口，要门本身就不具备Iterator接口。<br>解构赋值不仅适用于var命令，还适用于let和const命令。对于set结构也可以使用数组的解构赋值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [x,y,z] = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>解构赋值允许指定默认值。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo = <span class="literal">true</span>] - [];</span><br><span class="line">foo<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">x</span>,<span class="symbol">y</span> = <span class="string">'b'</span>] = [<span class="number">1</span>] <span class="comment">//x=1,y='b'</span></span><br><span class="line">[<span class="symbol">x</span>,<span class="symbol">y</span> = <span class="string">'b'</span>] = [<span class="number">1</span>,<span class="literal">undefined</span>] <span class="comment">//x=1,y='b'</span></span><br><span class="line">[<span class="symbol">x</span>,<span class="symbol">y</span> = <span class="string">'b'</span>] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//x=1,y=2</span></span><br></pre></td></tr></table></figure>
<p>注意：<b>ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的</b></p>
<p>默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">let [<span class="symbol">x</span>=<span class="number">1</span>,<span class="symbol">y</span>=<span class="symbol">x</span>] = []; <span class="comment">//x=1;y=1</span></span><br><span class="line">let [<span class="symbol">x</span>=<span class="number">1</span>,<span class="symbol">y</span>=<span class="symbol">x</span>] = [<span class="number">2</span>]; <span class="comment">//x=2;y=2</span></span><br><span class="line">let [<span class="symbol">x</span>=<span class="number">1</span>,<span class="symbol">y</span>=<span class="symbol">x</span>] = [<span class="number">1</span>,<span class="number">2</span>]; <span class="comment">//x=1;y=2</span></span><br><span class="line">let [<span class="symbol">x</span>=<span class="symbol">y</span>,<span class="symbol">y</span>=<span class="number">1</span>] = []; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，也可以用于对象。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var &#123;foo,bar&#125; = &#123; <span class="string">foo:</span><span class="string">'1'</span>,<span class="string">bar:</span><span class="string">'a'</span> &#125;</span><br><span class="line"><span class="comment">// foo = '1',bar = 'a'</span></span><br><span class="line"></span><br><span class="line">var &#123;bar,foo&#125; = &#123; <span class="string">foo:</span><span class="string">'1'</span>,<span class="string">bar:</span><span class="string">'a'</span> &#125;</span><br><span class="line"><span class="comment">// foo = '1',bar = 'a'</span></span><br><span class="line"></span><br><span class="line">var &#123; bar &#125; = &#123; <span class="string">foo:</span><span class="string">'1'</span>,<span class="string">bar:</span><span class="string">'a'</span> &#125;</span><br><span class="line"><span class="comment">//bar=undefined</span></span><br></pre></td></tr></table></figure>
<p>对象的解构赋值和数组有一个重要的不同：<code>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</code></p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span><span class="string">'1'</span>,<span class="string">bar:</span><span class="string">'a'</span> &#125;</span><br><span class="line"><span class="comment">//baz='1'</span></span><br><span class="line"><span class="comment">//foo undef</span></span><br></pre></td></tr></table></figure>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> foo, <span class="string">bar:</span> bar &#125; = &#123; <span class="string">foo:</span><span class="string">'1'</span>,<span class="string">bar:</span><span class="string">'a'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，真正被赋值的是后者而不是前者。<br>对象跟数组一样也可以用来嵌套解构赋值。</p>
<p>对象的解构也可以指定默认值。默认值生效的条件是<code>对象的属性值严格等于undefined</code></p>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;foo：&#123;bar&#125;&#125; = &#123;bar:<span class="string">'baz'</span>&#125;;</span><br><span class="line">foo <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>foo属性对应一个子对象，该子对象的bar属性解构时会报错，因为foo这个时候等于undefined，再取子属性就会报错。</p>
<p>如果要将一个已经声明的变量用于解构赋值，需要非常小心</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="symbol">x</span></span><br><span class="line">&#123;<span class="symbol">x</span>&#125; = &#123;<span class="symbol">x</span>：<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line">&#123;<span class="symbol">x</span>&#125; = （&#123;<span class="symbol">x</span>：<span class="number">1</span>&#125;）</span><br></pre></td></tr></table></figure>
<p>因为js引擎会将{x}理解成一个代码块，从而发生语法错误。只有不讲大括号写在行首，避免js将其解释为代码块才能解决这个问题。</p>
<p>解构赋值允许，等号左边的模式之中，不放置任何变量名。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//毫无意义的写法</span></span><br><span class="line">(&#123;&#125; = [<span class="literal">true</span>,<span class="literal">false</span>])</span><br><span class="line">(&#123;&#125; = <span class="number">123</span>)</span><br><span class="line">(&#123;&#125; = [])</span><br></pre></td></tr></table></figure>

<p>对象的解构赋值可以很方便的将现有对象的方法复制到某个变量</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="built_in">log</span>, <span class="built_in">sin</span>, <span class="built_in">cos</span> &#125; = Math</span><br></pre></td></tr></table></figure>
<p>会将Math对象的对数、预先】正弦三个方法赋值到对应的变量上。</p>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值，这是因为字符串被转换成了一个类似数组的对象</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">'hello'</span></span><br><span class="line">//a=<span class="string">'h'</span>,b=<span class="string">'e'</span>,c=<span class="string">'l'</span>,d=<span class="string">'l'</span>,e=<span class="string">'o'</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个length属性，因此，还可以对这个属性解构赋值</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length: lem&#125; =<span class="string">'hello'</span></span><br><span class="line">len <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值是如果等号右边时数值和布尔值，会先转为对象。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line"><span class="attr">s===</span> Number.prototype.<span class="built_in">toString</span> //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>&#123;<span class="built_in">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="attr">s===</span> Boolean.prototype.<span class="built_in">toString</span> //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>由于数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。<br>解构赋值的规则时，只要等号右边的值不是对象，就先将其转换为对象，由于undefined和null无法转换为对象，所以对他们进行解构赋值都会报错。</p>
<h3 id="函数参数的结构辅助"><a href="#函数参数的结构辅助" class="headerlink" title="函数参数的结构辅助"></a>函数参数的结构辅助</h3><p>函数的参数也可以使用解构赋值</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">function add([<span class="symbol">x</span>,<span class="symbol">y</span>]&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="symbol">x</span>+<span class="symbol">y</span></span><br><span class="line">	&#125;)</span><br><span class="line">add([<span class="number">1</span>,<span class="number">3</span>]) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>函数add的参数实际上不是一个数组，而是通过解构得到的变量x和y。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]].map(([a,b]) =&gt; a+b)</span><br><span class="line"><span class="comment">//[3,7]</span></span><br></pre></td></tr></table></figure>

<p>函数参数的解构也可以使用默认值。</p>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>ES6的规则是只要有可能导致解构的歧义，就不得使用圆括号。</p>
<h4 id="以下三种解构赋值不得使用圆括号"><a href="#以下三种解构赋值不得使用圆括号" class="headerlink" title="以下三种解构赋值不得使用圆括号"></a>以下三种解构赋值不得使用圆括号</h4><p>1、变量声明语句中，模式不能带有圆括号</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全部报错</span></span><br><span class="line">var [(a)] = [<span class="number">1</span>];</span><br><span class="line">var &#123; <span class="string">x:</span>(c) &#125; = &#123;&#125;;</span><br><span class="line">var &#123; <span class="string">o:</span> (&#123;<span class="string">p:</span>p&#125;) &#125; = &#123;<span class="string">o:</span>&#123;<span class="string">p:</span><span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>2、函数参数中，模式不能带有圆括号<br>函数参数也属于变量声明，因此不能带有圆括号</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([<span class="params">(z)</span>])</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br></pre></td></tr></table></figure>
<p>3、不能将整个模式，或嵌套模式中的一层，放在圆括号这</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">(</span><span class="template-variable">&#123;p:a&#125;</span><span class="xml">) = </span><span class="template-variable">&#123;p:42&#125;</span></span><br><span class="line"><span class="template-variable">&#123;[a]&#125;</span><span class="xml"> = [5]</span></span><br></pre></td></tr></table></figure>

<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>只有一种情况：赋值语句的非模式部分，可以使用圆括号</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">[(b)] = [3]</span></span><br><span class="line"><span class="xml">(</span><span class="template-variable">&#123;p:(d)&#125;</span><span class="xml"> = </span><span class="template-variable">&#123;&#125;</span><span class="xml">)</span></span><br></pre></td></tr></table></figure>
<p>赋值语句而不是声明语句，赋值语句可以执行，声明语句不可以执行。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li>交换变量的值 <code>[x,y] = [y,x]</code>，代码简洁易读语义清晰</li>
<li>从函数返回多个值。<br>函数只能返回一个值，如果要返回多个值，只能将他们放在数组或者对象里返回。有了解构赋值，取出这些值就非常方便。<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		foo: <span class="number">1</span>,</span><br><span class="line">		bar: <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数参数的定义<br>解构赋值可以方便的将一组参数与变量名对应起来<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">//参数是一组有次序的值</span><br><span class="line">function f([x,y,z])<span class="meta">&#123;...&#125;</span></span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">//参数是一组无次序的值</span><br><span class="line">function f(&#123;x,y,z&#125;)<span class="meta">&#123;...&#125;</span></span><br><span class="line">f(&#123;z：<span class="number">1</span>，x:<span class="number">2</span>，y:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>提取JSON数据</li>
<li>函数参数的默认值</li>
<li>遍历Map解构<br>任何部署可iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</li>
<li>输入模块的指定方法<br>加载模块时，往往需要指定哪些输入方法，解构赋值使得输入语句非常清晰。<code>const { s,s1 } = require(&#39;xxx&#39;)</code></li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>ECMAScript6入门（阮一峰）</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6--01</title>
    <url>/2019/11/18/ECMAScript6-01/</url>
    <content><![CDATA[<h2 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h2><p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转换为ES5代码，从而在浏览器或其他环境中执行。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item+<span class="number">1</span>;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的原始代码使用了箭头函数，这个特性还没有得到广泛支持，Babel将其转换为普通函数，就能在现有的js环境执行里面。<br>Babel自带一个babel-node命令。提供支持ES6的REPL环境。它支持node的PERL环境的所有功能，而且可以直接运行ES6代码。</p>
<a id="more"></a>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt;</span><br><span class="line">&gt;console.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(x =&gt; x*x))</span><br><span class="line">&gt; [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>babel-node命令也可以直接运行ES6脚本。假定将上面的代码放入脚本文件es6.js。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ babel-<span class="keyword">node</span> <span class="title">es6</span>.js</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>-o参数将转换后的代码，从标准输出导入文件</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">$ babel es6<span class="number">.</span><span class="keyword">js</span> -o es5<span class="number">.</span><span class="keyword">js</span></span><br><span class="line">//或者</span><br><span class="line">$ babel es6<span class="number">.</span><span class="keyword">js</span> --<span class="keyword">out</span>-fifle es5<span class="number">.</span><span class="keyword">js</span></span><br></pre></td></tr></table></figure>

<p>-d参数用于转换整个目录</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">babel </span>-d <span class="keyword">build-dir </span>source-dir</span><br></pre></td></tr></table></figure>
<p>注意，-d参数后面跟的是输出目录。<br>如果希望生成source map文件，则要加上-s参数</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">babel </span>-d <span class="keyword">build-dir </span>source-<span class="keyword">dir </span>-s</span><br></pre></td></tr></table></figure>

<h3 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h3><p>Babel也可以用于浏览器。但是从Babel6.0开始，不再直接提供浏览器版本，而是要用工具构建出来。</p>
<h3 id="node环境"><a href="#node环境" class="headerlink" title="node环境"></a>node环境</h3><p>需要注意的是，Babel默认不会转换iterator、generator、set、maps、proxy、reflect、symbol、promise等全局对象，以及一些定义在全局对象上的方法（比如object.assign）。如果用到了这些功能就需要安装<code>babel-polyfill</code>模块。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">babel-polyfill </span>--save</span><br></pre></td></tr></table></figure>
<p>然后在所有脚本头部都加上一行：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span>(<span class="string">'babel-polyfill'</span>);</span><br><span class="line">/<span class="regexp">/or</span></span><br><span class="line"><span class="regexp">import 'babel-polyfill';</span></span><br></pre></td></tr></table></figure>
<h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p>Babel提供一个REPL在线编译器，可以在线将ES6代码转换为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行</p>
<h2 id="Traceur转码器"><a href="#Traceur转码器" class="headerlink" title="Traceur转码器"></a>Traceur转码器</h2><p>该转码器润许将ES6代码直接插入网页。首先，必须在网页头部加载Traceur库文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 加载Traceur转码器 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://google.github.io/traceur-compiler/bin/traceur.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 将Traceur转码器 用于网页 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://google.github.io/traceur-compiler/bin/bootstrap.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打开实验选项，否则有些不成功 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">traceur.options.experimental = <span class="literal">true</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来可以将ES6代码放上上面这些代码的下方就可以了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//代码区</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，script的标签属性值是module。<br>也可以外部引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"es6.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6新增了let命令，用来生命变量，它的用法类似于var，但是所生命的变量只在let命令所在的代码块内有效</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let <span class="selector-tag">a</span> = <span class="number">10</span>；</span><br><span class="line">	<span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">1</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a<span class="comment">//a is not defined</span></span><br><span class="line">b<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>for循环的计数器，就很适合用let命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(let i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">console.log(i);<span class="comment">//i is not defined</span></span><br></pre></td></tr></table></figure>
<p>计数器i只在循环体内有效，只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。如果是var声明，在全局范围内都是i有效的，所以每一次循环新的i都会覆盖旧值。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>let不想var那样，会有“变量提升”现象。所以变量一定要在声明后使用。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line">let a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上述会输出一个错误，因为上述代码在声明a之前就使用这个变量结果就会抛出一个错误。这也意味着typeof不再是一个百分之百安全的操作</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeof</span> <span class="symbol">x</span> <span class="comment">//出错</span></span><br><span class="line">let <span class="symbol">x</span></span><br></pre></td></tr></table></figure>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再收外部的影响。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	t = <span class="string">"abc"</span>;<span class="comment">//出错</span></span><br><span class="line">	<span class="keyword">let</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量t，但是块级作用域内又声明了一个局部变量t，导致后者绑定这个块级作用域，所以在let声明变量前，对t赋值会报错。</p>
<p>es6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前使用这些命令就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ES6规定暂时性死区和不存在变量提升主要是为了减少运行时错误，防止在变量声明前就使用这个变量。</span><br><span class="line">~~~</span><br><span class="line">总之，暂时性死区的本质就是，只要已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的哪一行代码出现，才可以获取和使用该变量。</span><br><span class="line">~~~</span><br><span class="line">#### 不允许重复声明</span><br><span class="line">let不允许在相同作用域内，重复声明同一个变量</span><br><span class="line">~~~</span><br><span class="line">&#x2F;&#x2F;报错</span><br><span class="line">function()&#123;</span><br><span class="line">	let a &#x3D; 10;</span><br><span class="line">	var a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;报错</span><br><span class="line">function()&#123;</span><br><span class="line">	let a &#x3D; 10;</span><br><span class="line">	let a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line">因此&#96;&#96;&#96;不能在函数内部重新声明参数</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arg;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">let</span> arg;<span class="comment">//报错</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域。<br>1、内层变量可能会覆盖外层变量<br>2、用来计数的循环变量泄露为全局变量</p>
<h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><p>let为JS新增了块级作用域。ES6允许块级作用域的任意嵌套。外层作用域无法获取内层作用域的变量。内层作用域可以定义外层作用域的同名变量。<br>块级作用域使得获得广泛应用的立即执行匿名函数不再必要了。</p>
<p>ES5的函数提升：<br>不管会不会进入if代码块，函数声明都会提升到当前作用域的顶部得到执行。<br>ES6的块级作用域：<br>不管会不会进入if代码块，其内部声明的函数都不会影响到作用域的外部。</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>const也是用来声明变量，但是声明的是常量，一旦声明，常量的值就不能改变。相当于<code>read only</code>。<br>const的作用域和let作用域相同：只在声明所在的会计作用域内有效。<br>const声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。也跟let一样不能重复声明。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<span class="keyword">const</span>命令只是在保证变量名指向的地址不变，并不保证该地址的数据不变。</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;；</span><br><span class="line">foo.<span class="keyword">prop</span> = 123；</span><br><span class="line">foo.<span class="keyword">prop</span> <span class="comment">//123</span></span><br><span class="line">foo = &#123;&#125;<span class="comment">//read only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo存储的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加一个新属性。<br>另一个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'123'</span>);<span class="comment">//可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;<span class="comment">//可执行</span></span><br><span class="line">a = [<span class="string">"aa"</span>]<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的项把对象冻结，可以使用<code>Obejct.freeze</code>方法。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">const foo = Obejct.<span class="keyword">freeze</span>(&#123;&#125;)；</span><br><span class="line">foo.prop = <span class="number">123</span>；//不起作用</span><br></pre></td></tr></table></figure>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象完全冻结的函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">	Obejct.<span class="keyword">freeze</span>(obj);</span><br><span class="line">	Obejct.keys(obj).<span class="keyword">forEach</span>( (key,<span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span>(typeof obj[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">			constatize(obj[key]);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ES6一共又6种声明变量的方法。</p>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>全局对象是最顶层的对象，在浏览器环境值得是window对象，在Node.js指的是global对象。ES5中，全局对象的属性和全局变量是等价的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">window.a = <span class="number">1</span>;</span><br><span class="line">a<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">2</span>;</span><br><span class="line">window.a<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>ES6中，var和function命令所声明的全局变量，依旧是全局对象的属性，另一方面，let命令、const命令、class命令声明的全局变量不属于全局对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 吧= <span class="number">1</span>；</span><br><span class="line"><span class="built_in">window</span>.b<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>全局变量b由let声明，所以它不是全局对象的属性，返回undefined。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>ECMAScript6入门（阮一峰）</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1--零散笔记</title>
    <url>/2019/11/16/vue1-10/</url>
    <content><![CDATA[<h2 id="computed-VS-method"><a href="#computed-VS-method" class="headerlink" title="computed VS method"></a>computed VS method</h2><p>computed：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&#123;&#123; reverseMsg &#125;&#125;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">	reverseMsg: <span class="function"><span class="keyword">function</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="regexp">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">		&#125;</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>method：</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&#123;&#123; reverseMsg &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">methods</span>:&#123;</span><br><span class="line">	reverseMsg: <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设上述两种方法出来的结果是一样的，都是反转字符串的结果。我们可以将同一个函数定义为一个方法而不是一个计算属性。结果相同，不同的是计算属性是基于它们的<b>响应性依赖</b>进行缓存的。只在响应式依赖发生改变时，它们才会重新求值。这就意味着只要Msg没有发生改变，多次访问reverseMsg计算属性会立即返回之前的结果，而不必再次执行函数。可如果是函数的话每调用一次都要调用该方法，也就是说<code>computed有缓存，methods没有缓存</code>。但是computed的缓存只是针对<b>响应式依赖</b>。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">computed</span>:&#123;</span><br><span class="line">	<span class="attribute">now</span>:<span class="built_in">function</span>()&#123;</span><br><span class="line">		return Date.<span class="built_in">now</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码因为Date.now不是响应式依赖，所以当它改变的时候，就不会再更新！！！<br>相比之下，每当触发重新渲染时，调用方法总会再次执行函数。</p>
<h2 id="computed-VS-watch"><a href="#computed-VS-watch" class="headerlink" title="computed VS watch"></a>computed VS watch</h2><p>虽然computed再大多数情况下更合适，但有时也需要一个自定义的watch来响应数据的变化，当需要再数据变化时执行异步或开销较大的操作时，这个方法时最有效的。</p>
<h2 id="多页应用和单页应用"><a href="#多页应用和单页应用" class="headerlink" title="多页应用和单页应用"></a>多页应用和单页应用</h2><h3 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h3><p>每一次多页面跳转的时候，后台服务器都会给返回一个新的html文档（页面跳转=》返回html）</p>
<ul>
<li>优点：首屏事件快，SEO效果好（服务端渲染）</li>
<li>缺点：页面切换慢，每次跳转都是一个http请求</li>
</ul>
<h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>第一次进入页面的时候会请求一个html文件。切换到其他组件，路径也响应变化，但是并没有新的html文件请求，页面内容改变了。<br>原理：js会感知到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做判断页面到底是显示哪个组件，清楚不需要的，显示需要的组件。每次跳转的时候不再请求html文件了，只有一个完整页面，在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容（页面跳转=》js渲染）</p>
<ul>
<li>优点:页面切换速度快</li>
<li>缺点：首屏事件稍慢，SEO差（只认识HTML中的内容，不认识js内容）<br>单页应用首屏时间包括了一次html请求时间和一次js请求时间</li>
</ul>
<h2 id="客户端渲染和服务端渲染区别"><a href="#客户端渲染和服务端渲染区别" class="headerlink" title="客户端渲染和服务端渲染区别"></a>客户端渲染和服务端渲染区别</h2><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>DOM树在服务端生成，然后返回给前端</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>前端去后端获取数据生成DOM树</p>
<h3 id="优缺点比较"><a href="#优缺点比较" class="headerlink" title="优缺点比较"></a>优缺点比较</h3><h4 id="服务端渲染-1"><a href="#服务端渲染-1" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><ul>
<li>优点<ul>
<li>尽量不占用前端的资源，前端这块耗时少，速度快</li>
<li>有利于SEO优化，因为在后端有完整的html页面，首屏时间少</li>
</ul>
</li>
<li>缺点<ul>
<li>不利于前后端分离，开发效率更低</li>
<li>对html的解析，对前端来说加快了速度，但是也加大了服务器压力</li>
</ul>
</li>
</ul>
<h4 id="客服端渲染"><a href="#客服端渲染" class="headerlink" title="客服端渲染"></a>客服端渲染</h4><ul>
<li>优点<ul>
<li>前后端分离，开发效率高</li>
<li>用户体验好，将网站做成了SPA（单页面应用）</li>
</ul>
</li>
<li>缺点<ul>
<li>前端响应速度慢，特别是首屏时间长</li>
<li>不利于SEO</li>
</ul>
</li>
</ul>
<h2 id="别名和重定向"><a href="#别名和重定向" class="headerlink" title="别名和重定向"></a>别名和重定向</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>当用户访问/a时，url将会被替换成/b，然后匹配路由为/b</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>/a的别名时/b，意味着当用户访问/b时，url会保持/b，但是路由会被匹配为/a，就像用户访问/a</p>
<h2 id="vue-nextTick工作原理"><a href="#vue-nextTick工作原理" class="headerlink" title="vue nextTick工作原理"></a>vue nextTick工作原理</h2><p>vue在修改数据后，视图不会立即更新，而是等同一个事件循环中的所有数据变化完成之后，再统一进行属兔更新。<br>用途：需要再=视图更新之后，基于新的视图进行操作。再created、mounted阶段，如果需要操作选然后的视图，也需要使用nextTick方法。也就是说在下一次数据改变后视图没有更新之前。</p>
<h2 id="碎片化笔记"><a href="#碎片化笔记" class="headerlink" title="碎片化笔记"></a>碎片化笔记</h2><ul>
<li>当在一个自定义组件上使用class属性时，这些class将被添加到该组件的根元素上面。这个元素上已经存在的class不会被覆盖</li>
<li>当v-bind：style使用需要添加浏览器引擎前缀的css属性时，如transform，Vue.js会自己侦测并添加响应前缀</li>
<li>v-if和v-for一起使用时，v-for是有比v-if更高的优先级</li>
<li>Vue不能检测对象属性的添加或删除，我们只能现在data数据挂载对象上定义一个响应式元素，这样的话就可以监听检测到它的改变，如果直接是给一个元素添加不存在data响应式数据的话，就不会检测到，只能手动的用vue的set方法。</li>
<li>v-model会忽略所有表单元素的value、checked、selected attribute的初始值，而总是将vue实例的数据作为数据来源。</li>
<li>因为组件时可复用的vue实例，所有它们与new vue接收相同的选项，例如data、computed、watch、methods以及生命周期钩子等。仅有的例外时向el这样根实例特有的选项</li>
<li>一个组件的data选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立拷贝，如果没有这条规则，点击一个按钮就可能会像代码一样影响到其他所有实例。也就是说，组件是可以复用的，如果data不是一个函数，只是一个对象的话，那么复用的所有组件都共享一个data内存数据，即其中一个组件的改变可能会影响到另外组件的相关改变，所以只能用data作为一个函数来进行独立拷贝，这样的话就可以维护每一个可复用组件独立的数据。</li>
<li>全局注册的行为必须在根实例之前（new vue）创建之前发生。所有的prop都使得父子prop之前形成了单项下行绑定：父级prop的更新会向下流动到子组件中，但反过来则不行，这样会防止从子组件意外改变父组件的状态，从而导致应用数据流难以理解</li>
<li>一个足尖上的v-mode默认会利用名为value的prop和名为input的事件</li>
<li>v-slot只能添加在<code>&lt;template&gt;</code>上</li>
<li>当只用JavaScript过渡的时候，在enterheleave中必须使用done进行回调，否则，它们将被同步调用，过渡立即完成。</li>
<li>使用FLIP过渡的元素不能设置为display：inline。作为替代方案，可以设置为display：inline-block或者放置于flex中</li>
<li>render中的createElement参数返回的是一个实际的DOM元素，它更准确的名字较createNodeDescription，因为它所包含的信息会告诉vue页面上需要渲染什么样的节点，包括及其子节点的描述，我们把这样的节点称为virtualNode</li>
<li>插件通常用来为vue添加全局功能。组件（全局和局部）一般是复用代码，实现一些小的功能，提高代码的可复用性</li>
<li>响应式是非侵入响应式的，数据模型是普遍的js对象，响应式：当修改数据的时候，视图会进行更新。当把一个js进入vue中data选项，vue会遍历次对象所有的属性，并使用object.defineProperty将这些属性全部转换为getter/seeter。object.defineProperty是ES5中一个无法shim的特性，这也就是vue为何不能再IE8及以下的版本浏览器中使用</li>
<li>vue无法检测到对象属性的添加或者删除，由于vue会在初始化实例时对属性进行getter/setter转化，所以属性必须再data上才是响应式。</li>
<li>导航守卫：主要用来通过跳转或取消的方式首位导航（防止路由改变）相当于一个拦截器</li>
<li>props可以是数组或对象，用于接收来自父组件的数据。如果props时对象，则允许配置高级选项，如雷响检测、自定义验证和设置默认值</li>
<li>mixns：接收一个混入对象的数组。合并使用，以后使用自身组件，minxin钩子按照传入顺序依次调用，并在调用自身的钩子之前被调用</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day9</title>
    <url>/2019/11/15/vue1-09/</url>
    <content><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>概念：<br>vuex是Vue配套的公共数据管理工具，它可以把一些共享的数据，保存到vuex中，方便整个程序中的任何组件直接获取或者修改我们的公共数据。</p>
<p>vuex是为了保存组件之间共享数据而诞生的，如果组件之间有要共享的数据，可以直接挂载到vuex中，而不必通过父子组件之间传值了，如果组件的数据不需要共享，此时这些不需要共享的私有数据，没有必要传到vuex；<br>只有共享的数据，才有权力放到vuex中去，组件内部私有的数据，只要放到组件的data中即可</p>
<a id="more"></a>
<p>props（组件传递过来的数据）和data（私有数据）区别，vuex（共享数据）</p>
<p>得出一个结论：vuex是一个全局的共享数据存储区域，就相当于是一个数据的仓库；<br>如果在组件中想要访问store中的数据，只能通过this.$store.state.***<br>大奖vuex挂载到vm实例上，类似于router来进行挂载一样，只要挂载到了vm上，任何组件都能使用store来访问数据<br>如果要操作store中的state值，只能通过调用mutations提供的方法，才能操作对应的数据，不推荐直接操作state中的数据，因为万一导致了数据的紊乱，不能快速定位到错误的愿意你，因为每个组件都可能有操作数据的方法</p>
<p>如果组件想要调用mutations中的方法，只能调用$this.store.commit(‘方法名’)来进行调用</p>
<p>在mutations中最多只能支持两个参数，如果想要传多个参数，则可以使用对象方式来传参</p>
<p>getters只负责对外提供数据，不负责修改数据，如果想要修改state中的数据，请去mutations/经过回顾对比，发现getters中的方法，和组件中的过滤器比较类似，因为过滤器和getters都没有修改原数据，都是把原数据做了一层包装，提供给了调用者。其次getters也和computed比较像，只要state中的数据发生变化了，那么如果getters正好也引用了这个数据那么就会立即触发getters重新求值</p>
<p>总结：<br>  1、state中的数据，不能直接修改，如果想要修改，必须通过mutations<br>  2、如果组件想要直接从state上获取数据：需要this.$store.state.<strong>*<br>  3、入宫组件想要修改数据，必须使用mutations提供的方法，需要通过this.$store.commit（‘方法名’，唯一的一个参数）<br>  4、如果store中state上的数据，在对外提供的时候，需要做一层包装，那么，推荐使用getters，如果需要使用getters，则用this.$store.getters.*</strong></p>
<h2 id="开启Apache的gzip压缩"><a href="#开启Apache的gzip压缩" class="headerlink" title="开启Apache的gzip压缩"></a>开启Apache的gzip压缩</h2><p>要让apache支持gzip功能，要用到deflate_Module和headers_module。打开apache的配置文件httpd.conf，大约在105行左右，找到以下两行内容：（这两行不是连续在一起的）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#LoadModule deflate_module modules/mod_deflate.so</span></span><br><span class="line"><span class="comment">#LoadModule headers_Module modules/mod_headers.so</span></span><br></pre></td></tr></table></figure>
<p>然后将其前面的“#”注释删掉，表示开启gzip压缩功能。开启以后还需要进行相关配置。在http.conf文件的最后添加以下内容即可：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;IFModule deflate_module&gt;</span></span><br><span class="line"><span class="comment">#必须的，就像一个开关一样，告诉apache对传输到浏览器的内容进行压缩</span></span><br><span class="line"><span class="attribute">SetOutputFilter</span> DEEFLATE</span><br><span class="line"><span class="attribute">DeflateCompressionLevel</span> 9</span><br><span class="line"><span class="section">&lt;/IFModule deflate_module&gt;</span></span><br></pre></td></tr></table></figure>
<p>最少需要加上以上内容，才可以gzip功能生效，由于没有做其他额外配置，所以其他相关的配置均使用Appache的默认设置。这里说一下参数“DeflateCompressionLevel”，它表示压缩级别，值从1到9，值越大表示压缩的越厉害</p>
<h3 id="使用ngrok将本机映射为一个外网的web服务器"><a href="#使用ngrok将本机映射为一个外网的web服务器" class="headerlink" title="使用ngrok将本机映射为一个外网的web服务器"></a>使用ngrok将本机映射为一个外网的web服务器</h3><p>注意：由于默认使用的美国的服务器中间转接，所以访问速度超级慢，访问时可直接启用FQ软件，提高网页打开速度。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day8</title>
    <url>/2019/11/11/vue1-08/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="关于promise解决回调地狱问题的说明"><a href="#关于promise解决回调地狱问题的说明" class="headerlink" title="关于promise解决回调地狱问题的说明"></a>关于promise解决回调地狱问题的说明</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：你要封装一个方法，我给你一个要读取文件的路径，你这个方法能帮我读取文件，并把内容返回给我</span></span><br><span class="line"></span><br><span class="line">const fs = <span class="keyword">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">const path = <span class="keyword">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是普通读取文件的方式</span></span><br><span class="line">&lt;!-- fs.readFile(path.<span class="keyword">join</span>(__dirname,<span class="string">'./files/1.txt'</span>),<span class="string">'utf-8'</span>,(err,<span class="built_in">data</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span>(err) throw err</span><br><span class="line">	console.<span class="keyword">log</span>(<span class="built_in">data</span>)</span><br><span class="line">	&#125;) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装方法的初衷：给定文件路径，返回读取到的文件内容</span></span><br><span class="line"><span class="comment">//我们可以规定以下，callback中有两个参数，第一个参数就是失败的结果，第二个参数就是成功的结果；同时我们规定了，如果成功后，返回的结果应该房屋callback参数的第二个位置，此时第一个位置由于没有出错所以放一个努力了；如果失败了第一个位置参数防止erro对象，第二个位置放一个undefined</span></span><br><span class="line">function getFilePath(fpath,callback)&#123;</span><br><span class="line">	<span class="comment">//该文件读取方法是一个异步方法，主程序不会去管他，而会直接跳过，所以无法获得读取文件的return值</span></span><br><span class="line">	fs.readFile(path.<span class="keyword">join</span>(fpath,<span class="string">'utf-8'</span>,(err,<span class="built_in">data</span>) =&gt; &#123;</span><br><span class="line">	<span class="comment">//错误发生后，就立即进入if分支，if后面的额代码就不会执行，解决办法就是在throw err前面加一个return</span></span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">return</span> callback(err)</span><br><span class="line">	&lt;!-- console.<span class="keyword">log</span>(<span class="built_in">data</span>) --&gt;</span><br><span class="line">	callback(<span class="built_in">null</span>,<span class="built_in">data</span>)<span class="comment">//使用回调来获取读取文件的值</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">getFilePath(path.<span class="keyword">join</span>(__dirname,<span class="string">'./files/1.txt'</span>),(<span class="built_in">data</span>) =&gt; &#123;</span><br><span class="line">	console.<span class="keyword">log</span>(<span class="built_in">data</span>)</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">return</span> console.<span class="keyword">log</span>(err.message)</span><br><span class="line">	console.<span class="keyword">log</span>(<span class="built_in">data</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>回调地狱就是回调里面嵌套回调，一直会嵌套下去，当嵌套多了层级多了的时候，就会影响直观感受和代码的维护，物品们就称这种回调现象为回调地狱。解决办法是：使用ES6的Promise（本质就是用来解决回调地狱，并不能帮我们减少代码量），把多层的嵌套改成串联的使用。</p>
<h3 id="Promise基本概念介绍【重要】"><a href="#Promise基本概念介绍【重要】" class="headerlink" title="Promise基本概念介绍【重要】"></a>Promise基本概念介绍【重要】</h3><p>1.Promise是一个构造函数，既然是构造函数我们就可以new Promise(),得到Promise实例<br>2.在Promise上，有两个函数，分别叫做resolve（成功之后的回调函数）和reject（失败之后的回调函数）<br>3.在Promise构造函数的Prototype属性上有一个.then()方法，也就是说只要是Promise构造函数创建的实例，都可以访问到.then()方法<br>4.Promise表示一个异步操作，每当我们new一个Promise的实例，这个实例就表示一个具体的异步操作；<br>5.既然Promise创建的实例是一个异步操作，那么这个异步操作的结果只能有两种状态：异步执行成功了（需要在内部调用成功回调函数 resolve把结果返回给调用者）、异步执行失败了（需要在内部调用失败的回调函数reject把结果返回给调用者）；由于Promise的实例是一个异步操作，所以内部拿到操作的结果后，无法使用return把操作的结果返回给调用者；这时候只能使用回调函数的形式来吧成功或失败的结果返回给调用者。<br>6.我们可以在new出来的Promise实例上调用.then()方法，【预先】为这个Promise异步操作指定成功（resolve）和失败（reject）回调函数。</p>
<p>使用：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//这里<span class="keyword">new</span>出来的promise只是代表【形式上】的一个异步操作</span><br><span class="line">//什么是形式上的异步操作：就是说我们只知道它是一个异步操作，但是做什么具体的异步事情，目前还不清楚</span><br><span class="line">//var promise = <span class="keyword">new</span> Promise()</span><br><span class="line"></span><br><span class="line">//这是一个具体的异步操作，其中，使用<span class="function"><span class="keyword">function</span>指定一个具体的异步操作</span></span><br><span class="line">/* var promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">	//这个<span class="function"><span class="keyword">function</span>内部写的就是具体的异步操作</span></span><br><span class="line">	fs.readFile()</span><br><span class="line">	&#125;) */</span><br></pre></td></tr></table></figure>
<p>每当new一个Promise实例的时候，就会立即执行这个异步操作中的代码，也就是说，new的时候，除了能够得到一个Promise额实例之外，还会立即调用我们为Promise构造函数传递的哪个function，执行这个function中的额异步操作代码.如果不想要立即执行，需要用函数包裹一下这个函数如下所示。</p>
<p>then方法，谁调用谁写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初衷：给路径，返回读取到的内容</span></span><br><span class="line"><span class="comment">//以下的代码，因为promise是立即执行的，所以执行promise的时候，先then先执行，先把resolve和reject具体化，然后再执行function内部的其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileParh</span>(<span class="params">fpath</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		fs.readFile(fpath,<span class="string">'utf-8'</span>,(err,data) =&gt; &#123;</span><br><span class="line">			<span class="comment">/*if (err) throw err</span></span><br><span class="line"><span class="comment">			console.log(data)*/</span></span><br><span class="line">			<span class="keyword">if</span>(err) reject(err)</span><br><span class="line">			resolve(data)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFilePath(<span class="string">'./files'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err》message)</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：通过.then指定回调函数的时候，成功的回调函数必须穿，但是失败的回调函数可以省略不传</p>
<h3 id="打开promise的正确方式"><a href="#打开promise的正确方式" class="headerlink" title="打开promise的正确方式"></a>打开promise的正确方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初衷：给路径，返回读取到的内容</span></span><br><span class="line"><span class="comment">//以下的代码，因为promise是立即执行的，所以执行promise的时候，先then先执行，先把resolve和reject具体化，然后再执行function内部的其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileParh</span>(<span class="params">fpath</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		fs.readFile(fpath,<span class="string">'utf-8'</span>,(err,data) =&gt; &#123;</span><br><span class="line">			<span class="comment">/*if (err) throw err</span></span><br><span class="line"><span class="comment">			console.log(data)*/</span></span><br><span class="line">			<span class="keyword">if</span>(err) reject(err)</span><br><span class="line">			resolve(data)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件1</span></span><br><span class="line"><span class="comment">//在上一个.then中，返回一个新的promise实例，可以继续使用下一个.then来处理。即当前.then所处理的是上一个函数对return的结果</span></span><br><span class="line">getFilePath(<span class="string">'./files'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取文件2</span></span><br><span class="line">	<span class="keyword">return</span> getFilePath(<span class="string">'./files2'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">		<span class="comment">//读取文件3</span></span><br><span class="line">		<span class="keyword">return</span> getFilePath(<span class="string">'./files3'</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(data)</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常的两种方式"><a href="#捕获异常的两种方式" class="headerlink" title="捕获异常的两种方式"></a>捕获异常的两种方式</h3><p>如果前面的promise执行失败，我们不想让后续的promise操作终止，可以为每个promise指定失败的回调</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">getFilePath(<span class="string">'./files'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></span><br><span class="line">	console.<span class="built_in">log</span>(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取文件2</span></span><br><span class="line">	<span class="keyword">return</span> getFilePath(<span class="string">'./files2'</span>)</span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span><span class="params">(err)</span>&#123;</span></span><br><span class="line">		console.<span class="built_in">log</span>(err.message)</span><br><span class="line">		&#125;)</span><br><span class="line">	.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></span><br><span class="line">		console.<span class="built_in">log</span>(data)</span><br><span class="line">		<span class="comment">//读取文件3</span></span><br><span class="line">		<span class="keyword">return</span> getFilePath(<span class="string">'./files3'</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></span><br><span class="line">			console.<span class="built_in">log</span>(data)</span><br><span class="line">			&#125;)</span><br><span class="line">			.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></span><br><span class="line">				console.<span class="built_in">log</span>(data.message)</span><br><span class="line">				&#125;)</span><br></pre></td></tr></table></figure>
<p>当我们有这样的需求：哪怕前面的promise执行失败了，但是不要影响后续的正常执行，此时我们可以单独为每个promise，通过.then指定下一直白的回调；<br>有时候，我们有这样的需求，跟上面的需求刚好相反：如果后续的promise执行，依赖于前面promise执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有promise的执行.catch的作用就是，不管前面的哪一个出错了，哪怕是promise或者.then出错了，都立即停止执行.catch，进行错误的捕获（前面任何一个出错了后面的都不再执行相关操作直接跳到catch）</p>
<blockquote>
<p>catch的作用：如果前面有任何的promise执行失败，则立即停止所有promise的执行，并马上进入catch去处理promise中抛出的异常，但是执行成功的promise还是会执行成功</p>
</blockquote>
<blockquote>
<p>jQuery中的ajax也可以使用promise </p>
</blockquote>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day7</title>
    <url>/2019/11/08/vue1-07/</url>
    <content><![CDATA[<h2 id="Mint-UI"><a href="#Mint-UI" class="headerlink" title="Mint-UI"></a>Mint-UI</h2><p>是基于vue.js的移动端组件库<br>该Mint-UI个bootstrap不一样</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line"># Vue <span class="number">1.</span>x</span><br><span class="line">npm install mint-<span class="symbol">ui@</span><span class="number">1</span> -S</span><br><span class="line"># Vue <span class="number">2.0</span></span><br><span class="line">npm install mint-ui -S</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入全部组件</span></span><br><span class="line">import Vue from 'vue';</span><br><span class="line">import Mint from 'mint-ui';</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(Mint);</span><br><span class="line"><span class="comment">// 按需引入部分组件</span></span><br><span class="line">import &#123; Cell, Checklist &#125; from 'mint-ui';</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>component(<span class="module-access"><span class="module"><span class="identifier">Cell</span>.</span></span>name, Cell);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>component(<span class="module-access"><span class="module"><span class="identifier">Checklist</span>.</span></span>name, Checklist);</span><br></pre></td></tr></table></figure>

<h2 id="MUI"><a href="#MUI" class="headerlink" title="MUI"></a>MUI</h2><blockquote>
<p>MUI不同于mint-ui，MUI只是开发出来的一套好用的代码片段，里面提供了配套的样式、配套的html代码段，类似于bootstrap；二mint-ui是真正的组件库，是使用Vue技术分装出来的成淘宝的组件，可以无缝的和VUE项目进行集成开发；<br>因此，从体验上来说，mint-ui体验更好，因为是别人帮我们开发好的线程的Vue组件；从体验上来说。MUI和bootstrap类似；理论上，任何项目都可以使用MUI或bootstrap，但是，mint-ui只使用与VUE项目</p>
</blockquote>
<p>注意：MUI并不能使用npm去下载，只能自己手动从github上下载现成的包，解压出来，然后手动拷贝到项目中使用</p>
<p>项目文件中，node_modules是使用npm下载的包的存放地址，lib文件是自己手动下载拷贝的包的存放地址</p>
<p>码云控制上传文件的仓库的全局设置，在使用之前需要先在命令工具里面进行全局初始化，不然一开始可能是属于github的用户名和用户邮箱</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//码云</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"Teresa"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"1395768483@qq.com"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GitHub</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"flysara"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"1395768483@qq.com"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day6</title>
    <url>/2019/11/04/vue1-06/</url>
    <content><![CDATA[<h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><h3 id="url-loader的使用"><a href="#url-loader的使用" class="headerlink" title="url-loader的使用"></a>url-loader的使用</h3><p>注意：npm有两种安装方式，本地安装和全局安装，如果是本地安装，则可以通过require来引入包，如果是全局安装是提供给命令行用的，即全局安装的方式在代码中不用require方式引用。</p>
<p>默认情况下，webpack无法处理css文件中的url地址，不管是图片还是字体库，只要是url地址都处理不了</p>
<p>这是在webpack.config.js文件中新增的处理url的erl-loader文件</p>
<a id="more"></a>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123; test: /\.(<span class="name">jpg</span>|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7600&amp;name=[name].[ext]' &#125;</span><br></pre></td></tr></table></figure>
<p>limit传参的作用就是，当传参的大小大于文件（图片）的大小的时候，会把图片进行base64编码，转换为base64的字符串（可以通过检查网页），如果传参值小于或等于图片大小的时候，就不会进行编码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">limit</span>的作用：让大图保真，让小图压缩</span><br></pre></td></tr></table></figure>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>在webpack中，默认只能处理一部分es6的新语法，一些更高级的es6或者es7语法，webpack是处理不了的，这时候就需要借助第三方的loader来帮助webpack处理这些高级的语法，当第三方loader把高级语法转为低级的语法之后，会把结果交给webpack去打包到main.js中</p>
<p>在webpack中，默认只能处理一部分es6的新语法，一些更高级的es6或者es7语法，webpack是处理不了的，这时候就需要借助第三方的loader<br>来帮助webpack处理这些高级的语法，当第三方loader把高级语法转为低级的语法之后，会把结果交给webpack去打包到main.js中，由于</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">babel-loader <span class="number">8.</span>x对应Babel-core <span class="number">7.</span>x</span><br><span class="line">babel-loader <span class="number">7.</span>x对应babel-core <span class="number">6.</span>x</span><br></pre></td></tr></table></figure>
<p>我安装的是最新的babel-loader，所以跟视频老师说的一些不一样<br>1、通过babel，可以帮我们将高级的语法转换为低级的语法，在webpack中，可以运行如下两套命令安装两套包，去安装babel相关的loader功能</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">第一套包：cnpm i @<span class="keyword">babel/core </span><span class="keyword">babel-loader </span>@<span class="keyword">babel/plugin-transform-runtime </span>@<span class="keyword">babel/runtime </span>-D</span><br><span class="line">  第二套包：cnpm i @<span class="keyword">babel/preset-env </span><span class="keyword">babel-preset-mobx </span>-D</span><br></pre></td></tr></table></figure>
<p>2、打开webpack的配置文件，在module节点下的rules数组中，添加一个新的匹配规则：<br>   2.1<br>    <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">test:</span> <span class="regexp">/\.js$/</span>, <span class="string">use:</span> <span class="string">'babel-loader'</span>, <span class="string">exclude:</span><span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure><br>    第三个exclude，表示的是，除了node_modules中的js文件，其他都可以进行转换<br>   2.2注意：在配置babel的loader规则的时候，必须把node_modules通过exclude排除掉js文件，如果不排除，babel会把node_modules中的<br>           第三方js文件，都打包编译，这样会非常消耗CPU，同时打包速度非常慢<br>           哪怕，最终babel把所有node_modules中的所有js都转换完毕了，项目也无法正常运行<br>  3、在项目的根目录中新建一个叫做.babelrc的babel配置文件，这个配置文件属于json格式，在写.babelrc文件的时候，必须符合json语法规范，不能写注释，字符串必须使用双引号<br>   3.1在babel配置文件中写如下的配置：<br>   <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"@bable/preset-env"</span>,<span class="string">"mobx"</span>],</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   4、了解，目前我们安装的babel-preset-env，是比较新的es语法，之前我们安装的是babel-preset-es2015，当然现在最新的是@babel-preset-env，它包含了所有和<code>es***</code>相关的语法</p>
<h4 id="关于babel的几点说明"><a href="#关于babel的几点说明" class="headerlink" title="关于babel的几点说明"></a>关于babel的几点说明</h4><p>第一套包负责转换，转换器，第二套包负责对应语法的转换，语法对应关系</p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><h3 id="在普通页面中使用render函数渲染组件"><a href="#在普通页面中使用render函数渲染组件" class="headerlink" title="在普通页面中使用render函数渲染组件"></a>在普通页面中使用render函数渲染组件</h3><p>用render来进项渲染就相当于是插值表达式，会替换el对应的指定容器，全部覆盖，就算容器之间有内容，也会全部覆盖为组件内容，但是使用原始的组件标签方式的话，在el对应的哪个容器里面就算有内容，也不会进行覆盖，只是在里面进行展示。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var login = &#123;</span><br><span class="line">           template: <span class="string">'&lt;h1&gt;login&lt;/h1&gt;'</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       var <span class="keyword">vm</span> = <span class="keyword">new</span>(&#123;</span><br><span class="line">           <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#app'</span>,</span><br><span class="line">           dat<span class="variable">a:</span> &#123;&#125;,</span><br><span class="line">           method<span class="variable">s:</span> &#123;&#125;,</span><br><span class="line">           component<span class="variable">s:</span> &#123;</span><br><span class="line">               login</span><br><span class="line">           &#125;,</span><br><span class="line">           render: <span class="function"><span class="keyword">function</span><span class="params">(createElements)</span>&#123;</span></span><br><span class="line">               //createElements是一个方法，调用它，能够把指定的组件模板渲染为html结构</span><br><span class="line">               <span class="keyword">return</span> createElements(login)</span><br><span class="line">               //这里<span class="keyword">return</span>的结果会替换页面中指定<span class="keyword">el</span>的哪个容器</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>


<h3 id="在webpack中配置-vue组件页面的解析"><a href="#在webpack中配置-vue组件页面的解析" class="headerlink" title="在webpack中配置.vue组件页面的解析"></a>在webpack中配置.vue组件页面的解析</h3><p>1、运行<code>npm i vue -S</code>将vue安装为依赖<br>2、运行<code>npm i vue-loader vue-template-compiler -D</code>将解析转换vue的包安装为开发依赖<br>3、运行<code>npm i style-loader css-loader -D</code>将解析转换css的包安装为开发依赖，因为.vue文件中会写css样式<br>4、在<code>webpack.config.js</code>文件中，添加如下modules规则：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">modules:</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js文件中添加resolve属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resolve：&#123;</span><br><span class="line">	<span class="built_in">alias</span>：&#123;</span><br><span class="line">		<span class="string">'vue$'</span>:<span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结梳理：webpack中如何使用vue"><a href="#总结梳理：webpack中如何使用vue" class="headerlink" title="总结梳理：webpack中如何使用vue"></a>总结梳理：webpack中如何使用vue</h3><p>1、安装vue的包，npm i vue -S<br>2、由于在webpack中推荐使用.vue这个组件模板文件定义组件，所以 需要安装能解析这种文件的loader： npm i vue-loader vue-template-complier -D<br>3、在index.js中，导入vue模块，import Vue from ‘vue’<br>4、定义一个.vue结尾的组件，其中，组件有三部分组成：template、script、style<br>5、使用import导入这个组件,import login from ‘./login.vue’<br>6、创建vm的实例 var vm = new Vue（{el：’#app’,render:c =&gt; c(login)}}<br>7、在页面中船舰一个id为app的div元素，作为我们vm实例要控制的区域</p>
<h2 id="export-default和export使用方法"><a href="#export-default和export使用方法" class="headerlink" title="export default和export使用方法"></a>export default和export使用方法</h2><p>在node中向外暴露成员的形式：module.exports = {}，在es6中，也通过规范的形式，规定了es6中如何导入和导出模块</p>
<p>es6中导入模块：<code>import 模块名称from &#39;模块标识符&#39;     import &#39;表示路径&#39;</code><br>es6中导出模块，使用export default和export向外暴露成员；  </p>
<p>在node中使用var 名称 = require(“模块标识符”)<br>module.exports和exports来暴露成员</p>
<p>注意：+ <code>export default</code>向外暴露的成员，可以使用任意的变量来接收<br>     + 在一个模块中export default只允许向外暴露一次<br>     + 在一个模块中可以同时使用export default和export向外暴露成员<br>     + 使用export暴露的成员，引入的时候，必须要加上{}，例如export title，引入的时候：import {title}，这种形式叫做按需导出<br>     + export可以向外暴露多个成员，import {title，title1}，同时如果某些成员，我们在import的时候不需要则可以不再{}中定义引入<br>     + 使用export导出的成员，必须严格按照导出收的名称来引入<br>     + 使用export导出的成员，如果就想换个名称来接收，可以使用as来起一个别名</p>
<h2 id="scoped属性选择器实现原理"><a href="#scoped属性选择器实现原理" class="headerlink" title="scoped属性选择器实现原理"></a>scoped属性选择器实现原理</h2><p>只要设置了scoped属性以后，就会给该组件的 根容器设定一个自定义属性[]（可以通过网页检查元素看到）然后通过该属性在div样式设置上添加来生效。<br>样式的是scoped是通过css的属性选择器实现的。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day5</title>
    <url>/2019/10/28/vue1-05/</url>
    <content><![CDATA[<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function处理函数。即这个属性是用来监听data中数据改变从而进行相关操作的属性。</p>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>在computed中，可以定义一些属性，这些属性叫做【计算属性】，计算属性的本质就是一个方法，只不过，我们在使用这些计算属性的时候，是把他们的名称，直接当作属性来使用的，并不会把计算属性，当作方法去调用</p>
<a id="more"></a>
<p>注意：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、计算属性在引用的时候，一定不要加（）去调用，直接把它当作普通属性去使用就好</span><br><span class="line"><span class="number">2</span>、只要计算属性内部所依赖用到的任何data中的数据发生了变化，就会啊立即重新计算这个计算属性的值</span><br><span class="line"><span class="number">3</span>、计算属性的求值结果，会被缓存起来，方便下次直接使用，如果计算属性方法中，所有原来的任何数据，都没有发生过变化，则不会重新对计算属性求值</span><br></pre></td></tr></table></figure>

<h2 id="watch、computed、methods的对比"><a href="#watch、computed、methods的对比" class="headerlink" title="watch、computed、methods的对比"></a>watch、computed、methods的对比</h2><p>watch和computed都是一个function。<br>1、在watch中没有return值，在computed中有一个return值<br>2、methods中的function更侧于业务逻辑的处理。在其中可以写大量业务逻辑<br>3、computed中不能写大量逻辑<br>4、computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用<br>5、methods方法表示一个具体的操作，主要书写业务逻辑<br>6、watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些待定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是computed跟methods的结合体 </p>
<h2 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a>nrm的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的npm服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的npm服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、运行```npm i nrm -g```全局安装nrm包</span><br><span class="line"><span class="number">2</span>、使用``` nrm ls```查看当前所有可以的镜像源地址以及当前所使用的镜像源地址</span><br><span class="line"><span class="number">3</span>、使用```nrm use npm ```或者```nrm use taobao```切换不同的镜像源地址</span><br></pre></td></tr></table></figure>

<p>注意：nrm只是单纯的提供了几个常用的下载包url地址，并能够让我们在这几个地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的装包工具都是npm。</p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h4 id="在网页中会引用哪些常见的静态资源？"><a href="#在网页中会引用哪些常见的静态资源？" class="headerlink" title="在网页中会引用哪些常见的静态资源？"></a>在网页中会引用哪些常见的静态资源？</h4><ul>
<li>js<ul>
<li>.js .jsx .coffee .ts(类c#语言)</li>
</ul>
</li>
<li>css<ul>
<li>.css .less .sass</li>
</ul>
</li>
<li>images<ul>
<li>.jpgg  .imag  .png  .gif  .svg</li>
</ul>
</li>
<li>字体文件（fonts）<ul>
<li>.svg .ttf .eot .woff .woff2</li>
</ul>
</li>
<li>模板文件<ul>
<li>.ejs .jade  .vue(在webpack中定义组件的方式，推荐这么用)</li>
</ul>
</li>
</ul>
<h4 id="网页中引入的静态资源多了以后有什么问题"><a href="#网页中引入的静态资源多了以后有什么问题" class="headerlink" title="网页中引入的静态资源多了以后有什么问题"></a>网页中引入的静态资源多了以后有什么问题</h4><p>1、网页加载速度慢，因为我们要发起很多的二次请求<br>2、要处理错综复杂的依赖关系</p>
<h4 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h4><p>1、合并、压缩、雪碧图、图片的sass64编码<br>2、可以使用之前学过的requireJS，也可以使用webpack解决各个包之间的复杂关系</p>
<h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h4><p>webpack是前端的一个项目构建工具，它是基于node开发出来的一个前端工具</p>
<h4 id="如何完美实现上述的2种方案"><a href="#如何完美实现上述的2种方案" class="headerlink" title="如何完美实现上述的2种方案"></a>如何完美实现上述的2种方案</h4><p>1、使用Gulp，是基于task任务的，优点小巧灵活方便做一些小的项目<br>2、使用webpack，是基于整个项目进行构建的，站在更宏观的角度来观看项目</p>
<ul>
<li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能</li>
<li>根据官网的图片介绍webpack的打包过程</li>
<li>官网webpack.github.io/</li>
</ul>
<h4 id="安装webpack的两种方式"><a href="#安装webpack的两种方式" class="headerlink" title="安装webpack的两种方式"></a>安装webpack的两种方式</h4><p>1、运行<code>npm webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令<br>还需要安装wepack-cli，也是全局的才可以<br>2、在项目根目录中运行<code>npm i webpack --save--dev</code>安装到项目依赖中</p>
<p>运行的webpack命令<br>详情见浏览器webpack标签页收藏。</p>
<p>经过演示，webpack可以做什么事情？<br>1、webpack能够处理js文件之间的相互依赖关系；<br>2、webpack能够处理js的兼容问题，把高级的浏览器不识别的语法，转换为低级的，浏览器能够正常识别到的语法</p>
<p>####webpack watch模式<br><code>webpack --watch</code>,这个是热部署（hot replace），也就是实时监听项目中改变属性的时候，不用在终端输入webpack命令重新启动，可以直接就在浏览器上进行刷新显示更改后的浏览器页面。就相当于node中的<code>nodemon</code>，是一个实时监控器。在webpack4.x版本中，可以直接使用watch模式，使用方法很简单：直接在package.json里面添加一个脚本（找到script）：<code>&quot;watch&quot;:&quot;webpack --watch&quot;</code>，就可以实现热部署了。使用的时候，在命令脚本终端输入<code>npm run watch</code>，就可以实时监控了</p>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>使用webpack-dev-server这个工具，来实现自动打包编译的功能<br>1、运行npm i webpack-dev-server -D把这个工具安装到项目的本地开发依赖<br>2、安装完毕后，这个工具的用法和webpack命令的用法完全一样。只是需要把webpack替换成webpack-dev-server，自动监听<br>3、由于我们是在项目中本地安装的webpack-dev-server，所以我无法把它当作脚本命令，在powershell终端直接运行；（只有哪些安装到全局-g的工具们才能在终端中正常执行）<br>4、注意，webpack-dev-server这个工具，如果想要正常运行，要求，在本地项目中必须安装webpack，就算全局已经安装过了，也需要再在本地安装一下<br>5、webpack-dev-server帮我们打包生成的bundle.js文件，并没有存放到实际的物理磁盘上；而是直接托管到了电脑的内存中，所以我们在项目根目录中，根本找不到这个打包好的main.js<br>6、我们可以任务webpack-dev-server把打包好的文件，以一种虚拟的形似，托管到了咱们项目中的根目录中，虽然我们看不到它，但是可以认为，和dist src node_modules平级，有一个看不见的文件，叫做main.Js，浏览器打开的页面是物理上的页面不是电脑内存的页面</p>
<h4 id="webpack-dev-server常用命令"><a href="#webpack-dev-server常用命令" class="headerlink" title="webpack-dev-server常用命令"></a>webpack-dev-server常用命令</h4><p>直接在package.json文件中中的script标签里面里</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">"dev":</span> <span class="comment">"webpack</span><span class="literal">-</span><span class="comment">dev</span><span class="literal">-</span><span class="comment">server</span> --<span class="comment">open</span> --<span class="comment">port</span> <span class="comment">3000</span> --<span class="comment">contentBase</span> <span class="comment">src</span> --<span class="comment">hot"</span></span><br></pre></td></tr></table></figure>
<p>表示的是自动打开浏览器，并且在端口号3000打开，直接进入src中的首页面，–hot表示热重载热更新。</p>
<p><code>热重载</code>：如果没有热重载的话，每次更新生成的都是一个完整的js文件，有了热更新热重载，每次更新的时候不会生成完整的一个js文件，只是会在原有的js文件上，把新增加的或者新改变的代码作为一个补丁添加上去，就好比添加补丁做补充。这样做的好处就是减少不必要的代码更新。</p>
<p>同时使用–hot以后可以实现浏览器的无刷新重载。</p>
<h4 id="webpack-dev-server’配置命令的第二种方式："><a href="#webpack-dev-server’配置命令的第二种方式：" class="headerlink" title="webpack-dev-server’配置命令的第二种方式："></a>webpack-dev-server’配置命令的第二种方式：</h4><p>在package.json文件中添加的代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入webpack包，启用热更新的第二部</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --port 3000 --contentBase src --hot"</span></span><br></pre></td></tr></table></figure>

<p>在webpack.json.js文件中添加的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    entry:  <span class="string">'./src/index.js'</span>,<span class="comment">//入口，表示要使用webpack打包哪个文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">//输出文件相关的配置</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./dist'</span>),<span class="comment">//指定打包好的文件输出到哪个目录中去</span></span><br><span class="line">        filename: <span class="string">'main.js'</span> <span class="comment">//指定输出的文件的名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">    	<span class="comment">//这是配置dev-server命令参数的第二种形式，相对比较麻烦</span></span><br><span class="line">    	<span class="comment">// --open --port 3000 --contentBase src --hot </span></span><br><span class="line">    	open: <span class="keyword">true</span>,<span class="comment">//自动打开浏览器</span></span><br><span class="line">    	port: <span class="number">3000</span>,<span class="comment">//设置启动时候的运行窗口</span></span><br><span class="line">    	contentBase: <span class="string">'src'</span>,<span class="comment">//指定托管的根目录</span></span><br><span class="line">    	hot: <span class="keyword">true</span><span class="comment">//启用热更新的第一步</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">       <span class="comment">//配置插件的节点</span></span><br><span class="line">       <span class="keyword">new</span> webpack.hotModuleReplacementPlugin()  <span class="comment">//new一个热更新的模块对象，启用热更新的第三步</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用html-webpack-plugin插件配置启动页面</h3><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐使用<code>html-webpack-olugin</code>插件配置启动页面。<br>1、运行<code>npm i html-webpack-plugin --save-dev</code>安装到开发依赖<br>2、修改<code>webpack.config.js</code>的配置文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入路径的模块</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//导入自动生成HTML文件的插件</span></span><br><span class="line"><span class="keyword">var</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: path.resolve(_dirname, <span class="string">'src/js/index.js'</span>),<span class="comment">//项目入口文件</span></span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(_dirname,<span class="string">'dist'</span>),</span><br><span class="line">		filename: <span class="string">'bundle.js'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">	    <span class="keyword">new</span> htmlWebpackPlugin(&#123;<span class="comment">//创建一个在内存中生成HTML页面的插件</span></span><br><span class="line">	    	template:path.resolve(_dirname, <span class="string">'src/main.html'</span>),<span class="comment">//指定模板页面，将来会根据指定的页面路径，去生成内存中的页面</span></span><br><span class="line">	    	filename: <span class="string">'main.html'</span><span class="comment">//指定生成页面的名称</span></span><br><span class="line">	    	&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、修改<code>package.json</code>中的<code>script</code>节点的dev指令如下</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br></pre></td></tr></table></figure>
<p>4、将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把main.js注入到html页面中</p>
<p>作用：<br>1、在内存中根据指定路径帮我们生成一个页面，把打包好的main文件自动插入到dom元素中去<br>2、当使用html-webpack-plugin之后我们不再需要手动处理main.js的引用路径，因为这个插件已经帮我们自动创建了一个合适的script，并且引用了正确的路径。自动把打包好的main.js追加到页面中去</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>加载js文件直接使用import然后打包就可以，但是使用其他样式表，例如css文件，就不能直接使用import打包的方式来。<br>webpack默认只能打包处理js类型的文件，无法处理其他的非js类型的文件。如果要处理非js类型的文件，我们需要手动安装一些合适第三方loader加载器。</p>
<p>1、如果想打包css文件，需要安装npm i style-loader css-loader -D这两个文件<br>2、打开webpack.config.JS这个配置文件，在里面新增一个配置节点，叫做module，他是一个对象，在这个module对象身上，有个rules属性，这rules属性是个数组，这个数组中存放了所有第三方文件的匹配和处理规则。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    entry:  <span class="string">'./src/index.js'</span>,<span class="comment">//入口，表示要使用webpack打包哪个文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">//输出文件相关的配置</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./dist'</span>),<span class="comment">//指定打包好的文件输出到哪个目录中去</span></span><br><span class="line">        filename: <span class="string">'main.js'</span> <span class="comment">//指定输出的文件的名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        <span class="comment">//这个节点用于配置所有第三方模块加载器</span></span><br><span class="line">        rules:[</span><br><span class="line">            <span class="comment">//所有第三方模块的匹配规则</span></span><br><span class="line">            &#123; test: <span class="regexp">/\.css$/</span>, use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] &#125;<span class="comment">//配置处理.css文件的第三方loader规则，必须要有text和use属性</span></span><br><span class="line">            <span class="comment">//表示符合test中正则表达式的所有文件都使用对应后面所加载的loader文件</span></span><br><span class="line">            <span class="comment">//test表示要匹配到的文件类型，use表示对应文件类型要使用的loader文件</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有在webpack.config.js文件中找到对应的文件路径就会报错<br>如果同时添加了两个loader，调用规则就是<code>从右到左</code>。</p>
<h4 id="webpack处理第三方文件类型的过程："><a href="#webpack处理第三方文件类型的过程：" class="headerlink" title="webpack处理第三方文件类型的过程："></a>webpack处理第三方文件类型的过程：</h4><p>1、发现这个要处理的文件不是js 文件，然后就去配置文件中，查找有没有对应的第三方loader规则<br>2、如果能找到对应的规则就会调用对应的laoder处理这种文件类型<br>3、在调用loader的时候，是从后往前调用的<br>4、当最后一个loader调用完毕，会把处理的结果，直接交给webpack进行打包合并，最终输出到main.js中去</p>
<p>在文件根目录下的文件作用分析：<br>1、package.json文件，是在项目进行初始化的时候，所生成的一个配置文件，表示的是所搭建这个项目需要的哪些依赖，下载了哪些东西。<br>2、package-lock.json文件，表示在项目初始化的时候，所下载的哪些依赖他们的版本的锁定，以防下载更新依赖的时候，会有版本的问题<br>3、webpack.config.json文件，这个是打包webpack的时候需要用到的配置文件，当以webpack命令开始打包工具的时候，工具会发现并没有提供入口和出口文件，这个时候工具就会来检查项目根目录下的配置文件，并读取这个文件，拿到的导出的这个配置对象，然后根据这个配置文件的相关信息进行打包构建。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day4</title>
    <url>/2019/10/27/vue1-04/</url>
    <content><![CDATA[<h2 id="小球动画flag标识符的作用分析"><a href="#小球动画flag标识符的作用分析" class="headerlink" title="小球动画flag标识符的作用分析"></a>小球动画flag标识符的作用分析</h2><p>在半场小球动画案例中，的afterEnter钩子函数里面原先写的是<code>this.flag=！this.flag</code>，如果改成<code>el.style.opacity=0.5</code>，则会没有动画效果。<br>Vue把一个完整的动画，使用钩子函数，拆分为了两部分：我们使用flag标识符，来表示动画的切换；刚一开始，flag=false，然后变成true，然后便变成false。</p>
<a id="more"></a>

<h2 id="组件传值–父组件向子组件传值，data和props的区别"><a href="#组件传值–父组件向子组件传值，data和props的区别" class="headerlink" title="组件传值–父组件向子组件传值，data和props的区别"></a>组件传值–父组件向子组件传值，data和props的区别</h2><p>子组件中，默认无法访问到父组件中的data上的数据和methods中的方法。<br>父组件可以在引用子组件的时候，通过属性绑定（v-bind：）的形式，把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用。</p>
<p>把父组件传递过来的属性，先在props数组中，定义一下，这样我们才能在子组件中使用父组件的数据。</p>
<p>注意：<br>     + 组件中的所有props中的数据，都是通过父组件传递给自组件的。<br>     + 子组件中的data数据，并不是通过父组件传递过来的，而是子组件自己私有的，比如：子组件通过AJAX，请求回来的数据，都可以放到data身上。<br>     + props中的数据都是只读的，无法重新赋值<br>     + data上的数据都是可读可写的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 属性绑定在子组件标签中添加‘v-bind：自定义属性名称="父组件属性名称"’就可以达到属性绑定的目的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com1</span> <span class="attr">v-bind:parentmsg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">com</span>：&#123;</span><br><span class="line">	<span class="selector-tag">data</span>()&#123;</span><br><span class="line">		<span class="selector-tag">return</span>&#123;</span><br><span class="line">			<span class="attribute">title</span>:<span class="string">'123'</span>,</span><br><span class="line">			<span class="attribute">content</span>:<span class="string">'qqq'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attribute">template</span>:<span class="string">'&lt;h1&gt;nnnnn---&#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">	<span class="attribute">props</span>:[<span class="string">'parentmsg'</span>],</span><br><span class="line">	<span class="attribute">directives</span>:&#123;&#125;,</span><br><span class="line">	<span class="attribute">filters</span>:&#123;&#125;,</span><br><span class="line">	<span class="attribute">methods</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件传值–子组件通过事件调用向父组件传值（父组件把方法传递给子组件）"><a href="#组件传值–子组件通过事件调用向父组件传值（父组件把方法传递给子组件）" class="headerlink" title="组件传值–子组件通过事件调用向父组件传值（父组件把方法传递给子组件）"></a>组件传值–子组件通过事件调用向父组件传值（父组件把方法传递给子组件）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件向子组件传递方法，使用的是事件绑定机制：v-on，当我们自定义了一个事件属性之后，那么子组件就能够通过某些方法来调用传递进去的这个方法了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事件绑定在子组件标签中添加‘v-on：自定义事件名称="父组件事件名称"’就可以达到事件绑定的目的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com1</span> <span class="attr">v-on:func</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;com1 @func="show"&gt;&lt;/com1&gt;  --&gt;</span></span><br><span class="line">//如果改成<span class="tag">&lt;<span class="name">com1</span> @<span class="attr">func</span>=<span class="string">"show（）"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span>，就说明是调用方法，把调用该方法的结果传递给这个事件 </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件中的方法</span></span><br><span class="line">methods:&#123;</span><br><span class="line">		show(<span class="built_in">data</span>,data2)&#123;</span><br><span class="line">			console.<span class="keyword">log</span>(<span class="string">'aaaa'</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">com：&#123;</span><br><span class="line">	<span class="keyword">data</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span>&#123;</span><br><span class="line">			title:<span class="string">'123'</span>,</span><br><span class="line">			content:<span class="string">'qqq'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	template:<span class="string">'&lt;h1&gt;nnnnn---&#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">	props:[<span class="string">'parentmsg'</span>],</span><br><span class="line">	directives:&#123;&#125;,</span><br><span class="line">	filters:&#123;&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		<span class="comment">//当点击子组件的按钮的时候，如何拿到父组件传递过来的func方法，并调用这个方法</span></span><br><span class="line">        <span class="comment">//emit：英文原意是触发调用发射意思</span></span><br><span class="line">		<span class="keyword">this</span>.$emit(<span class="string">'func'</span>,<span class="number">123</span>,<span class="number">456</span>)<span class="comment">//调用的func是传递过来的事件绑定的自定义事件名称</span></span><br><span class="line">		<span class="comment">//从第二个位置以后都可以进行传参。跟父组件中的方法中需要的参数进行传递</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用ref获取DOM元素和组件"><a href="#使用ref获取DOM元素和组件" class="headerlink" title="使用ref获取DOM元素和组件"></a>使用ref获取DOM元素和组件</h2><p> ref是英文单词reference的简写。<br>通过ref可以拿到组件的引用和一些组件的数据。<br>ref也可以拿到一些DOM元素，并且可以在不直接操作DOM元素的情况下去操作DOM元素。引用的时候要加refs，但是绑定的时候不用加s，只用写ref就可以了。由于refs是挂载在实例上的一个对象属性，所以，需要在vm中使用，并且需要添加this来使用。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;h3 <span class="built_in">id</span>=<span class="string">"myh3"</span> <span class="keyword">ref</span>=<span class="string">"myh3"</span>&gt;hhhhh&lt;/h3&gt;</span><br><span class="line">&lt;login <span class="keyword">ref</span>=<span class="string">"mylogin"</span>&gt;&lt;/login&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var login = &#123;</span><br><span class="line">	template:<span class="string">'&lt;h1&gt;login&lt;/login&gt;'</span>,</span><br><span class="line">	data()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			ms<span class="variable">g:</span><span class="string">'son msg'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	method<span class="variable">s:</span>&#123;</span><br><span class="line">		show()&#123;</span><br><span class="line">			console.<span class="built_in">log</span>(<span class="string">'调用了子组件的方法'</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="keyword">e</span><span class="variable">l:</span><span class="string">'app'</span>,</span><br><span class="line">	dat<span class="variable">a:</span>&#123;&#125;,</span><br><span class="line">	method<span class="variable">s:</span>&#123;</span><br><span class="line">		getelements()&#123;</span><br><span class="line">			//console.<span class="built_in">log</span>(this.$refs.myh3.innerText)</span><br><span class="line">			//console.<span class="built_in">log</span>(this.$refs.mylogin.msg),访问子组件中的数据</span><br><span class="line">			//this.$refs.mylogin.show()访问子组件中的方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	component<span class="variable">s:</span>&#123;</span><br><span class="line">		login</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>1、后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源。<br>2、前端路由：对于单页面应用程序来说，主要通过URL中的hash（#）来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容，所以，单页面程序中的原页面跳转主要用hash实现<br>3、在单页面应用程序中，这种通过hash改变切换页面的方式，乘坐前端路由。（区别于后端路由）</p>
<h3 id="在vue中使用vue-router"><a href="#在vue中使用vue-router" class="headerlink" title="在vue中使用vue-router"></a>在vue中使用vue-router</h3><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>创建一个路由对象，当导入vue-router包之后，在window全局对象中，就有了一个路由的构造函数，叫做VueRouter，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//组件模板对象</span><br><span class="line">var login = &#123;</span><br><span class="line">	template:'<span class="tag">&lt;<span class="name">h1</span>&gt;</span>login<span class="tag">&lt;/<span class="name">login</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var register = &#123;</span><br><span class="line">	template:'<span class="tag">&lt;<span class="name">h1</span>&gt;</span>register<span class="tag">&lt;/<span class="name">login</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- var login = Vue.component('login', &#123;</span></span><br><span class="line"><span class="comment">	template:'&lt;h1&gt;login&lt;/login&gt;'</span></span><br><span class="line"><span class="comment">	&#125;) --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个对象，在new路由对象的时候，可以为构造函数传递一个配置对象</span></span><br><span class="line">var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	<span class="comment">//route //这个配置对象中的route 表示【路由匹配规则】的意思</span></span><br><span class="line"><span class="symbol">	routes:</span>[</span><br><span class="line">	<span class="comment">//路由匹配规则，每个路由都是一个对象，这个规则对象，身上有两个必须的属性：</span></span><br><span class="line">	<span class="comment">//属性1：是path，表示监听哪个路由连接地址；</span></span><br><span class="line">	<span class="comment">//属性2：是component，表示如果路由时前面匹配到的path，则展示component属性对应的哪个组件</span></span><br><span class="line">	<span class="comment">//注意：component的属性值，必须是一个组件模板对象，不能是组件的引用名称；</span></span><br><span class="line">	&#123; <span class="string">path:</span><span class="string">'/login'</span>,<span class="string">component:</span> login &#125;,</span><br><span class="line">	&#123; <span class="string">path:</span><span class="string">'register'</span>,<span class="string">component:</span> register&#125;</span><br><span class="line">	]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//vm实例对象</span></span><br><span class="line">var vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="symbol">        el:</span><span class="string">'#app'</span>,</span><br><span class="line"><span class="symbol">        data:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">        methods:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">        components:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">        router:</span> routerObj<span class="comment">//将路由规则对象，注册到vm实例上，用来监听URL地址的变化，然后展示对应的组件</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<p>.router-link-active是路由选中时候的样式设置，是默认的，如果想要修改该属性名称，需要在router构造函数添加一个<code>linkActiveClass：&#39;myclass&#39;</code>来对其进行属性名称修改，这样的话，在设置路由高亮时候的属性名称就要写成.myclass：{}<br>来对其进行路由高亮显示设置了。</p>
<h3 id="为路由页面切换添加动画"><a href="#为路由页面切换添加动画" class="headerlink" title="为路由页面切换添加动画"></a>为路由页面切换添加动画</h3><p>只需要把router-view标签用transition标签包裹起来，然后再进行动画设计</p>
<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h4><p>query传参是挂载到一个路由对象上，通过调用路由对象的属性来进行传参的。<br>query可以多个传参，传参方式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login?id=10&amp;name=zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果再路由中，使用查询字符串，给路由传递参数，则不需要修改路由规则（就是router实例中的route对象挂载的几个对象的path）的path属性。<br>通过this.$route.query.id来获取id的值，this.$route是路由对象，里面有很多路由对象的属性挂载。可以省略this。<br>模板对象为：</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">var login = &#123;</span><br><span class="line">	<span class="attribute">template</span>: '&lt;h1&gt;login-----&#123;&#123; this.$route<span class="variable">.query</span><span class="variable">.id</span> &#125;&#125;-----&#123;&#123; $route<span class="variable">.query</span><span class="variable">.name</span> &#125;&#125;'//或者$route<span class="variable">.query</span><span class="variable">.id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以query也可以在模板对象上获取多个数据</p>
<p>优点：1、不需要修改path路径规则<br>      2、拿到参数直接通过this.$route.query.参数名或者$route.query.参数名拿到参数</p>
<h4 id="params方式传递路由参数"><a href="#params方式传递路由参数" class="headerlink" title="params方式传递路由参数"></a>params方式传递路由参数</h4><p>这个方式说明的是，在/login后面放的就是id这个参数，会一一对应起来。传递参数的时候，直接就在router-link里面的to的路径后面添加要传递的id值过去就行了。具体如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="symbol">	routers:</span> [</span><br><span class="line">	&#123; <span class="string">path:</span> <span class="string">'/login/:id/:name'</span>,<span class="string">component:</span> login &#125;,</span><br><span class="line">	&#123; <span class="string">path:</span> <span class="string">'/register/:id/:name'</span>,<span class="string">component:</span> register &#125;,</span><br><span class="line">	]</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login/12/zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>要输出到页面上的化，需要在模板对象上面添加变量显示出来</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">var login = &#123;</span><br><span class="line">	<span class="attribute">template</span>: '&lt;h1&gt;login-----&#123;&#123; this.$route<span class="variable">.params</span><span class="variable">.id</span> &#125;&#125;-----&#123;&#123; $route<span class="variable">.params</span><span class="variable">.name</span> &#125;&#125;'//或者$route<span class="variable">.query</span><span class="variable">.id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>通过children属性来进行路由嵌套，不过在route属性中的children属性中，添加的path对象的路径不能添加/。<br>子路由的path前面不要带/。否则永远以根路径开始请求，这样不方便我们用户去理解URL地址</p>
<h3 id="使用命名视图实现经典视图"><a href="#使用命名视图实现经典视图" class="headerlink" title="使用命名视图实现经典视图"></a>使用命名视图实现经典视图</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接给每一个坑取一个name属性，然后显示相应属性名字的组件，没有的就显示default的组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 命名视图 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接用三个占位符来分别展示不同组件，从而实现命名试图</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">            route<span class="variable">s:</span> [</span><br><span class="line">                // &#123; path: <span class="string">'/'</span>, componen<span class="variable">t:</span> header &#125;,</span><br><span class="line">                // &#123; path: <span class="string">'/left'</span>, componen<span class="variable">t:</span> <span class="keyword">left</span> &#125;,</span><br><span class="line">                // &#123; path: <span class="string">'/main'</span>, componen<span class="variable">t:</span> main &#125;,</span><br><span class="line">                //这种方法是不可行的</span><br><span class="line"></span><br><span class="line">                &#123; </span><br><span class="line">                    path: <span class="string">'/'</span>, </span><br><span class="line">                    component<span class="variable">s:</span> &#123;</span><br><span class="line">                        <span class="string">'default'</span>: header,//默认放的组件</span><br><span class="line">                        <span class="string">'left'</span>:<span class="keyword">left</span>,</span><br><span class="line">                        <span class="string">'main'</span>:main</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day3</title>
    <url>/2019/10/21/vue1-03/</url>
    <content><![CDATA[<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>步骤：<br>1、导入vue-resource包，所以可以直接通过this.$http来发起数据请求<br>2、根据接口API文档，知道获取列表的时候，应该发起一个get请求<br>3、this.$http.get（’url’）.then（function（result）{}）<br>4、当通过then指定回调函数之后，再回调函数中，可以拿到数据服务器返回的result（数据格式是json）<br>5、先判断result.status是否等于0，如果等于0，就成功了，可以把result是一个对象，result.body.massage赋值给this.list；如果不等于0，可以弹框提醒，获取数据失败！</p>
<a id="more"></a>
<p>只有返回数据中的result.body.status=0，才说明这个请求成功。result.body.massage是返回结果里面的所有 信息，就会把所有能获取到的信息都返回给一个数组，进行储存或者显示</p>
<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>步骤分析：<br>1、经过查看数据API接口，要发送一个post请求，this.$http.post()<br>2、this.$http.post()中接受三个参数</p>
<ul>
<li>第一个参数：要请求的url地址</li>
<li>第二个参数：要提交给服务器的数据，要以对象形式提交到服务器（name：this.name）</li>
<li>第三个参数：是一个配置对象，要以哪种表单数据类型提交过去，{emulateJSON：true}，以普通表单格式，将数据提交给服务器application/x-www-form-urlencoded，这个参数一般是必须的，如果不传入的话，也可能会出问题。<br>3、再post方法中，使用.then来设置成功的回调函数，如果想要拿到成功的结果，需要result.body。</li>
</ul>
<p>注意：第二个参数和第三个参数都是以对象形式进行传参，所以都要加{xxx}，{xxx}</p>
<p>对{emulateJSON：true}进行全局配置，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">在Vue实例之前进行添加一句</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>http.options.emulateJSON = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，会全局启用emulateJSON</p>
<p>如果我们通过全局配置了，请求的数据接口 根域名，则再每次单独发起http请求的时候，请求的url路径，应该以相对路径开头，强调，后面的相对路径前面不能带/，否则就不是相对路径。</p>
<h2 id="vue中的动画"><a href="#vue中的动画" class="headerlink" title="vue中的动画"></a>vue中的动画</h2><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><p>1、html结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动起来"</span> @<span class="attr">click</span>=<span class="string">"myanimate"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用transition将需要过渡的元素包裹起来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>transition中的name=“”中的值是自定义的前缀，如果如上所示，则用fade-enter来进行动画控制。不自定义的话，直接就是v-enter。</p>
<p>2、vm实例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建vue实例，得到viewmodel</span></span><br><span class="line"><span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">	el:<span class="string">'#app'</span>,</span><br><span class="line">	<span class="keyword">data</span>:&#123;</span><br><span class="line">		isshow:<span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		myanimate()&#123;</span><br><span class="line">			<span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤分析：</span><br><span class="line"><span class="number">1</span>、使用transition元素，把需要被动画控制的元素包裹起来。transition元素，是vue官方提供的</span><br><span class="line"><span class="number">2</span>、自定义两组样式，来控制transition内部的元素实现动画。v-enter：进入之前，元素的起始状态，此时还没有进入【这是一个时间点】；v-leave-to：是动画离开之后，离开的终止状态，此时元素已经结束了。v-enter-active：入场动画时间段，v-leave-active：离场时间段。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用第三方animate.css类库实现动画</span><br><span class="line">animate.css，可以直接在百度进行搜索该网页，进行动画展示</span><br><span class="line">在对transition进行添加我们所选择的类样式之外，还需要再样式前面加一个一个基本类样式animated</span><br></pre></td></tr></table></figure>
<transition enter-active-class="bounceinIn" leave-active-class="bounceOut">
<div v-show="isshow" class="animated">动画</div>
</transition>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">或者使用这种方式</span><br></pre></td></tr></table></figure>
<transition enter-active-class="animated bounceinIn" leave-active-class="animated bounceOut">
<div v-show="isshow">动画</div>
</transition>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">再transition标签后面添加```<span class="symbol">:duration=<span class="string">"200"</span>```</span>表示该动画所需要的时长。</span><br><span class="line">如果改成在transition标签后面添加```<span class="symbol">:duration=<span class="string">"&#123;enter:200,leave:400&#125;"</span>```</span>表示分别给入场和离场设置时间。即如果用一个对象来设置duration的话就是分别给两个动画来设置动画时长。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 钩子函数实现半场动画</span></span><br><span class="line">即只有进入没有离开的动画，我们叫做半场动画。用上述的两种方法和自定义的函数方法都不能够实现半场动画，所以这个时候就需要使用钩子函数来实现。</span><br><span class="line"></span><br><span class="line">可以在属性中声明javascript钩子</span><br></pre></td></tr></table></figure>
<transition
 v-on:before-enter="beforeEnter"
 v-on:enter="enter"
 v-on:after-enter="afterEnter"
 v-on:enter-cancelled="enterCancelled"

<p> v-on:before-leave=”beforeLeave”<br> v-on:lever=”leave”<br> v-on:after-leave=”afterLeave”<br> v-on:leave-cancelled=”leaveCancelled”</p>
<blockquote>
</blockquote>
 </transition>
 <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">都可以称作动画的生命周期函数，前一部分是进入，后一部分是离开。上述有八个事件，那么对应的在<span class="keyword">methods</span>中也有对应的八个函数方法。来对此进行定义。如果只需要半场函数的话，那我们就只需要前面一部分的事件，而不需要后面一部分的事件。</span><br></pre></td></tr></table></figure>
 methods:{
     //进入中
     beforeEnter:function(el){},


<p> }</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">当只用 <span class="keyword">JavaScript </span>过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</span><br><span class="line"></span><br><span class="line">推荐对于仅使用 <span class="keyword">JavaScript </span>过渡的元素添加 v-<span class="keyword">bind:css="false"，Vue </span>会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现列表动画</span></span><br><span class="line">样式设计</span><br></pre></td></tr></table></figure>
<p>.v-enter,<br>    .v-leave-to{<br>        opacity: 0;<br>        transform:translateY(80px);<br>    }</p>
<pre><code>.v-enter-active,
.v-leave-active{
    transition:all 0.6s ease;
}</code></pre><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">在实现列表过度的时候，如果需要过渡的元素是通过v-for循环渲染出来的，不能使用<span class="attribute">transition</span>包裹，需要使用transitionGroup包裹。</span><br></pre></td></tr></table></figure>
<ul>
            <transition-group>
                    <li v-for="item in list" :key="item.id">
                             --- 
                        </li>
            </transition-group>
</ul>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果要为v-for循环创建的元素设置动画，必须为每一个元素设置：key属性</span><br><span class="line"></span><br><span class="line">### 列表删除动画</span><br><span class="line">只需要在上述基础上再添加以下样式就可以了，一般都是固定写法。还要注意的是，需要在li样式中添加width属性值，避免```position：absolute```在起作用的同时，也会将宽度变为最小值。</span><br></pre></td></tr></table></figure>
.v-move{
        transition:all 0.6s ease;
    }
.v-leave-active{
        position:absolute;
    }
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### transition-group中的appear和tag属性</span><br><span class="line">给transition-group添加apper属性，实现页面刚展示出来入场时候 的效果。</span><br></pre></td></tr></table></figure>
<transition-group appear>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果就直接按照上述规则填写的话，在页面检查元素检查出来会发现页面将transition-group标签渲染成span标签了。</span><br><span class="line">解决办法是去掉ul标签，然后在```&lt;transition-group appear tag=<span class="string">"ul"</span>&gt;```添加tag=<span class="string">"ul"</span>属性值就可以了。</span><br><span class="line"></span><br><span class="line">通过为transition-group元素，设置tag属性，指定transition-group渲染为指定的元素，如果不指定tag属性，默认渲染为span标签。</span><br><span class="line"></span><br><span class="line">## vue组件</span><br><span class="line">什么是组件？组件的出现就是为了拆分vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块。将来我们需要什么样的功能，就去调用对应的组件即可。</span><br><span class="line"></span><br><span class="line">组件话和模块化的不同？</span><br><span class="line">+ 模块化是从代码逻辑的角度进行划分的。方便代码的分层开发，保证每个功能模块的职能单一</span><br><span class="line">+ 组件化是从UI界面的角度进行划分的 。前端的组件化，方便UI组建的重用</span><br><span class="line"></span><br><span class="line">### 创建组件</span><br><span class="line">#### 方式一：使用Vue.extend来创建全局的Vue组件</span><br><span class="line">这些创建过程是在script标签中创建的</span><br></pre></td></tr></table></figure>
//1、使用Vue.extend来创建全局的Vue组件
var com1 = Vue.extend({
    template:'<h3>这是使用Vue.extend创建的组件</h3>'//通过template属性，指定了组件要展示的HTML结构，将来要展示的具体内容
    })
//2、使用Vue.component('组件的名称，将来要引用的名称',创建出来的组件模板对象)
Vue.component('mycom1',com1)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">引用组件：</span><br></pre></td></tr></table></figure>
//如果要使用组件，直接把组件的名称，以HTML标签的形式，引入到页面中
<my-com1></my-com1>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">注意：在创建的时候，可以使用驼峰的方法来书写名称，但是在使用的时候，需要使用带-的方式来写，即把大写的驼峰改成小写的字母带-来表示。如果不写驼峰，直接拿名称就可以了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">直接把上述步骤合成一个步骤即可</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>component第一个参数：组件的名称，将来在引用组件的时候，就是一个标签形式来引入它的/第二个参数：<span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>extend（）创建的组件，template就是组件将来要展示的HTML内容。</span><br></pre></td></tr></table></figure>
Vue.component('myCom1',Vue.extend({
    template:''
    }))
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 方式二创建组件</span><br></pre></td></tr></table></figure>
Vue.component('mycom2',{
    template:'<h3>这是直接使用Vue.component创建出来的组件</h3>'
    })
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">引用的时候，还是使用标签的形式，引入自己的组件。</span><br><span class="line"></span><br><span class="line">注意：无论是哪种方式创建出来的组件，组建的template属性指向的模板内容，必须有且只有唯一的一个根元素。</span><br><span class="line"></span><br><span class="line">#### 创建组件方式三</span><br></pre></td></tr></table></figure>
Vue.component('mycom3',{
    template:'#temp1'
    })
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用方式，在被控制的<span class="meta">#app外面使用template元素，定义组件的模板结构</span></span><br></pre></td></tr></table></figure>
<div id="app">
<mycom3></mycom3>//引用组件
</div>//这是vm实例控制部分


<template id="temp1">
  <div>
   <h3>这是通过template元素，在外部定义的组件结构，这个方式，有代码的只能提示个高亮</h3>
   <h4>好用</h4>
  </div>
</template>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 使用component定义私有组件</span><br><span class="line">上述的都是全局组件，</span><br></pre></td></tr></table></figure>
var vm = new Vue({
    el:'#app2',
    data:{},
    methods:{},
    filters:{},
    directives:{},
    components:{
        //定义实例内部私有组件，不和其他公用，在实力内部自己使用
        login：'<h1>这是私有的login组件</h1>'
    }
    })
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">调用，只能在控制的实例上app2上使用</span><br></pre></td></tr></table></figure>
<div id="app2">
<login></login>
</div>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">也可以像上述方式的改进一样，写在template里面，对其进行整合</span><br><span class="line"></span><br><span class="line">### 组件中的<span class="keyword">data</span></span><br><span class="line">组件中也有一个<span class="keyword">data</span>，但是跟实例中的<span class="keyword">data</span>不一样，组件的<span class="keyword">data</span>必须是一个<span class="function"><span class="keyword">function</span></span>并且<span class="keyword">return</span>一个对象，但实例中的<span class="keyword">data</span>是一个对象。组件中的<span class="keyword">data</span>数据使用方式和实例中的<span class="keyword">data</span>数据使用方式完全一样。</span><br></pre></td></tr></table></figure>
Vue.component('mycom1',{
    template:'<h1>这是一个全局组件---</h1>',
    data:function(){
        return{
            msg:'这是组件中的data定义的数据'
        }
    }
    })
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 为什么组件中的data中必须是一个function</span><br><span class="line">例如</span><br></pre></td></tr></table></figure>
<template id="tmp1">
<div>
<input type="button" value="+1" @click="increment">
<h3></h3>
</div>
<template>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line">var dataObj=&#123;<span class="built_in">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">//这是一个计数器的组件，身上有个按钮，每当点击按钮，让<span class="keyword">data</span>中的<span class="built_in">count</span>加<span class="number">1</span></span><br><span class="line">Vue.component(<span class="string">'counter'</span>,&#123;</span><br><span class="line">	template:<span class="string">'#tmp1'</span>,</span><br><span class="line">	<span class="keyword">data</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dataObj  //这种方法不推荐，最好是<span class="keyword">return</span>&#123;<span class="built_in">count</span>：<span class="number">0</span>&#125;因为这样的话他们就互相不会干扰</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		increment()&#123;</span><br><span class="line">			this.<span class="built_in">count</span>++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h3><p>使用v-if和v-else结合flag进行切换<br>定义一个flag，让默认组件显示为v-if=”flag”，然后另外一个组件设置v-else=”flag”就可以了。<br>缺点就是只能切换两个画面，如果有三个以上的就需要另外的方法。</p>
<h4 id="组件切换方式二"><a href="#组件切换方式二" class="headerlink" title="组件切换方式二"></a>组件切换方式二</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- vue提供了component，来展示对应名称的组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- component是一个占位符，：is属性可以用来指定要展示的组件的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"componentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>错误使用：<code>&lt;component :is=&quot;counter&quot;&gt;&lt;/component&gt;</code>因为组件名称是一个字符串，在component的is属性用了属性绑定，所以要写<br><code>&lt;component :is=&quot;&#39;counter&#39;&quot;&gt;&lt;/component&gt;</code>使用字符串将其绑定</p>
<p>总结：当前学习的vue标签：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;component&gt;</span>   <span class="attribute">template</span>   transition   transitionGroup</span><br></pre></td></tr></table></figure>

<h4 id="应用切换动画和mode方式"><a href="#应用切换动画和mode方式" class="headerlink" title="应用切换动画和mode方式"></a>应用切换动画和mode方式</h4><p>多个组件的过渡我们不需要使用key属性，我们只需要使用动态组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"component-fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="keyword">e</span><span class="variable">l:</span><span class="string">""</span>,</span><br><span class="line">	dat<span class="variable">a:</span>&#123;</span><br><span class="line">		<span class="keyword">vie</span><span class="variable">w:</span><span class="string">'v-a'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	componen<span class="variable">t:</span>&#123;</span><br><span class="line">		<span class="string">'v-a'</span>:&#123;</span><br><span class="line">			template:<span class="string">''</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'v-b'</span>:&#123;</span><br><span class="line">			template:<span class="string">''</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>mode属性的”out-in”指的是先出去的动画结束了才进来，也可以改成”in-out”就是先进来在出去<br>通过mode属性设置组件切换时候的模式。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day2</title>
    <url>/2019/10/19/vue1-02/</url>
    <content><![CDATA[<h2 id="小碎片"><a href="#小碎片" class="headerlink" title="小碎片"></a>小碎片</h2><p>1、在vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了。<br>2、在vue中，已经实现了数据的双向绑定，每当我们修改了data中的数据，vie会默认监听到数据的改动，自动把最新的数据应用到页面上。<br>3、之前，v-for中的数据都是直接从data上的list直接渲染过来的；现在我们自定义了一个serch方法，同时，把所有的关键字，通过传参的形式，传递给了search方法。<br>4、forEach、some、filter、findIndex 这些都属于数组的新方法，都会对数组中的每一项，进行遍历，执行相关的操作。<br>5、ES6中，为字符串提供了一个新的方法，叫做string.prototype.includes(‘要包含的字符串’)；如果包含，则返回true，否则返回false。</p>
<a id="more"></a>
<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>vue允许自定义被过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。过滤器应该被添加在js表达式的尾部，有管道标识符标识</p>
<p>要输出的内容和定义的内容有差别，就可以用过滤器来进行格式化的改变。只是改变输出格式的变化，数据本身没有变化。</p>
<p>在实例之前进行定义</p>
<p>过滤器调用的格式</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;&#123; name | 过滤器的名称 &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义过滤器"><a href="#定义过滤器" class="headerlink" title="定义过滤器"></a>定义过滤器</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">vue.filter(<span class="string">'过滤器的名称'</span>，<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>过滤器中的function，第一个参数已经被规定死了，永远都是过滤器管道符前面传递过来的数据。其他位置可以进行传参，也可以进行多个传参。</p>
<p>过滤器也可以多个一起使用，比如</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;&#123; msg | msgFormat(<span class="name">'</span>疯狂'，'123') | test &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>结果是，先调用第一个过滤器，把第一个过滤器的结果再作为第二个过滤器的参数进行调用。</p>
<p>所谓的全局过滤器就是所有的vm实例都可以共享。</p>
<h2 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h2><p>直接在vm实例内部进行定义</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">	dat<span class="variable">a:</span>&#123;</span><br><span class="line">		d<span class="variable">t:new</span> Date()</span><br><span class="line">	&#125;,</span><br><span class="line">	method<span class="variable">s:</span>&#123;&#125;,</span><br><span class="line">	<span class="built_in">filter</span><span class="variable">s:</span>&#123;  </span><br><span class="line">		dateForma<span class="variable">t:function</span>(dataStr)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>定义私有过滤器，过滤器有两个条件：过滤器名称和处理函数。<br>过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称抑制了，这时候优先调用私有过滤器。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">使用ES6中的字符串新方法<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>prototype.pad<span class="constructor">Start(<span class="params">maxLength</span>,<span class="params">dillString</span>='')</span>或</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>prototype.pad<span class="constructor">End(<span class="params">maxLength</span>,<span class="params">fillString</span>='')</span>来填充字符串</span><br></pre></td></tr></table></figure>

<p>第一个参数表示填充的最大长度是多少，例如如果是2的话，那么小于2的字符串就会被填充，第二个参数表示用什么来进行填充。分别表示在前面填充和在后面填充。这个可以用来进行时间格式化。</p>
<p>注意：全局的过滤器定义的时候不加s，私有的过滤器定义的时候要加s。</p>
<h2 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h2><p>在监听键盘事件时，我们经常需要检测常见的键值。vue允许为v-on在监听键盘事件添加关键修饰符：</p>
<figure class="highlight plain"><figcaption><span>@keyup.13</span></figcaption><table><tr><td class="code"><pre><span class="line">记住所有的keyCode比较困难，所以vue为做常用的按键提供了别名：</span><br><span class="line">~~~</span><br><span class="line">&#x2F;&#x2F;这里两种写法都是可以的，可以是键码，也可以是别名和自定义别名</span><br><span class="line">&lt;input @keyup.enter&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;input @keyup.13&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">~~~</span><br><span class="line">全部的按键别名：</span><br><span class="line">+ .enter</span><br><span class="line">+ .tab</span><br><span class="line">+ .delete(捕获删除键或者退格键)</span><br><span class="line">+ .esc</span><br><span class="line">+ .space</span><br><span class="line">+ .up</span><br><span class="line">+ .down</span><br><span class="line">+ .left</span><br><span class="line">+ .right</span><br><span class="line"></span><br><span class="line">可以通过全局config.keyCodes对象自定义键值修饰符别名：</span><br><span class="line">~~~</span><br><span class="line">Vue.config.keyCodes.f1&#x3D;112</span><br><span class="line">&#x2F;&#x2F;可以使用v-on:keyup.f1</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">定义的时候，跟定义全局过滤器一样，都是在全局进行定义的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 自定义全局定义</span><br><span class="line">在vue中所有的指令在调用的时候都是以v-开头。</span><br><span class="line">~~~</span><br><span class="line">        Vue.directive(&#39;focus&#39;)&#x2F;&#x2F;调用的时候用v-focus</span><br><span class="line">~~~</span><br><span class="line">使用上述语法定义全局的指令。其中：</span><br><span class="line">+ 参数1：指令的名称，注意，在定义的时候，指令的名称前面不需要加v-前缀，</span><br><span class="line">但是 在调用的时候，必须在指令名称前加上v-前缀来进行调用。</span><br><span class="line">+ 参数2：是一个对象，身上有一些指令相关的钩子函数，这些函数可以在特定的阶段，执行相关的指令</span><br><span class="line"></span><br><span class="line">### 钩子函数</span><br><span class="line">指令定义提供了几个钩子函数：</span><br><span class="line">+ bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</span><br><span class="line">+ inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）</span><br><span class="line">+ update：所在组件的VNode更新时调用，但是可能发生在其孩子的VNode更新之前。指令的值可能发生了改变也可能没有。但是可以通过较更新前后的值来忽略不必要的模板更新</span><br><span class="line">+ componentUpdated：所在组建的VNode及其汉字的VNode全部更新时调用</span><br><span class="line">+ unbind：只调用一次，指令与元素解绑时调用</span><br><span class="line"></span><br><span class="line">较为重要的时候，时前三个。</span><br><span class="line"></span><br><span class="line">钩子函数的参数：el、binding、vnode、oldvnode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 钩子函数参数列表</span><br><span class="line">+ el：指令所绑定的元素，可以用来直接操作DOM。</span><br><span class="line">+ binding：一个对象，包含以下属性：</span><br><span class="line">   - name：指令名，不包括v-前缀</span><br><span class="line">   - value：指令的绑定值，例如v-my-directive&#x3D;&#39;1+1&#39;，value的值是2</span><br><span class="line">   - oldValue：指令绑定的前一个值，尽在update和component钩子中使用</span><br><span class="line">   - expression：绑定之的字符串形式。例如：v-my-directive&#x3D;“1+1”，expression的值是“1+1”</span><br><span class="line">   - arg：传给指令的参数。例如：v-my-directive：foo，arg的值是foo</span><br><span class="line">   - modifiers：一个包含修饰符的对象。例如：v-mt-directive.foo.bar，修饰符对象modifiers的值是（foo：true，bar：true）。</span><br><span class="line">+ vnode：Vue编译生成的虚拟节点</span><br><span class="line">+ oldVnode：上一个虚拟节点，仅在update和component钩子中使用</span><br><span class="line"></span><br><span class="line">注意binding.expression和binding.value的对比，前者是一个字符串形式，后者是它的值</span><br><span class="line"></span><br><span class="line">除了el之外，其他参数都应该是只读的，尽量不要修改他们，如果需要在钩子之间共享数据，建议通过元素的dataset来进行</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">Vue.directive(&#39;focus&#39;,&#123;</span><br><span class="line">	bind:function(el)&#123;&#x2F;&#x2F;每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次</span><br><span class="line">&#x2F;&#x2F;注意：在每个函数中，第一个参数永远是el，表示被绑定了指令的哪个元素，这个el参数，是一个原生的js对象</span><br><span class="line">&#x2F;&#x2F;在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用focus方法没有作用，</span><br><span class="line">&#x2F;&#x2F;因为一个元素，只有插入DOM之后，才能获取焦点</span><br><span class="line">        &lt;!-- el.focus() --&gt;</span><br><span class="line">		&#125;,</span><br><span class="line">	inserted:function(el)&#123;&#x2F;&#x2F;表示元素插入到DOM中的时候，会执行该函数。只能触发一次</span><br><span class="line">		el.focus();&#x2F;&#x2F;可以显示出来，因为这个已经插入到DOM中去了</span><br><span class="line">		&#125;,</span><br><span class="line">	updated:function(el)&#123;&#x2F;&#x2F;当VNode更新的时候，会执行updated，可能会触发多次</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### bind和inserted的区别：</span><br><span class="line">我们看到的页面都是通过从内存中进行渲染在页面上来进行显示，数据从内存显示到页面的这个过程我们叫做inserted，而bind的话只要在内存中一进行绑定就可以执行该指令。</span><br><span class="line"></span><br><span class="line">样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联样式。将来元素肯定会显示到页面中去，这时候，浏览器的渲染引擎必然会解析样式，应用给这个给样式。</span><br><span class="line"></span><br><span class="line">和js行为有关的操作，做好在inserted中去执行，防止js行为不生效。和样式相关的操作，一般都可以在bind中执行。</span><br><span class="line"></span><br><span class="line">### 使用钩子函数的第二个binding参数拿到传递的值</span><br><span class="line"></span><br><span class="line">举例子定义一个自定义指令：</span><br><span class="line">~~~</span><br><span class="line"> Vue.directive(&#39;color&#39;,&#123;</span><br><span class="line">          bind:function(el,binding)&#123;</span><br><span class="line">            el.style.color&#x3D;binding.value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">调用的时候：</span><br><span class="line">~~~                   </span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; v-model&#x3D;&quot;keywords&quot; id&#x3D;&quot;search&quot; v-focus v-color&#x3D;&quot;&#39;blue&#39;&quot;&gt;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">如果定义的时候是&#96;&#96;&#96;el.style.color&#x3D;binding.expression&#96;&#96;&#96;的话，得到的是：</span><br><span class="line">&#96;&#96;&#96;el.style.color&#x3D;&#39;blue&#39;</span><br></pre></td></tr></table></figure>

<h3 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = Vue(&#123;</span><br><span class="line">	<span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">	dat<span class="variable">a:</span>&#123;</span><br><span class="line">		d<span class="variable">t:new</span> Date()</span><br><span class="line">	&#125;,</span><br><span class="line">	method<span class="variable">s:</span>&#123;&#125;,</span><br><span class="line">	<span class="built_in">filter</span><span class="variable">s:</span>&#123;&#125;,</span><br><span class="line">	directive<span class="variable">s:</span>&#123;//自定义私有指令</span><br><span class="line">		<span class="string">'fontweight'</span>:&#123;</span><br><span class="line">			bind:<span class="function"><span class="keyword">function</span><span class="params">(el,binding)</span>&#123;</span></span><br><span class="line">				<span class="keyword">el</span>.style.fontWeight = binding.value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="指令函数的简写"><a href="#指令函数的简写" class="headerlink" title="指令函数的简写"></a>指令函数的简写</h3><p>不管是私有的还是全局的，后面都是跟的一个对象来进行定义<br>大多数情况下，我们可能想在bind和update钩子上做重复动作，并且不想关心其他的钩子函数。可以这样写：</p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">Vue.directive('<span class="built_in">color</span>',<span class="function"><span class="keyword">function</span><span class="params">(el,binding)</span>&#123;</span></span><br><span class="line">	el.style.<span class="built_in">color</span> = binding.value</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>相当于说，这个function在bind和update中都写了一份</p>
<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>生命周期钩子=生命周期函数=生命周期事件</p>
<p>什么是生命周期：从vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件统称为生命周期<br>生命周期钩子：就是生命周期事件的别名而已<br>主要的生命周期函数分类：</p>
<ul>
<li><p>创建期间的生命周期函数</p>
<ul>
<li>beforeCreated：实例刚在内存中被创建出来，此时还没有初始化好data和methods属性</li>
<li>created：实例已在内存中创建ok，此时data和methods属性已经创建ok，此时还没有编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中心事</li>
</ul>
</li>
<li><p>运行期间的生命周期函数</p>
<ul>
<li>beforeUpdate：状态更新之前执行此函数，此时data中的状态值时最新的，但是界面上溴铵是的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。</li>
</ul>
</li>
<li><p>销毁期间的生命周期函数</p>
<ul>
<li>beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用</li>
<li>destroy：Vue实例销毁后调用。调用后，Vue实例只是的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">	el:<span class="type"></span>'<span class="meta">#app',</span></span><br><span class="line">	data:<span class="type"></span>&#123;&#125;,</span><br><span class="line">	methods:<span class="type"></span>&#123;&#125;,</span><br><span class="line">	beforeCreated()&#123;<span class="comment">//这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会调用它</span></span><br><span class="line">		<span class="comment">//在beforeCreated生命周期函数执行的时候，data和methods都还没有初始化。所以这个时候在这个</span></span><br><span class="line">		<span class="comment">//函数里面操作任何元素、属性或者数据都拿不到</span></span><br><span class="line">	&#125;,</span><br><span class="line">	created()&#123;</span><br><span class="line">		<span class="comment">//在created里面，data和methods都已经初始化了</span></span><br><span class="line">		<span class="comment">//如果要调用methods或者data，最早都需要在created中去操作</span></span><br><span class="line">	&#125;,</span><br><span class="line">	beforeMount()&#123;</span><br><span class="line">		<span class="comment">//表示模板已经在内存中编辑完成了，但是还没有渲染到页面上去</span></span><br><span class="line">		<span class="comment">//在该函数执行的时候，页面中的元素还没有真正切换过来，只是之前写的一些模板字符串</span></span><br><span class="line">	&#125;,</span><br><span class="line">	mounted()&#123;</span><br><span class="line">		<span class="comment">//表示内存中的模板已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了</span></span><br><span class="line">		<span class="comment">//注意：mounted是实例创建期间的最后一个生命周期函数，当执行完mounted，就表示实例已经完全创建好了</span></span><br><span class="line">		<span class="comment">//此时如果没有其他操作的话，这个实例就会静静的躺在内存中，一动不动</span></span><br><span class="line">		<span class="comment">//如果要通过某些插件要操作页面上的DOM节点最早要在mounted中进行</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//接下来的是两个运行事件</span></span><br><span class="line">	beforeUpdate()&#123;</span><br><span class="line">		<span class="comment">//这时候，表示我们的界面还没有被更新，数据被更新了</span></span><br><span class="line">		<span class="comment">//当执行该函数的时候，页面中的显示数据，还是旧的，而此时data数据是最新的，页面尚未和最新的数据保持同步</span></span><br><span class="line">	&#125;,</span><br><span class="line">	updated()&#123;</span><br><span class="line">		<span class="comment">//该事件执行的时候，页面和data数据已经保持同步了，都是最新的</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>beforeUpdate函数之后的一个变化就是，虚拟树的重新渲染和挂载。这一步执行的是，现根据data中的最新的数据，重新渲染出一份最新的内存DOM树，当最新的DOM树更新之后眯会吧最新的内存DOM书，重新渲染到真实的页面中去，这时候，就完成了数据从data-&gt;view的更新</p>
<p>当执行beforeDestroy钩子函数的时候，就已经从运行极端进入到了销毁阶段，实例身上所有的data和methods以及过滤器、指令等都处于可用过程，此时，还没有真正的执行销毁过程。</p>
<p>当执行dextroy钩子函数的时候，组件已经完全销毁了，组件中的所有data、methods、过滤器、指令都不可用。</p>
<h2 id="vue-resource发起get、post、jsonp请求"><a href="#vue-resource发起get、post、jsonp请求" class="headerlink" title="vue-resource发起get、post、jsonp请求"></a>vue-resource发起get、post、jsonp请求</h2><p>使用jquery发起数据请求，需要操作DOM。<br>除了vue-resource还可以有使用axios的第三方包实现数据的请求。<br>常见的请求：个get、post、jsonp</p>
<p>vue-resource依赖vue</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发起get请求之后，通过.then来设置成功的回调函数</span></span><br><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">'路径地址'</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>&#123;</span><br><span class="line">	<span class="comment">//回调函数</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>手动发起的post请求，默认没有表单格式，所以，有的服务器处理不了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.post(<span class="string">'路径地址'</span>,&#123;&#125;,&#123;&#125;).then(<span class="function"><span class="params">result</span>=&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="jsonp实现原理"><a href="#jsonp实现原理" class="headerlink" title="jsonp实现原理"></a>jsonp实现原理</h3><p>由于浏览器的安全性限制，不允许AJAX访问协议不同、域名不同、端口号不同的数据接口，浏览器认为通过这种访问不安全。<br>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称之为JSONP，其只支持get请求。</p>
<ul>
<li>具体实现过程<ul>
<li>先在客户端定义一个回调方法，预定义对数据的操作</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口</li>
<li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法和名称，拼接出一个调用这个方法的字符串，发送给客户端去执行</li>
<li>客户端拿到服务器返回的字符串之后，当作script脚本去解析执行，这样就能够拿到jsonp的数据了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue1-day1</title>
    <url>/2019/10/16/vue1-01/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h3><ul>
<li>vue是目前最火的一个前端框架，react是最流行的一个前端框架（react除了开发网站，还可以开发手机app，vue语法也是可以进行手机app开发，需要借助weex）</li>
<li>vue是前端的主流框架之一，和react、angular一起，称为前端三大主流框架</li>
<li>vue 是一套构建用户界面的框架，指关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（vue由配套的第三方类库，可以整合起来做大型项目的开发）</li>
<li>前端的主要工作？主要负责为MVC中的V层，主要就是和界面打交道，来制作前端页面效果<a id="more"></a>

</li>
</ul>
<h3 id="为什么学习流行框架"><a href="#为什么学习流行框架" class="headerlink" title="为什么学习流行框架"></a>为什么学习流行框架</h3><ul>
<li>企业为了提高开发效率，企业中使用框架能够提高开发效率</li>
<li>提高开发效率的过程：原生js-&gt;jQuery之类的类库-&gt;前端模块引擎-&gt;angular.js/Vue.js（帮助我们减少不必要的DOM操作；提高渲染效率，双向数据绑定的概念（通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的））</li>
<li>在vue中，一个核心的概念就是让用户不再操作DOM元素</li>
</ul>
<h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul>
<li>框架：是一套完整的解决方案，对项目的侵入性比较大，项目需要更换框架，则需要重新架构整个项目。<ul>
<li>node中的express</li>
</ul>
</li>
<li>库（插件）：提供一个某一个小功能，对项目的侵入性比较小，如果某个库无法完成某些需求，可以很容易切换到其他库需求。<ul>
<li>1.从jquery切换到zepto</li>
<li>2.从EJS切换到art-template</li>
</ul>
</li>
</ul>
<h2 id="node（后端）中的mvc和前端中的mvvm之间的区别"><a href="#node（后端）中的mvc和前端中的mvvm之间的区别" class="headerlink" title="node（后端）中的mvc和前端中的mvvm之间的区别"></a>node（后端）中的mvc和前端中的mvvm之间的区别</h2><ul>
<li>mvc是后端的分层开发概念（view前端-&gt;app.js项目入口模块-&gt;router.js路由部分-&gt;controller业务逻辑处理层-&gt;model层只负责操作数据库；controller层包括router.js和controller两个部分）</li>
<li>mvvm是前端视图层的概念，前端图层分层开发思想，主要把每个页面分成了M,V,VM。其重VM是MVVM思想的核心，因为VM是M和V之间的调度者。这三个部分都是在view视图层里面的。M指的是每个页面中单独的数据，V是每个页面中的HTML结构，VM它是一个调度者，分割了M和V；每当v层想要获取后保存数据的适合，都要由vm做中间的处理。这么做的好处：前端页面中采用mvvm的思想，主要是为了让我们开发更加方便，因为mvvm提供了数据的双向绑定；注意：数据的双向绑定是由vm提供的。mvvm主要关注于视图分离层，也就是说，mvvm把前端的视图层，分为了三部分，model，view，vm viewmodel</li>
</ul>
<h2 id="vue基本代码和mvvm之间的对应关系"><a href="#vue基本代码和mvvm之间的对应关系" class="headerlink" title="vue基本代码和mvvm之间的对应关系"></a>vue基本代码和mvvm之间的对应关系</h2><p>步骤：1、导入vue的包 ；2、创建一个vue实例，当我们导入包以后，在浏览器的内存中，就多了一个vue构造函数</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">//在头部要先引入vue的包，后续的才有用</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//vue实例所控制的这个元素区域，就是我们的V</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>  //将来new的Vue实例，会控制这个元素中 的所有内容</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//注意：我们new出来的vm对象，就是我们mvvm中的vm调度者</span></span><br><span class="line"><span class="xml">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">	el: '#app', //表示当前我们new的这个实例，要控制页面上的哪个区域</span></span><br><span class="line"></span><br><span class="line"><span class="xml">	//这里的data就是mvvm中的m，专门用来保存每个每个页面的数据</span></span><br><span class="line"><span class="xml">	data:&#123;  //data属性中，存放的是el元素中要用到的数据,是一个data对象</span></span><br><span class="line"><span class="xml">       msg:'welcom vue' //通过vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了。前端的vue之类的框架不提倡我们取手动操作DOM元素</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">	&#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<h2 id="v-cloak、v-text、v-html"><a href="#v-cloak、v-text、v-html" class="headerlink" title="v-cloak、v-text、v-html"></a>v-cloak、v-text、v-html</h2><p>直接用插值表达式的时候，如果网速有点慢，就会先显示然后再显示出msg的值，解决办法就是可以再插值表达式的标签里面添加v-cloack</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>//网速较慢的情况下会直接显示插值表达式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">	el:'#app',</span></span><br><span class="line"><span class="xml">	data:&#123;</span></span><br><span class="line"><span class="xml">		msg:'123'</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">	&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="解决办法1："><a href="#解决办法1：" class="headerlink" title="解决办法1："></a>解决办法1：</h3><p>使用v-cloack能够解决插值表达式闪烁问题</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">[v-cloack]&#123;</span></span><br><span class="line"><span class="xml">	display:none;//这是让网络比较慢的时候显示为none</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloack</span>&gt;</span></span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">	el:'#app',</span></span><br><span class="line"><span class="xml">	data:&#123;</span></span><br><span class="line"><span class="xml">		msg:'123'</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">	&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="解决办法2："><a href="#解决办法2：" class="headerlink" title="解决办法2："></a>解决办法2：</h3><p>v-text也可以解决插值 闪烁问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el:<span class="string">'#app'</span>,</span></span><br><span class="line">	data:&#123;</span><br><span class="line"><span class="actionscript">		msg:<span class="string">'123'</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-cloack和v-text的区别"><a href="#v-cloack和v-text的区别" class="headerlink" title="v-cloack和v-text的区别"></a>v-cloack和v-text的区别</h3><p>1、v-cloak如果没有写style样式中的display的话，也是会有闪烁问题。而v-text默认没有闪烁问题<br>2、v-text会覆盖元素中原本的内容，但是v-cloak插值表达式只会替换自己的占位符，不会把整个元素的内容清空</p>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>v-html是把data中的插值解释为html元素，也会覆盖元素中原本的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el:<span class="string">'#app'</span>,</span></span><br><span class="line">	data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">		msg:'<span class="tag">&lt;<span class="name">h1</span>&gt;</span>llllllll<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>v-bind是vue中提供用于绑定属性的一个指令<br>v-bind会把后面的属性绑定当作是一个变量，以js语句来解析，如果想要自己再添加什么东西，就往里面添加字符串就可以了，所以会把v-bind冒号里面的东西当作解析式来解析，然后把解析的结果来进行渲染</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">//mytitle是一个变量，如果直接写上去的话，会把它当作是一个直接的值从而显示在按钮上，如果想要告诉title这是一个变量的话，需要用v-bind来绑定title的值，mytitle是一个属性，所以这样的话解析title的时候就会去查找mytitle这个变量所代表的值</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> <span class="attr">v-bind:title</span>=<span class="string">"mytitle + '123'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el:<span class="string">'#app'</span>,</span></span><br><span class="line">	data:&#123;</span><br><span class="line"><span class="actionscript">		mytitle:<span class="string">'这是一个我自己定义的title'</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>简写：<br>v-bind可以被简写为一个英文的:，v-bind中可以写合法的js表达式</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"button"</span> <span class="attribute">value</span>=<span class="string">"按钮"</span> :<span class="attribute">title</span>=<span class="string">"mytitle + '123'"</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>v-on是用来绑定事件的，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> <span class="attr">v-bind:title</span>=<span class="string">"mytitle + '123'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el:<span class="string">'#app'</span>,</span></span><br><span class="line">	data:&#123;</span><br><span class="line"><span class="actionscript">		mytitle:<span class="string">'这是一个我自己定义的title'</span></span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	methods:&#123;<span class="comment">//这个methods对象中定义了当前vue实例所有可用的方法</span></span></span><br><span class="line"><span class="actionscript">		show:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">			alert(<span class="string">'hello'</span>)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"button"</span> <span class="attribute">value</span>=<span class="string">"按钮"</span> v-bind:<span class="attribute">title</span>=<span class="string">"mytitle + '123'"</span> v-on:<span class="attribute">click</span>=<span class="string">"show"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"button"</span> <span class="attribute">value</span>=<span class="string">"按钮"</span> v-bind:<span class="attribute">title</span>=<span class="string">"mytitle + '123'"</span> @<span class="attribute">click</span>=<span class="string">"show"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>注意：在vm实例中，如果想要获取打他上的数据，或者想要调用methods中的方法，必须通过this.数据属性名或this.方法名来进行访问，这里的this，就表示我们new出来的vm实例对象。</p>
<p>vm实例，会监听自己身上data中所有数据的改变，只要数据以发生变化，就会自动把最新的数据，从data上同步到页面上去；好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面</p>
<p>箭头函数，this的指向永远跟外部的指向一致</p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ul>
<li>.stop 阻止冒泡</li>
<li>.prevent 阻止默认事件</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li>.once 事件只触发一次</li>
</ul>
<p>.self和.stop的区别：self并不能当作stop来使用，stop是可以阻止全部的冒泡行为，但是self只能阻止自己本身的冒泡行为，如果在该元素上级的上级还有父元素，则不能阻止该元素的父元素进行冒泡行为。但是stop会全部阻止冒泡行为。self只会阻止自己身上的冒泡行为，并不会阻止真正的冒泡行为</p>
<h2 id="v-model-和双向数据绑定"><a href="#v-model-和双向数据绑定" class="headerlink" title="v-model 和双向数据绑定"></a>v-model 和双向数据绑定</h2><p>使用该指令，可以实现表单元素和model中数据的双向绑定，v-model只能运用在表单元素中，select、input（radio、text、address、email）、checkbox、textarea</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"button"</span> <span class="attribute">value</span>=<span class="string">"按钮"</span> <span class="attribute">v-model</span>=<span class="string">"msg"</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="class类样式"><a href="#class类样式" class="headerlink" title="class类样式"></a>class类样式</h2><p>1、数组</p>
<figure class="highlight plain"><figcaption><span>:class</span></figcaption><table><tr><td class="code"><pre><span class="line">2、数组中使用三元表达式</span><br><span class="line">&#96;&#96;&#96;&lt;h1 :class&#x3D;&quot;[&#39;red&#39;,&#39;thin&#39;,isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个邪恶的h1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<p>3、数组中嵌套对象</p>
<figure class="highlight plain"><figcaption><span>:class</span></figcaption><table><tr><td class="code"><pre><span class="line">4、直接使用对象</span><br><span class="line">&#96;&#96;&#96;&lt;h1 :class&#x3D;&quot;&#123;red:true,italic:true,active:true,thin:true&#125;&quot;&gt;这是一个邪恶的h1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>在为class使用v-bind绑定对象的时候，对象的属性是类名，由于对象的属性可带引号，也可不带引号，属性的值是一个标识符.但是如果是复合属性名字，则必须要加引号，改成驼峰属性名称就可以不加引号</p>
<h2 id="为元素绑定style行内样式"><a href="#为元素绑定style行内样式" class="headerlink" title="为元素绑定style行内样式"></a>为元素绑定style行内样式</h2><p>1、直接在元素上通过：style形式，书写样式对象<br><code>&lt;h1 :style=&quot;{color:&#39;red&#39;,&#39;font-size&#39;:&#39;40px&#39;}&quot;&gt;这是一个善良的h1&lt;/h1&gt;</code><br>2、姜堰市对象，定义到打他中，并直接引用到：style中</p>
<ul>
<li>在data中定义样式<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">data</span>:&#123;</span><br><span class="line">	<span class="attribute">h1styleobj</span>:&#123;<span class="attribute">color</span>:<span class="string">'red'</span>,<span class="string">'font-size'</span>:<span class="string">'40px'</span>,<span class="string">'font-weight'</span>:<span class="string">'200'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在元素中，通过属性绑定的形式，将央视对象应用到元素中：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"h1styleobj"</span>&gt;</span>这是一个善良的h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
3、在：style中通过数组，引用多个data上的样式对象</li>
<li>在data上定义样式<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">data</span>：&#123;</span><br><span class="line">	<span class="attribute">hh1styleobj</span>:&#123;<span class="attribute">color</span>:<span class="string">'red'</span>,<span class="string">'font-size'</span>:<span class="string">'40px'</span>,<span class="string">'font-weight'</span>:<span class="string">'200'</span>&#125;,</span><br><span class="line">	<span class="attribute">h1styleobj2</span>:&#123;<span class="attribute">fontStyle</span>:<span class="string">'italic'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"[h1styleobj,h1styleobj2]"</span>&gt;</span>这是一个善良的h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-for指令四种使用方法和key属性"><a href="#v-for指令四种使用方法和key属性" class="headerlink" title="v-for指令四种使用方法和key属性"></a>v-for指令四种使用方法和key属性</h2><p>1、迭代数组</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in list"</span>&gt;</span>索引：</span><span class="template-variable">&#123;&#123;i&#125;&#125;</span><span class="xml">----姓名：</span><span class="template-variable">&#123;&#123;item.name&#125;&#125;</span><span class="xml">---年龄：</span><span class="template-variable">&#123;&#123;item.age&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>2、迭代对象中的属性</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--循环遍历对象身上的属性--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val,key,i) in userInfo"</span>&gt;</span></span><span class="template-variable">&#123;&#123;val&#125;&#125;</span><span class="xml">---</span><span class="template-variable">&#123;&#123;key&#125;&#125;</span><span class="xml">---</span><span class="template-variable">&#123;&#123;i&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>3、迭代数字</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"i in 10"</span>&gt;</span>这是第</span><span class="template-variable">&#123;&#123;i&#125;&#125;</span><span class="xml">个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：在遍历 对象身上的键值对的时候，除了有val  key，在第三个位置还有一个索引</p>
<h3 id="v-for的使用事项"><a href="#v-for的使用事项" class="headerlink" title="v-for的使用事项"></a>v-for的使用事项</h3><p>注意:2.2.0+的版本里，挡在组件中使用v-for时，key现在时必须的。当vue用v-for正在更新已渲染的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保他在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一key属性。</p>
<p>注意：1、v-for循环的时候，key属性只能能使用number或者string<br>      2、key在使用的时候，必须使用v-bind属性绑定的形式，指定key的值</p>
<p>在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果v-for有问题，必须在使用v-for的同时指定唯一的字符串/数字类型作为key值来进行绑定。进行绑定以后，每一个单选 项会跟自己的各个选项一起绑定成为一个主体，循环的时候，是全部一起来进行循环，不会只是他们分开来进行循环，从而有一些选项会落下。</p>
<h2 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">一般来说，v-<span class="keyword">if</span>有更高的切换消耗而v-<span class="keyword">show</span>有更高的初始渲染消耗。因此，如果需要频繁切换v-<span class="keyword">show</span>较好，如果在运行时条件不大可能改变v-<span class="keyword">if</span>较好。</span><br></pre></td></tr></table></figure>
<p>如果一个元素从来都没有显示过或者说它可能会永远不会显示出来，也就是它的条件变化不是特别大，这个时候就使用v-if比较好，因为v-show有较高的渲染消耗。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>v-if的特点：每次都会重新删除或者创建元素<br>v-show特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none样式</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、mvc和mvvm的区别<br>2、学习了vue中最基本代码的结构<br>3、插值表达式 v-cloak、v-text、v-html、v-bind（：）、v-on（@）、v-model、v-for、v-if、v-show<br>4、时间修饰符 .stop  .prevent  .capture  .self   .once<br>5、el：指定要控制的区域、data：是个对象，制定了控制区域内要用到的数据、methods：虽然带个s后缀，但是是个对象，这里可以自定义了一些好用的方法<br>6、在vm实例中，如果要访问data上的数据或者要访问methods中的方法，必须要带this<br>7、在v-for中要会使用key属性（只接受string/number类型）<br>8、v-model只能用于表单元素<br>9、在vue中绑定央视的两种方式：v-bind：class（class类样式）、v-bind：style（行样式）</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端进阶</category>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Vue1</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js零散笔记07</title>
    <url>/2019/07/27/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B007/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>在第一次触发事件时，不立即执行函数，而是给出一个期限值，比如200ms。</p>
<ul>
<li>如果在200ms内没有再次触发 滚动事件，那么就执行函数</li>
<li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时<br>结果：如果短时间内大量触发同一事件，只会执行一次函数<br>对于短时间内连续触发的事件，防抖就是让某个时间期限内，事件处理函数只会执行一次</li>
<li>实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法</li>
<li>缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟<a id="more"></a>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2>让函数执行一次后，在某个时间段暂时失效，过了这段时间再重新激活。<br>效果：如果短时间内大量触发同一事件，那么函数执行一次之后，该函数在限定事件期限内不再共工作，直到过了这段时间才会生效.</li>
<li>实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>函数防抖：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>
</li>
<li><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。</p>
</li>
<li><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>节流防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>博客（一）</title>
    <url>/2019/06/26/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A201/</url>
    <content><![CDATA[<h2 id="首页加载空白"><a href="#首页加载空白" class="headerlink" title="首页加载空白"></a>首页加载空白</h2><p>在我不断的调试修改之后，部署上GitHub的代码显示的是空白首页，但是其他页面依旧。然后我本地运行了一下，发现也是这样的情况，于时我去网上搜了一些教程，都是说将source/vendors改成source/lib，我去该目录下看已经被改过来了，那说明就不是这个问题，我在这个问题上纠结了好久，终于决定删除node_modules文件夹，然后重新在该目录下<code>npm i</code>生成所有依赖文件，再次打开时，发现问题解决。</p>
<h2 id="部署的时候出现错误"><a href="#部署的时候出现错误" class="headerlink" title="部署的时候出现错误"></a>部署的时候出现错误</h2><p>我在部署的时候出现了以下未标红的错误:</p>
<a id="more"></a>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line"><span class="keyword">Error: </span>Spawn failed</span><br></pre></td></tr></table></figure>
<p>我尝试了用原始git方法上传，但还是不行，于是我又去百度了以下，这个的意思就是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">致命:远程端意外挂起</span></span><br><span class="line"></span><br><span class="line"><span class="section">致命:远程端意外挂起</span></span><br><span class="line"></span><br><span class="line"><span class="section">致命的东西是错的。也许你可以在这里找到解决办法:</span></span><br><span class="line"></span><br><span class="line"><span class="section">错误:生成失败</span></span><br></pre></td></tr></table></figure>
<p>然后我上网查了一下，出现这种情况的原因就是网速不好！！！！所以只要再尝试上传几次就可以成功的！！！！</p>
<h2 id="底部标签显示不正常"><a href="#底部标签显示不正常" class="headerlink" title="底部标签显示不正常"></a>底部标签显示不正常</h2><p>底部下一页标签显示的时<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code><br>在<code>\themes\next\layout\_partials\pagination.swig</code>中，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">        next_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> page.<span class="keyword">prev</span> <span class="built_in">or</span> page.<span class="keyword">next</span> %&#125;</span><br><span class="line">  &lt;nav class=<span class="string">"pagination"</span>&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_tex<span class="variable">t:</span> <span class="string">'&lt;i class="fa fa-hand-o-left" aria-label="'</span> + __(<span class="string">'accessibility.prev_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">        next_tex<span class="variable">t:</span> <span class="string">'&lt;i class="fa fa-hand-o-right" aria-label="'</span> + __(<span class="string">'accessibility.next_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">        mid_size : <span class="number">1</span>,</span><br><span class="line">        <span class="built_in">escape</span>   : false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">&#123;%- <span class="keyword">endif</span> %&#125;</span><br></pre></td></tr></table></figure>
<p>其中：<code>fa-angle-right</code>为图标样式，可以自己改为自己喜欢的，去<a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">这里</a>找</p>
<h2 id="修改侧边栏背景图"><a href="#修改侧边栏背景图" class="headerlink" title="修改侧边栏背景图"></a>修改侧边栏背景图</h2><p>打开<code>themes/next/source/css/_custom/custom.styl</code>，在里面新增如下代码：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">$blue</span>; <span class="comment">//天空的颜色，和我的眼镜是绝配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="端口被占用"><a href="#端口被占用" class="headerlink" title="端口被占用"></a>端口被占用</h2><p>提示“FATAL Port 4000 has been used. Try other port instead.”<br>解决办法：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$hexo</span> s -p 5000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客相关问题解决</category>
      </categories>
      <tags>
        <tag>博客遇到的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>js--任务队列</title>
    <url>/2019/06/24/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B006/</url>
    <content><![CDATA[<p>具体文章解释可以参考<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">这篇博文</a></p>
<h2 id="JS单线程"><a href="#JS单线程" class="headerlink" title="JS单线程"></a>JS单线程</h2><p>JS单线程，同一个时间段只能做一件事。why？作为浏览器脚本，主要用途是和用户互动以及操作DOM。浏览器允许JS创建多个现成，但是子现成完全受主线程控制，且不得操作DOM。<br>单线程：前一个接后一个。如果排队是因为计算量大，CPU忙不过来倒也算了，但很多时候CPU是闲着的，因为IO很慢（比如AJAX操作网络读取数据），这时就必须等结果出来。</p>
<p>JS认识到，主线程可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头把挂起的任务继续执行。<br>于是，任务合成两种，同步任务和异步任务。</p>
<a id="more"></a>
<ul>
<li>同步任务：在主线程进入任务队列的任务。只有前一个任务执行完才能执行下一个任务 </li>
<li>异步任务：不进入主线程，进入任务队列的任务。只有“任务队列”通知主线程，某个异步任务可以执行力，该任务才会进入线程执行</li>
</ul>
<p>注意：</p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>
<li>主线程之外，还有一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个时间</li>
<li>一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些时间，那些对应的异步任务，于时结束等待状态，进入执行栈，开始执行</li>
<li>主线程不断重复上一步。只要主线程空了就会读取“任务队列”</li>
</ul>
<p>任务队列是一个事件的队列，IO完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入执行栈了。主线程读取任务，就是读取里面具体有哪些事件</p>
<p>任务队列中的事件，除了IO设备的事件以外，还包括了一些用户产生的事件，比如鼠标点击、页面滚动等。只要通过指定回调函数，这些事件发生时就会进入任务队列，等待主线程读取。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。主线程从任务队列中 读取事件是循环不断地，所以整个机制叫事件循环。</p>
<h2 id="Node-js运行机制"><a href="#Node-js运行机制" class="headerlink" title="Node.js运行机制"></a>Node.js运行机制</h2><ul>
<li>v8引擎解析脚本</li>
<li>解析后的代码，调用Node API</li>
<li>libviv库负责Node API的执行。它等待不同的任务分配给不同的现成，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎</li>
<li>v8再将结果返回给用户</li>
</ul>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h2><p>process.nextTick在下一次event loop之前触发回调函数，也就是说它指定的任务总是发生在所有任务之前。比如现在有一个同步任务，一个异步任务，一个process.nextTick，那么执行顺序就是先执行同步任务，再执行process.nextTick，再执行异步任务。</p>
<p>如果现在执行栈中有三个异步任务，任务队列还有五个异步任务，如果我在此时process.nextTick，那么就会再该轮执行栈执行结束以后，再将process.nextTick的事件添加进执行栈，也就是说先执行执行栈里面的三个异步任务，再执行process.nextTick的任务，最后执行任务队列中的五个异步任务</p>
<p>process.nextTick总是在该轮循环结束之后，在下一轮循环开始之前，执行该任务。</p>
<p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via StackOverflow）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'TIMEOUT FIRED'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// TIMEOUT FIRED</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。</p>
<p>process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">process.next<span class="constructor">Tick(<span class="params">function</span> <span class="params">foo</span>()</span> &#123;</span><br><span class="line">  process.next<span class="constructor">Tick(<span class="params">foo</span>)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="几种异步方法比较"><a href="#几种异步方法比较" class="headerlink" title="几种异步方法比较"></a>几种异步方法比较</h2><p>setImmediate和setTimeout封装在一个setImmediate里面。色图Immediate、总是将事件注册到下一轮EventLoop。setImmediate指定的回调函数总是排在setTimeout前面。</p>
<p>process.nextTick和setImmediate的一个重要区别就是：多个process.nextTick语句总是在前执行栈一次执行完，多个setImmediate可能则需要多次loop才能能执行完。由于process.nextTick指定的指定函数是在本次“事件循环”触发，而setImmediate指定的是下次事件循环触发，所以前者总是比后者遭，而且执行效率也高。</p>
<p>需要注意的是，setTimeout只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才回去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，<b>回调函数一定会在setTimeout()指定的事件执行</b></p>
<h2 id="微任务和宏任务。先执行微任务再执行宏任务。"><a href="#微任务和宏任务。先执行微任务再执行宏任务。" class="headerlink" title="微任务和宏任务。先执行微任务再执行宏任务。"></a>微任务和宏任务。先执行微任务再执行宏任务。</h2><p>运行机制：遇到同步任务直接执行，遇到异步任务分为宏任务和微任务</p>
<ul>
<li>宏任务：整体script、setTimeout、setInterval、I/O交互、setImmediate</li>
<li>微任务：promise、process.nextTick</li>
<li>有微则微，无微则宏。如果微任务列表里面有任务，会执行完毕后再执行宏任务</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>任务队列</tag>
        <tag>js基础</tag>
        <tag>Event Loop</tag>
        <tag>nodejs运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title>js--Event Loop</title>
    <url>/2019/06/20/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B005/</url>
    <content><![CDATA[<p>参考<a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做”进程”（process），一般情况下，一个进程一次只能执行一个任务。</p>
<p>JavaScript语言是一种单线程语言，所有任务都在一个线程上完成一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现”假死”，因为JavaScript停不下来，也就无法响应用户的行为。</p>
<a id="more"></a>
<h3 id="JavaScript为什么是单线程，难道不能实现为多线程吗？"><a href="#JavaScript为什么是单线程，难道不能实现为多线程吗？" class="headerlink" title="JavaScript为什么是单线程，难道不能实现为多线程吗？"></a>JavaScript为什么是单线程，难道不能实现为多线程吗？</h3><p>JavaScript从诞生起就是单线程。原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。后来就约定俗成，JavaScript为一种单线程语言。（Worker API可以实现多线程，但是JavaScript本身始终是单线程的。）</p>
<p>由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为”同步模式”（synchronous I/O）或”堵塞模式”（blocking I/O）。</p>
<p>Event Loop就是为了解决这个问题而提出的。Wikipedia这样定义：</p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line"><span class="comment">"Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）"</span></span><br></pre></td></tr></table></figure>
<p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p>
<p>每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。</p>
<p>主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”异步模式”（asynchronous I/O）或”非堵塞模式”（non-blocking mode）。</p>
<p>这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>任务队列</tag>
        <tag>js基础</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器05</title>
    <url>/2019/05/17/%E6%B5%8F%E8%A7%88%E5%99%A805/</url>
    <content><![CDATA[<p>具体参考<a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>由于http是无状态协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求会重新连接，这说明服务端单从网络连接上是没有饭吧直到用户身份的。那就给每次新的用户请求时，给它颁发一个身份证（独一无二），下次访问时，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同响应，这就是cookie的原理。其实cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息</p>
<p>用户首次访问服务器，服务器会返回一个独一无二的识别码（id=12345），这样服务器可以用这个吗来跟踪用户的信息（购物车历史、地址信息）。cookie可以包含任意的信息，不仅仅是id，客户端会记录服务端返回来的set cookie首部中的cookie内容，并将cookie存储在浏览器的cookie数据库中，当用户访问同一站点时，浏览器会挑选当时该站点颁发的id=xxxxx身份证，并在cookie请求首部发送过去。</p>
<p>cookie分为会话cookie（临时cookie）和持久cookie（存在硬盘里）</p>
<a id="more"></a>
<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>1、很久以前，web基本上激素hi文本的浏览而已，既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议，就是请求响应，尤其不用记住是谁刚刚发了http请求，每个请求对我来说都是全新的。<br>2、但是随着交互式web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住那些人登录系统，哪些人往自己的购物车放商品，也就是说要把每一个人区分开，但是http是一个无状态的协议，所以想出的办法就是给每一个用户颁发一个会话标识（seddion id），这其实就是一个随机的字符串，每个人收到的都不一样，每次的用户发送一个请求的时候，就把这个字符串一起发送过来，这样服务器就能区分每一个用户了。<br>3、这样的话用户是识别了，可是服务器的负担就重了，因为客户端只需要保存自己的session id，但是服务器要保存所有人的session id，如果访问服务器的用户多了，那么服务器就崩溃了。</p>
<p>这对服务器是一个巨大的开销，严重的限制了服务器扩展能力，比如说我用两个及其组成了一个集群，小F通过机器A登录了系统那session id就会保存在机器A上，假如小F下一次请求被转发到机器B怎么办？机器B没有下F的session id</p>
<p>有时候会采用一点小伎俩：session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。</p>
<p>那只好做session的复制，把sessionid在两个机器之间搬来搬去，会很麻烦。</p>
<p>后来有个方法：把session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是哪个负责session的机器挂掉了，所有人都得重新登录以便，估计太麻烦了。<br>4、于是有人就在思考，为什么要服务器保存这个session id呢，直接让每个客户端去保存就好了。<br>可是如果不保存这些session id，怎么验证客户端发给服务器的session id的确是服务器生成的呢？如果不去验证，服务器都不知道它们是不是合法的用户，哪些不怀好意的人就可以任意伪造session id了。</p>
<p>所以关键点就是<code>验证</code><br>比如小f已经登陆了系统，服务器给它发送一个令牌（token），里面包含了小f的user id，下一次小f再次通过http请求访问服务器的时候，把这个token通过http header带过来不就可以了。</p>
<p>不过这和sessionid没有本质区别，任何人都可以伪造，所以得想点办法不让别人伪造</p>
<p>那就对数据做一个签名吧，比如说服务器用HMAC-SHA256算法，加上一个只有服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为一个token，由于密钥别人不知道，所以就无法伪造tokenl。</p>
<p>这个token服务器不保存，当小f把这个token<br>发送给服务器的时候，服务器再用同样的算法和同样的密钥，对数据再计算一次签名，和token中的签名做一个比较，结果相同就知道小f已经登录过了，并且可以直接得到小f的user id，如果不相同数据部分肯定被人纂改过，服务器就可以告诉客户端对不起没有认证！</p>
<p>token中的数据是明文保存的（虽然服务器会用Base64做编码，但是那不是编码），还是可以被别人看到，所以服务器不能在其中保存像密码这样的敏感信息。</p>
<p>当然如果一个人的token被人偷走了，那服务器也没有你办法，服务器就会认为小偷是合法用户，服务器用它的CPU计算时间获取它的session存储空间。</p>
<h2 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。<br>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下次请求统一网站时会把该cookie发送给服务器。由于cookie时存储在客户端上的，所以浏览器加入了一些限制确保cookie<br>不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session从字面上讲，就是会话。这个就类似于我们和一个人交谈，我们怎么知道他时张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p>
<p>session就是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的身份标识，然后客户端每次像服务端发送请求的时候，都带上这个身份标识，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个身份标识，可以有很多种方式，对于浏览器客户端大家都默认采用cookie的方式。</p>
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果服务器做了负载均衡那么下一个操作请求到了另一个服务器的时候session会丢失。</p>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>在web领域基于token的身份验证随处可见。在大多数使用webAPI的互联网公司中，tokens是多用户下处理认证的最佳方式。<br>以下几点特性会让我们在程序中基于token的身份验证：</p>
<ul>
<li>无状态、可扩展</li>
<li>支持移动设备</li>
<li>跨程序调用</li>
<li>安全</li>
</ul>
<p>哪些基于token的身份验证的大佬们，大部分见到过的API和web用于都使用tokens。例如facebook、twitter、github等。</p>
<h3 id="token的起源"><a href="#token的起源" class="headerlink" title="token的起源"></a>token的起源</h3><p>在介绍基于token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。</p>
<h4 id="基于服务器的验证"><a href="#基于服务器的验证" class="headerlink" title="基于服务器的验证"></a>基于服务器的验证</h4><p>我们都知道http是无状态的，这就意味这程序需要验证每一次请求，从而辨别客户端的身份。在这之前，程序都是在服务器存储的登录信息来辨别请求的，这种方式一般都是通过存储sessio来实现的。<br>随着web应用程序，以及移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。</p>
<p>暴露的问题：</p>
<ul>
<li>session：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</li>
<li>可扩展性：在服务端的内存中使用session存储登录信息，伴随而来的时可扩展性问题。</li>
<li>CORS（跨域资源共享）：当我们需要让数据跨多台移动设备上使用时，跨域资源共享是一个让人头疼的问题，在使用Ajax抓取另一个域的资源就会出现禁止请求的情况。</li>
<li>CSRF（跨站请求伪造）：用户在访问银行网站时，它他们容易受到跨站请求伪造的攻击，并且能够利用器访问其他的网站。<br>在这些问题中，可扩展性是最突出的。因此我们有必要去寻求一种更为有效的办法。</li>
</ul>
<h4 id="基于token的验证原理"><a href="#基于token的验证原理" class="headerlink" title="基于token的验证原理"></a>基于token的验证原理</h4><p>基于token的身份验证是无状态的，我们不用将用户信息在服务器或session中。<br>这种概念解决了在服务端存储信息时的许多问题。no session意味着我们的程序需要去增减服务器，而不用担心用户是否登录。</p>
<p>基于token的身份验证如下：</p>
<ul>
<li>用户通过用户名和密码发送请求</li>
<li>程序验证</li>
<li>程序返回一个签名的token给客户端</li>
<li>客户端存储token，并且用于没vi发送请求</li>
<li>服务端验证token并返回数据</li>
</ul>
<p>每一次请求都需要token。token‘应该在http的头部发送从而保证了http请求无状态。我们同样通过设置服务器属性access-control-allow-origin： * ，让服务器能接收到来自于所有的请求。需要注意是，在ACAO头部表明* 时。不得带有像http认证，客户端SSL整数和cookie的整数。</p>
<ul>
<li>用户登录校验校验成功后就返回token给客户端</li>
<li>客户端收到数据后保存到客户端</li>
<li>客户端每次访问API时携带token到服务器端</li>
<li>服务器端采用filter过滤器校验。校验成功后则返回请求数据，校验失败则返回错误码</li>
</ul>
<p>当我们在程序中认证了信息并取得token之后，我们便能通过这个token做许多事情。我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）</p>
<h4 id="token的优势"><a href="#token的优势" class="headerlink" title="token的优势"></a>token的优势</h4><p>无状态、可扩展<br>在客户端存储的token时无状态的，并且能够被扩展。基于这种无状态和不存储session信息，负载均衡器能够将用户信息从一个服务器传到另一个服务器上。</p>
<p>如果我们将已校验的用户的信息保存到session中，则每次请求都需要用户向已验证的服务器发送验证信息。用户量增大时，可能会造成一些拥堵<br>但是，使用token后这些问题都迎刃而解，因为token自己hold住了用户的验证信息。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>请求中发送token而不再是发送cookie能够放置CSRF（跨站请求伪造）。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不讲信息存储在session中让我们少了对session的操作。</p>
<p>token是有时效的，一段时间之后，用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocation可以使一个特定的token或是一组有相同认证的token无效</p>
<h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><p>token能够创建与其他程序共享权限的程序。例如，能够将一个随便的社交账号和自己的大号联系起来。当通过服务登录时，我们可以将这些buffer附到数据流上，使用token时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问他们的数据时，我们可以通过建立自己的API，得出特殊权限的token。</p>
<h5 id="多平台跨越"><a href="#多平台跨越" class="headerlink" title="多平台跨越"></a>多平台跨越</h5><p>我们提前先来讨论一下CORS（跨域资源共享），对应用程序和服务进行扩展的时候，需要介入各种各样的设备和应用程序。</p>
<h5 id="基于标准"><a href="#基于标准" class="headerlink" title="基于标准"></a>基于标准</h5><p>创建token时，可以设定一些选项。</p>
<h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><p>从安全性优先级来说：</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">Cookie&lt;session&lt;<span class="built_in">token</span></span><br></pre></td></tr></table></figure>
<h3 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><ul>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</li>
<li>HTTP是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了CookieCookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</li>
</ul>
<h4 id="session-1"><a href="#session-1" class="headerlink" title="session:"></a>session:</h4><ul>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li>
<li>关闭浏览器不会关闭session,它具失效日期，失效后服务器认为客户端停止了活动，并删除session以节省空间</li>
</ul>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token:"></a>Token:</h4><ul>
<li>作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击</li>
<li>Oauth token提供的是认证和授权，认证针对用户，授权针对app</li>
<li>token的生成一般是采用uuid保证唯一性，当用户登录时为其生成唯一的token，存储一般保存在数据库中。token过期时间采用把token二次保存在cookie或session里面，根据cookie和session的过期时间去维护token的过期时间</li>
</ul>
<h3 id="开发过程举例："><a href="#开发过程举例：" class="headerlink" title="开发过程举例："></a>开发过程举例：</h3><p>案例一：<br>项目中我们的用户数据可能需要和第三方共享,或允许第三方调用我们的API则用token</p>
<p>案例二:<br>公司内部的网站，自己的App，就可以用cookie、session<br>一般来说我们可以将登录信息放在session，其他信息保存在cookie</p>
<p>案例三：<br>观察微信、支付宝登录接口用的就是token</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>客户端连接服务器，服务器生成session id(会话ID），返回客户端。浏览器客户端一般默认采用cookie方式保存这个session id（身份标识）。为防止客户端伪造session id，验证是关键，即算法+密钥对数据做一个签名。客户端将数据+签名一起作为token发送到服务器，服务端通用用算法+同样的密钥对数据计算签名，与客户端带过来的签名对比，相同则表明客户端已登录，不同则可能数据被篡改，返回验证失败。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>token</tag>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--07</title>
    <url>/2019/05/09/nodejs2-07/</url>
    <content><![CDATA[<h2 id="路径操作模块path"><a href="#路径操作模块path" class="headerlink" title="路径操作模块path"></a>路径操作模块path</h2><ul>
<li>path.basename<ul>
<li>获取一个路径的文件名（默认包含扩展名）</li>
</ul>
</li>
<li>path.dirname<ul>
<li>获取一个路径的目录部分</li>
</ul>
</li>
<li>path.extname<ul>
<li>获取一个路径的扩展名部分</li>
</ul>
</li>
<li>path.parse<ul>
<li>把一个路径转换为对象<a id="more"></a>
<ul>
<li>root根路径</li>
<li>dir目录</li>
<li>base包含后缀名的文件名</li>
<li>ext后缀名</li>
<li>name不包含后缀名的文件名</li>
</ul>
</li>
</ul>
</li>
<li>path.join<ul>
<li>当需要进行路径拼接的时候，就使用这个方法，这个方法可以纠正【拼接格式</li>
</ul>
</li>
<li>path.isAbsolute<ul>
<li>判断一个路径是否是绝对路径</li>
</ul>
</li>
</ul>
<h2 id="node中的非模块成员（其他成员）"><a href="#node中的非模块成员（其他成员）" class="headerlink" title="node中的非模块成员（其他成员）"></a>node中的非模块成员（其他成员）</h2><p>在每个模块中除了require、exports等模块关键API之外，还有两个特殊成员：</p>
<ul>
<li>_ dirname<ul>
<li>可以用来获取当前文件模块所属目录的绝对路径</li>
<li>动态获取</li>
</ul>
</li>
<li>_ filename<ul>
<li>可以用来获取文件的绝对路径</li>
<li>动态获取</li>
</ul>
</li>
<li>./指的是相对于node命令所处的终端路径<ul>
<li>也就是说，文件操作路径中，相对路径设计指的是相对与node命令所处的终端路径</li>
<li>在文件操作中，使用相对路径是不可靠的，所以为了解决这个路径，只需要把相对路径改成绝对路径就可以了</li>
<li>所以可以使用<code>_dirname</code> 和 <code>_filename</code>来解决这个问题了</li>
<li><code>_dirname</code> 和 <code>_filename</code>是不受node命令所属路径影响的</li>
<li>在拼接路径的过程中，为了避免手动拼接带来的游戏额低级错误，所以推荐使用path.join()来辅助拼接。</li>
<li>为了尽量避免路径带来的问题，我们以后再文件操作中使用的相对路径都统一转换为动态的绝对路径</li>
</ul>
</li>
<li>模块中的路径表示和这里的路径没有关系，不受影响（相对于文件模块），即用require引入模块的时候不能省略相对路径<ul>
<li>不受node命令所处路径影响<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var fs = require('fs');</span><br><span class="line">fs.read<span class="constructor">File(<span class="params">__dirname</span> + '<span class="operator">/</span><span class="params">a</span>.<span class="params">txt</span>','<span class="params">utf8</span>',<span class="params">function</span>(<span class="params">err</span>,<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进方法</span></span><br><span class="line">fs.read<span class="constructor">File(<span class="params">path</span>.<span class="params">join</span>(<span class="params">__dirname</span>,'<span class="operator">/</span><span class="params">a</span>.<span class="params">txt</span>')</span>,'utf8',<span class="keyword">function</span>(err,data)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>date.now()会立即调用</li>
<li>date.now是一个方法</li>
<li>表单具有默认的提交行为，默认是同步的，同步表单提交，浏览器会锁死等待服务器的响应结果。</li>
<li>表单的同步提交以后，无论服务器响应的是什么，都会直接把响应的结果覆盖当前页面</li>
<li>服务端重定向只针对同步请求有效，对异步请求无效</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul>
<li><p>http是无状态的</p>
</li>
<li><p>cookie是 类似于小纸条，可以用来保存一些不太敏感的数据。但是不能用来保存用户登录状态</p>
</li>
<li><p>可以用来保存一些其他信息：例如：记住用户名、购物车<br>举例：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">超市</span>--<span class="comment">》电子柜（服务端）</span>--<span class="comment">》你（客户端）（二维码小票（开箱凭证）cookie）（凭证是唯一的，不可能重复）</span></span><br><span class="line"><span class="comment">一旦丢失，不可找回，如果小票丢失，你的状态也就丢失了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要是是服务器给的，所以就很安全了，不太容易伪造出来了。</span></span><br><span class="line"><span class="comment">这个时候，我们就可以包一些敏感的数据来保存到服务端，客户端只需要拿着这把钥匙就可以了。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在express这个框架中，默认不支持session和cookie</p>
</li>
<li><p>所以需要第三方中间件：express-session</p>
<ul>
<li>npm install express-session</li>
<li>配置（一定要在app.use（router）之前）</li>
<li>使用<ul>
<li>当把这个插件配置好以后，我们就可以通过req.session来访问和设置session成员</li>
<li>添加session数据：req.seesion = ‘bar’</li>
<li>访问session数据：req.session.foo</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该插件为req请求对象添加一个成员：req.session默认是一个对象</span></span><br><span class="line"><span class="comment">//这是最简单的配置方式，暂且先不用关心里面参数的含义</span></span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(session(&#123;</span><br><span class="line">	<span class="comment">//配置加密字符串，它会爱原有加密基础上和这个字符串拼接起来去加密</span></span><br><span class="line">	<span class="comment">//目的是为了增加安全性，防止客户端恶意伪造</span></span><br><span class="line">	<span class="attribute">secret</span>:<span class="string">'itcast'</span>,</span><br><span class="line">	<span class="attribute">resave</span>:false,</span><br><span class="line">	<span class="attribute">saveUninitialized</span>:false<span class="comment">//无论是否使用session，我都能默认直接给你分配一把钥匙</span></span><br><span class="line">	&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//添加<span class="keyword">session</span>数据</span><br><span class="line">req.<span class="keyword">session</span>.foo = <span class="string">'bar'</span>;</span><br><span class="line">//获取<span class="keyword">session</span>数据</span><br><span class="line">req.<span class="keyword">session</span>.foo</span><br></pre></td></tr></table></figure>
<p>提示：默认session数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把session持久化存储。</p>
<h2 id="写案例步骤"><a href="#写案例步骤" class="headerlink" title="写案例步骤"></a>写案例步骤</h2><p>目录结构：</p>
<ul>
<li>app.js                          项目的入口文件</li>
<li>controllers                   </li>
<li>models                          存储使用mongoose设计的数据模型</li>
<li>node_modules                    第三方包</li>
<li>package.json                    包描述文件</li>
<li>package-lock.json               第三方包版本锁定文件（npm5以后才有）</li>
<li>public                          公共的静态资源</li>
<li>README.md                       项目说明文档</li>
<li>routes                          如果业务比较多，代码量大，最好把路由按照业务的分类存储到routes目录中</li>
<li>router.js                       简单一点把所有的路由都放到这个文件</li>
<li>views                           存储视图目录</li>
</ul>
<p>步骤：</p>
<ul>
<li>创建目录结构</li>
<li>整合静态-模板页<ul>
<li>include </li>
<li>block</li>
<li>extend</li>
</ul>
</li>
<li>设计用户登录、退出、注册的路由</li>
<li>用户注册<ul>
<li>先处理好客户端页面的内容（表单控件的name、收集表单数据、发起请求）</li>
<li>服务端</li>
<li>先获取客户端请求数据</li>
<li>操作数据库<ul>
<li>如果有错，发送500告诉客户端服务器报错</li>
<li>其他根据业务发送不同的响应数据</li>
</ul>
</li>
</ul>
</li>
<li>用户登录</li>
<li>用户退出</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>path模块</li>
<li>__ dirname 和__filename两个属性<ul>
<li>动态的，获取当前文件或者文件所处目录的绝对路径</li>
<li>用来解决文件操作路径的相对路径问题</li>
<li>因为在文件操作中，相对路径相对于执行node命令所处的目录</li>
<li>所以为了尽量避免这个问题，都建议文件操作的目录都转为动态的</li>
<li>方式：path.join(__ dirname,’文件名’)</li>
</ul>
</li>
<li>art-template模板引擎高级语法<ul>
<li>include</li>
<li>extend</li>
<li>block</li>
</ul>
</li>
<li>表单同步提交和异步提交<ul>
<li>以前没有ajax都是这么干的，甚至有些直接就是渲染了提示信息出来了</li>
<li>异步提交页面不会刷新，交互方式更灵活</li>
</ul>
</li>
<li>express中配置使用express-session中间件</li>
</ul>
<h2 id="表单同步和异步的区别"><a href="#表单同步和异步的区别" class="headerlink" title="表单同步和异步的区别"></a>表单同步和异步的区别</h2><p>同步：提交请求-》等待服务器处理-》处理完毕返回  这个期间客户端浏览器不能干任何事<br>异步：请求通过事件触发-》服务器处理（这时浏览器仍然可以做其他事情）-》处理完毕</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>处理请求的，本质就是个函数。我们把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是为了提高代码的灵活性，动态可扩展的。</p>
<p>在express中，对中间件有几种分类：</p>
<h3 id="1、不关心请求路径和-请求方法的中间件，也就是说任何请求都会进入这个中间件"><a href="#1、不关心请求路径和-请求方法的中间件，也就是说任何请求都会进入这个中间件" class="headerlink" title="1、不关心请求路径和    请求方法的中间件，也就是说任何请求都会进入这个中间件"></a>1、不关心请求路径和    请求方法的中间件，也就是说任何请求都会进入这个中间件</h3><p>中间件本身是一个方法，该方法接收三个参数：request请求对象，response响应对象，next下一个中间件。next是一个方法会调用下一个中间件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'1'</span>)</span><br><span class="line">	<span class="built_in">next</span>()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'2'</span>)</span><br><span class="line">	<span class="built_in">next</span>()</span><br><span class="line">	&#125;)</span><br><span class="line">//<span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>添加next，就会调用下一个中间件，所以调用next也是要匹配的，不是调用紧挨着的。如果请求进入中间件后，如果没有next则代码会停在当前中间件，如果调用了next则往后找到匹配的下一个中间件</p>
<h3 id="2、关心路径请求的中间件，以-xxx开头的路径中间件"><a href="#2、关心路径请求的中间件，以-xxx开头的路径中间件" class="headerlink" title="2、关心路径请求的中间件，以/xxx开头的路径中间件"></a>2、关心路径请求的中间件，以/xxx开头的路径中间件</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/a'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'1'</span>)</span><br><span class="line">	<span class="built_in">next</span>()</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>没有匹配中间件express会默认输出 CAN NOT GET/</p>
<h3 id="3、除了以上中间件之外，还有一种最尝试用的严格匹配请求方法和匹配请求路径的中间件"><a href="#3、除了以上中间件之外，还有一种最尝试用的严格匹配请求方法和匹配请求路径的中间件" class="headerlink" title="3、除了以上中间件之外，还有一种最尝试用的严格匹配请求方法和匹配请求路径的中间件"></a>3、除了以上中间件之外，还有一种最尝试用的严格匹配请求方法和匹配请求路径的中间件</h3><p>app.get,app.post</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/a'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果中间件没有next则不会往下执行，只会停留在当前中间件<br>当调用next的时候，如果传递了参数v，则直接往后找到带有这个参数应用程序级别中间件<br>当发生错误的时候，我们可以调用next传递错误对象，然后就会被全局错误处理中间件匹配到并处理之</p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--06</title>
    <url>/2019/05/03/nodejs2-06/</url>
    <content><![CDATA[<h2 id="使用node操作MySQL数据库"><a href="#使用node操作MySQL数据库" class="headerlink" title="使用node操作MySQL数据库"></a>使用node操作MySQL数据库</h2><p>安装：<br><code>npm install --save mysql</code></p>
<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0 、引包</span></span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="comment">//1、创建连接</span></span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">	host:<span class="string">'localhost'</span>,</span><br><span class="line">	user:<span class="string">'root'</span>,</span><br><span class="line">	password:<span class="string">'123'</span>,</span><br><span class="line">	database:<span class="string">'users'</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、连接数据库 打开冰箱门</span></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、执行数据操作，把大象放到冰箱中</span></span><br><span class="line"><span class="comment">//选择数据</span></span><br><span class="line">&lt;!-- connect.query(<span class="string">'SELECT * FROM `users`'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,res,fields</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">throw</span> error</span><br><span class="line">	&#125;); --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就只有connect.query方法，所有的增删改查都在该方法内部填写，通过前面的mysql语句来进行数据库操作</span></span><br><span class="line"><span class="comment">//增加数据</span></span><br><span class="line">&lt;!-- connect.query(<span class="string">'INSERT INTO users VALUES("admin","123456")'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,res,fields</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">throw</span> error</span><br><span class="line">	&#125;); --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭连接，关闭冰箱门</span></span><br><span class="line">connect.end();</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>mongodb数据库<ul>
<li>数据存储结构</li>
</ul>
<ul>
<li>数据表</li>
<li>集合（表）</li>
<li>文档（表记录）</li>
</ul>
</li>
<li>mongodb 官方有一个mongodb的包用来操作mongodb数据库<ul>
<li>比较原始，使用比较麻烦，一半不用该包</li>
</ul>
</li>
<li>mongoose<ul>
<li>真正公司进行开发，使用的是mongoose第三方包</li>
<li>提高开发效率</li>
</ul>
</li>
<li>掌握使用mongodb对数据集合进行基本的CRUD</li>
<li>使用node操作mysql数据库</li>
</ul>
<h2 id="回调地狱-callback-hell"><a href="#回调地狱-callback-hell" class="headerlink" title="回调地狱 callback hell"></a>回调地狱 callback hell</h2><h3 id="throw-error"><a href="#throw-error" class="headerlink" title="throw error"></a>throw error</h3><p>抛出异常：<br>两个作用：<br>1、阻止程序的执行<br>2、把错误信息打印到控制台</p>
<p>对于异步编程会出现的问题：<br>异步指的是不一定会按照程序代码的顺序进行执行，而是根据操作系统的调度行和文件大小以及一些偶然性决定的，所以是不一定按照编写顺序来的<br>例如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">var fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./data/a.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/b.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/c.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>即以上文件的读取顺序不一定是a.txt  b.txt   c.txt的顺序来进行读取的</p>
<p>解决以上办法就是通过回调嵌套的方式来保证顺序<br>例如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">var fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./data/a.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/b.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/c.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">error</span>) throw <span class="built_in">error</span></span><br><span class="line">	console.<span class="built_in">log</span>(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>不停在内部进行嵌套，但是当回调的程序多了以后，就会不停的嵌套，形成回调地狱。一个任务依赖一个异步任务以后，就把该任务写到异步任务里面，形成回调关系。问题就是嵌套太深，代码很丑，不易维护，阅读困难</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>为了解决回调地狱嵌套，所以在ES6中新增了一个API：Promise</p>
<p>可以把Promise看作是一个容器，容器中存放了一个异步任务，该异步任务包括三种状态，pending（默认状态），resolved（成功）、rejected（失败）。pending指向这俩个状态，并且每次只能变成一种，单向的，只能从pending–&gt;resolved或者pending–&gt;rejected。</p>
<ul>
<li>Promise是一个构造函数</li>
<li>Promise本身不是异步，但它里面的任务是异步的，即内部往往都是封装一个异步任务</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//0、创建Promise容器</span></span><br><span class="line"><span class="comment">//1、给别人一种承诺I Promise You</span></span><br><span class="line"><span class="comment">//Promise容器一旦创建，就开始执行里面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./data/a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			<span class="comment">//承诺容器中的任务失败了</span></span><br><span class="line">			<span class="comment">//把容器的pending状态改为rejected</span></span><br><span class="line">			<span class="comment">//调用reject就相当于调用了then方法的第二个参数函数</span></span><br><span class="line">			reject(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//承诺容器中的任务成功了</span></span><br><span class="line">			<span class="comment">//把容器的pending状态改成resolved</span></span><br><span class="line">			<span class="comment">//也就是说这里调用的resolve方法实际上就是then方法传递的哪个function</span></span><br><span class="line">			resolve(<span class="number">123</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//p1就是哪个Promise，实例对象</span></span><br><span class="line"><span class="comment">//当p1成功了 然后（then）做指定的操作</span></span><br><span class="line"><span class="comment">//then方法接受的function就是容器中的resolve函数</span></span><br><span class="line">p1</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data);<span class="comment">//123，上面传递的resolve参数是123，所以打印出来就是123</span></span><br><span class="line"> 	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"> 		<span class="built_in">console</span>.log(<span class="string">'读取文件失败了'</span>,err);</span><br><span class="line"> 		&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="嵌套解决"><a href="#嵌套解决" class="headerlink" title="嵌套解决"></a>嵌套解决</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建三个文件读取实例</span></span><br><span class="line"><span class="comment">//a.txt</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./data/a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			reject(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resolve(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.txt</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./data/b.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			reject(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resolve(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.txt</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./data/c.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			reject(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resolve(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data);</span><br><span class="line"> 	<span class="comment">//当p1读取成功的时候</span></span><br><span class="line"> 	<span class="comment">//当前函数中return的结果就可以在后面的 then中function接收到</span></span><br><span class="line"> 	<span class="comment">//当return 123 后面就接受到123</span></span><br><span class="line"> 	<span class="comment">//return 'hello'，后面就接受到hello，没有return后面就接受到undefined</span></span><br><span class="line"> 	<span class="comment">//上面那些数据没什么用，真正有用的是我们可以return一个Promise对象</span></span><br><span class="line"> 	<span class="comment">//当return一个Promise对象的时候，后续的then中方法的第一个参数会作为P2的resolve</span></span><br><span class="line"> 	<span class="comment">//第二个参数会作为p2的reject方法</span></span><br><span class="line"> 	<span class="keyword">return</span> p2</span><br><span class="line"> 	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"> 		<span class="built_in">console</span>.log(<span class="string">'读取文件失败了'</span>,err);</span><br><span class="line"> 		&#125;)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data);</span><br><span class="line"> 	<span class="keyword">return</span> p3;</span><br><span class="line"> 	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"> 		<span class="built_in">console</span>.log(err);</span><br><span class="line"> 		&#125;)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(data)</span><br><span class="line"> 	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"> 		<span class="built_in">console</span>.log(err);</span><br><span class="line"> 		&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="封装Promise版本的readFile"><a href="#封装Promise版本的readFile" class="headerlink" title="封装Promise版本的readFile"></a>封装Promise版本的readFile</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filepath</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	fs.readFile(filepath,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			reject(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resolve(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReadFile(<span class="string">'./data/a.txt'</span>)</span><br><span class="line"></span><br><span class="line">   .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(data);</span><br><span class="line">   	<span class="keyword">return</span> pReadFile(<span class="string">'./data/b.txt'</span>);<span class="comment">//返回一个新建的b文件pb实例</span></span><br><span class="line">   	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   		<span class="built_in">console</span>.log(err+<span class="string">'1'</span>);</span><br><span class="line">   		&#125;)</span><br><span class="line"></span><br><span class="line">   .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(data);</span><br><span class="line">   	<span class="keyword">return</span> pReadFile(<span class="string">'./data/c.txt'</span>);<span class="comment">//返回一个新建的c文件pc实例</span></span><br><span class="line">   	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   		<span class="built_in">console</span>.log(err+<span class="string">'2'</span>);</span><br><span class="line">   		&#125;)</span><br><span class="line"></span><br><span class="line">   .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(data)</span><br><span class="line">   	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   		<span class="built_in">console</span>.log(err+<span class="string">'3'</span>);</span><br><span class="line">   		&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Promise和数据库操作"><a href="#Promise和数据库操作" class="headerlink" title="Promise和数据库操作"></a>Promise和数据库操作</h3><p>所有数据库操作都是异步的</p>
<p><del>~</del><br>//用户注册<br>//1、判断用户是否存在，如果已存在，结束注册，否则注册（保存一条用户信息）<br>User.findOne({<br>    username:’admin’<br>    })<br>   .then(function(user){<br>       if(user){<br>           //用户已存在，不能注册<br>           console.log(‘用户已存在’)<br>           } else {<br>           //用户不存在，可以注册<br>           return new User({<br>               username:’aaa’,<br>               paaword:’123’,<br>               email:’sas’<br>               })<br>           }<br>       })<br>   .then (function(ret){</p>
<pre><code>}) </code></pre>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--05</title>
    <url>/2019/04/29/nodejs2-05/</url>
    <content><![CDATA[<h2 id="关于js模块化问题"><a href="#关于js模块化问题" class="headerlink" title="关于js模块化问题"></a>关于js模块化问题</h2><ul>
<li>js天生不支持模块化<ul>
<li>require</li>
<li>exports</li>
<li>Node.js才有的</li>
</ul>
</li>
<li>在浏览器中也可以像在Node中的模块一样来进行编程<ul>
<li>require.js第三方库  CMD</li>
<li>sea.js 第三方库     AMD<a id="more"></a></li>
<li>通过script标签来进行引用加载，而且还必须考虑加载顺序的问题</li>
</ul>
</li>
<li>无论是CommonJS、AMD、CMD、UMD、ES6 Module官方规范<ul>
<li>都是为了解决js的模块化问题</li>
<li>CommonJS、MD、CMD都是民间搞出来的</li>
<li>ES是官方规范定义</li>
<li>官方看民间在乱搞，开发人员为了在不同的环境中使用js模块化解决方案</li>
<li>所以ES2016，ES6，其中包含了官方对js模块化的支持</li>
</ul>
</li>
</ul>
<h2 id="package-lock文件的作用"><a href="#package-lock文件的作用" class="headerlink" title="package-lock文件的作用"></a>package-lock文件的作用</h2><ul>
<li>app.use()不仅仅是可以用来加载静态资源的和，还可以做很多工作</li>
<li>配置body-parse也是通过app.use来配置的</li>
<li>这是一个中间件，中间有一套规则</li>
</ul>
<p>npm5以前是不会有package-lock文件的，只有npm5以后才有这个文件。，当安装包的时候，都会生成或者更新package-lock.jspom文件。</p>
<ul>
<li>npm5以后的版本安装包不需要加–save参数，它会自动保存依赖信息</li>
<li>当安装包的时候，会自动创建或者更新package-lock.json文件</li>
<li>package-lock.json这个文件会保存node_modules中所有包的信息，（版本、下载地址）<ul>
<li>这样的话chongxinnpm install的时候速度就会提升</li>
</ul>
</li>
<li>从文件来看，有一个lock称之为锁<ul>
<li>这个lock是用来锁定版本的，</li>
<li>如果项目依赖了1.1.1版本，如果重新install其实会下载最新版本，而不是1.1.1</li>
<li>我们的目的就是希望可以锁住1.1.1这个版本</li>
<li>所以这个package-lock.json这个文件的另外一个作用就是锁定版本，防止升级版本</li>
</ul>
</li>
</ul>
<h2 id="find和findIndex原理"><a href="#find和findIndex原理" class="headerlink" title="find和findIndex原理"></a>find和findIndex原理</h2><ul>
<li>find接受一个方法作为参数，方法内部返回一个条件</li>
<li>find会遍历所有的元素，执行你给定的带有条件返回值的函数</li>
<li>符合该条件的元素会作为find方法的返回值</li>
<li>如果遍历结束还没有符合该条件的元素，则返回undefined</li>
<li>如果遍历到该元素符合条件了，就停止向下遍历</li>
<li>findIndex不过是返回的元素匹配的下标，而find返回的是元素匹配的元素值</li>
</ul>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>数据库,可以有多个数据库，qq，baidu，taobao</li>
<li>集合，一个数据库中可以有多个集合users，products</li>
<li>文档，一个集合中可以有多个文档{}，{}，{}，{}</li>
<li>文档结构很灵活，没有任何限制</li>
<li>mongodb非常灵活，不需要向MySQL一样先创建数据库、表、设计表结构<ul>
<li>在这里只需要：当需要插入数据的时候，只需要指定往哪个数据库的哪个集合中操作就可以了</li>
<li>一切都有mongodb帮助完成建库建表这件事<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attribute">qq</span>:&#123;</span><br><span class="line">		<span class="attribute">users</span>:[</span><br><span class="line">		&#123;<span class="attribute">name</span>:<span class="string">'a'</span>&#125;,</span><br><span class="line">		&#123;<span class="attribute">name</span>:<span class="string">'a'</span>&#125;,</span><br><span class="line">		&#123;<span class="attribute">name</span>:<span class="string">'a'</span>&#125;,</span><br><span class="line">		&#123;<span class="attribute">name</span>:<span class="string">'a'</span>&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attribute">products</span>:[</span><br><span class="line">		],</span><br><span class="line">		……</span><br><span class="line"></span><br><span class="line">		&#125;，</span><br><span class="line">	<span class="attribute">baidu</span>:&#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="attribute">taobao</span>:&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="关系型数据库和非关系型数据"><a href="#关系型数据库和非关系型数据" class="headerlink" title="关系型数据库和非关系型数据"></a>关系型数据库和非关系型数据</h3><ul>
<li>表就是关系，或者说表与表之间存在关系<ul>
<li>所有的关系型数据库都需要通过sql语言来操作</li>
<li>所有的关系型数据库都需要在操作之前设计表结构</li>
<li>而且数据表还支持约束<ul>
<li>唯一的、主键、默认值、非空</li>
</ul>
</li>
</ul>
</li>
<li>非关系型数据库非常的灵活，是灵活的<ul>
<li>有的非关系型数据库就是key-value对儿</li>
<li>MongoDB是长得最像关系型数据库的非关系型数据库<ul>
<li>数据库-》数据库</li>
<li>数据表-》集合（数组）</li>
<li>表记录-》(文档对象)</li>
</ul>
</li>
<li>MongoDB不需要设计表结构</li>
<li>也就是说你可以任意的往里面存数据，没有结构性这么一说</li>
</ul>
</li>
</ul>
<h3 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h3><p>启动：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#mongodb 默认执行mongodb命令所处盘符根目录下的 /data/db作为自己的数据存储目录</span></span><br><span class="line"><span class="meta"># 所以在第一次执行该命令之前先自己手动创建一个/data/db目录</span></span><br><span class="line"></span><br><span class="line">mongod</span><br></pre></td></tr></table></figure>
<p>如果想要修改默认的数据存储目录</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mongod <span class="attribute">--dbpath</span>=数据存储目录路径</span><br></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">在开启服务的控制台，直接ctrl+<span class="keyword">c</span>即可停止。或者直接关闭开启服务的控制台也可以</span><br></pre></td></tr></table></figure>
<h3 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">mongo <span class="comment">//该命令默认链接本机的mongoDB服务</span></span><br></pre></td></tr></table></figure>
<p>退出：在链接状态输入 exit</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>show dbs<ul>
<li>查看所有数据库</li>
</ul>
</li>
<li>db<ul>
<li>查看当前操作的数据库</li>
</ul>
</li>
<li>use 数据库名称<ul>
<li>切换到指定的数据库（如果没有会新建）</li>
</ul>
</li>
<li>插入数据</li>
</ul>
<h3 id="在node中如何操作mongodb"><a href="#在node中如何操作mongodb" class="headerlink" title="在node中如何操作mongodb"></a>在node中如何操作mongodb</h3><h4 id="使用官方mongodb包来操作"><a href="#使用官方mongodb包来操作" class="headerlink" title="使用官方mongodb包来操作"></a>使用官方mongodb包来操作</h4><p>网址：<a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="noopener">https://github.com/mongodb/node-mongodb-native</a></p>
<h4 id="使用第三放mongoose来操作mongodb数据库"><a href="#使用第三放mongoose来操作mongodb数据库" class="headerlink" title="使用第三放mongoose来操作mongodb数据库"></a>使用第三放mongoose来操作mongodb数据库</h4><p>第三方包：mongoose基于mongodb官方的mongodb包再做了一次包装<br>安装：nom i mongoose<br>网址：mongodbjs.com</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引包</span></span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">//连接ongodb数据库</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>,&#123;<span class="attr">useMongoClient</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.Promise = global.Promise;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个模型</span></span><br><span class="line"><span class="comment">//就是在设计一个数据库</span></span><br><span class="line"><span class="comment">//mongodb是动态的，非常灵活，只需要在代码中设计你的数据库就可以了</span></span><br><span class="line"><span class="comment">//mongoose这个包就可以让你的设计编写过程变得非常简单</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cat = mongoose.model(<span class="string">'Cat'</span>,&#123;<span class="attr">name</span>:string&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个cat</span></span><br><span class="line"><span class="keyword">var</span> kitty = <span class="keyword">new</span> Cat(&#123;<span class="attr">name</span>:<span class="string">'zilding'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//持久化保存kitty实例</span></span><br><span class="line">kitty.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'meow'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>写在一个js文件中，该js文件是放在node_modules中的<br>demo案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//新增数据</span></span><br><span class="line"><span class="keyword">var</span> mongoose = require(<span class="symbol">'mongoos</span>e');</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、链接数据库，括号里的localhost后的可以是不用存在的数据库，当插入第一条数据的时候，会自动创建</span></span><br><span class="line">mongoose.connect(<span class="symbol">'mongodb</span>:<span class="comment">//localhost/test');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、设计集合表结构（集合结构和表结构），设计文档结构</span></span><br><span class="line"><span class="comment">//字段名称就是表结构的属性名称</span></span><br><span class="line"><span class="comment">// 值，约束的目的是为了保证数据的完整性，不要由脏数据</span></span><br><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> <span class="type">Schema</span>(</span><br><span class="line">	&#123;</span><br><span class="line">		username:&#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span></span>:<span class="type">String</span>,</span><br><span class="line">			required:<span class="literal">true</span><span class="comment">//必须有</span></span><br><span class="line">		&#125;,</span><br><span class="line">		password:&#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span></span>:<span class="type">String</span>,</span><br><span class="line">			required:<span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		email:&#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span></span>:<span class="type">String</span></span><br><span class="line">		&#125;</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、将文档结构发布为模型</span></span><br><span class="line"><span class="comment">//mongoose.model方法就是用来将一个架构发布为model</span></span><br><span class="line"><span class="comment">//第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose会自动将大写名词的字符串生成小写复数的</span></span><br><span class="line"><span class="comment">//集合名称，也就是说User最终会变成users集合名称</span></span><br><span class="line"><span class="comment">//第二个参数：架构Schema，返回值：模型构造函数</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">User</span> = mongoose.model(<span class="symbol">'Use</span>r'，userSchema);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、当我们有了这个模型构造函数以后，就可以使用这个构造函数对users集合中的数据为所欲为了</span></span><br><span class="line"><span class="keyword">var</span> admin = <span class="keyword">new</span> <span class="type">User</span>(&#123;</span><br><span class="line">	ursername:<span class="symbol">'admi</span>n',</span><br><span class="line">	password:<span class="symbol">'12345</span>6',</span><br><span class="line">	email:<span class="symbol">'admin</span><span class="meta">@admin</span>.com'</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">admin.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'保存失败'</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'保存成功'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="comment">//查询数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//该方法时查询全部数据</span></span><br><span class="line">User.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'查询失败'</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret)</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="按条件查询数据"><a href="#按条件查询数据" class="headerlink" title="按条件查询数据"></a>按条件查询数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//按照条件查询</span></span><br><span class="line">User.find(&#123;</span><br><span class="line">	username:<span class="string">'zs'</span>,</span><br><span class="line">	password:<span class="string">'1234556'</span>  <span class="comment">//花括号以内的就是查询条件</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'查询失败'</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret)</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">User.findOne(&#123;</span><br><span class="line">	username:<span class="string">'zs'</span><span class="comment">//之查找一个，如果不跟条件的话，就是插入的第一个数据</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'查询失败'</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ret)</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="根据条件删除所有"><a href="#根据条件删除所有" class="headerlink" title="根据条件删除所有"></a>根据条件删除所有</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.remove(&#123;</span><br><span class="line">	uername:<span class="string">'zs'</span>  <span class="comment">//把所有username为zs的都删除了</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'删除失败'</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(ret)</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="根据条件删除一个："><a href="#根据条件删除一个：" class="headerlink" title="根据条件删除一个："></a>根据条件删除一个：</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Model</span>.</span></span>find<span class="constructor">OneAndRemove(<span class="params">conditions</span>,[<span class="params">options</span>],[<span class="params">callback</span>])</span></span><br></pre></td></tr></table></figure>
<h4 id="根据id删除一个"><a href="#根据id删除一个" class="headerlink" title="根据id删除一个"></a>根据id删除一个</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Model</span>.</span></span>find<span class="constructor">ByIdAndRemove(<span class="params">id</span>,[<span class="params">options</span>],[<span class="params">callback</span>])</span></span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.findByIdAndUpdate(<span class="string">'sdsd'</span>,&#123;</span><br><span class="line">	password:<span class="string">'123445'</span></span><br><span class="line">	&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,ret</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'更新失败'</span>)			</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'更新成功'</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--04</title>
    <url>/2019/04/24/nodejs2-04/</url>
    <content><![CDATA[<h2 id="文件路径和模块路径关系"><a href="#文件路径和模块路径关系" class="headerlink" title="文件路径和模块路径关系"></a>文件路径和模块路径关系</h2><p>文件操作中的相对路径./可以省略，模块加载中的相对路径./不能省略</p>
<ul>
<li>使用的所有文件操作API都是异步的</li>
</ul>
<h2 id="修改完代码自动重启"><a href="#修改完代码自动重启" class="headerlink" title="修改完代码自动重启"></a>修改完代码自动重启</h2><p>使用一个第三方命令行工具，nodemon来帮助我们频繁修改代码重启服务器问题。<br>nodemon是一个居于node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装</p>
<a id="more"></a>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install --<span class="built_in">global</span> nodemon<span class="regexp">//</span>在任意目录执行该命令都可以</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，使用：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">//以前使用方式</span><br><span class="line"><span class="keyword">node</span> <span class="title">app</span>.js</span><br><span class="line"></span><br><span class="line">//现在的方式</span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure>
<p>只要是通过<code>nodemon app.js</code>启动的服务，它就会监视你的文件变化，当文件发生变化的时候，自动帮助我们重启服务器。</p>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><p>路由就是一张表，表里面由具体的映射关系。</p>
<ul>
<li>请求方法</li>
<li>请求路径</li>
<li>请求处理函数<br>get：<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">//当你以<span class="built_in">get</span>方法请求/的时候，执行对应的处理函数</span><br><span class="line">app.<span class="built_in">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="title">req</span>,<span class="title">res</span>)&#123;</span></span><br><span class="line">	res.<span class="built_in">send</span>(<span class="string">'hello express！！！'</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>post：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">//当你以<span class="built_in">post</span>防范请求/的时候，指定对应的处理函数</span><br><span class="line">app.<span class="built_in">post</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="title">req</span>,<span class="title">res</span>)&#123;</span></span><br><span class="line">	res.<span class="built_in">send</span>(<span class="string">'get a post request'</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h3><p>当以’/public/‘开头的时候，去’./public’目录中查找相对应的文件，访问路径必须要添加/public/</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /public/xxx</span></span><br><span class="line">app.<span class="keyword">use</span>('/<span class="keyword">public</span>/',express.<span class="keyword">static</span>('./<span class="keyword">public</span>'))</span><br></pre></td></tr></table></figure>
<p>当省略第一个参数的时候，则可以通过省略/public的方式来进行访问，可以额访问路径不用添加/public/</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /xxx</span></span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>('./<span class="keyword">public</span>'))</span><br></pre></td></tr></table></figure>

<p>以下的方法代表的是以/static/来替换./public，也就是说，/static/是./public的别名</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /static/xxx</span></span><br><span class="line">app.<span class="keyword">use</span>('/<span class="keyword">static</span>/',express.<span class="keyword">static</span>('./<span class="keyword">public</span>'))</span><br></pre></td></tr></table></figure>

<h3 id="在express中配置使用art-template模板引擎"><a href="#在express中配置使用art-template模板引擎" class="headerlink" title="在express中配置使用art-template模板引擎"></a>在express中配置使用art-template模板引擎</h3><p>安装：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save art-template</span></span><br><span class="line">npm <span class="keyword">install</span> <span class="comment">--save express-art-template</span></span><br></pre></td></tr></table></figure>

<p>配置使用art-template模板引擎，第一个参数表示当渲染以.art结尾的文件的时候，使用art-template模板引擎.<br>express-art-template是专门用来在express中把art-template整合到express中的，虽然这里不需要加载art-template，但是也必须安装该包，原因就在于express-art-template依赖了art-tempplate。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">app.engine（<span class="string">'art'</span>,<span class="built_in">require</span>(<span class="string">'express-art-template'</span>)）</span><br></pre></td></tr></table></figure>
<p>express为response相应对象提供了一个方法：render。render方法默认是不可以使用，但是如果配置了模板引擎就可以使用了。<br>语法：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">res</span><span class="selector-class">.render</span>(<span class="string">'html模板名'</span>,&#123;模板数据&#125;)</span><br></pre></td></tr></table></figure>
<p>读取html模板名文件，渲染模板数据。第一个参数不能写路径，默认会去项目中的views目录中查找该模板文件，也就是说，express有一个约定：开发人员把所有的视图文件都放到views目录中。<br>例如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">app.<span class="built_in">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span>&#123;</span></span><br><span class="line">	<span class="keyword">res</span>.render(<span class="string">'404.art'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">/*</span><br><span class="line">注意：</span><br><span class="line">	<span class="number">1</span>、<span class="keyword">res</span>.render(<span class="string">'404.art'</span>)不能写成<span class="keyword">res</span>.render(<span class="string">'./views/404.art'</span>)，因为会默认去views这个目录下面查找</span><br><span class="line">	<span class="number">2</span>、要把views目录中对应的html文件名的后缀改成.art</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>如果不想要把改变views目录中文件的后缀名（不想把.html改成.art）的话，就需要在加载引擎的时候重新定义，即把：<br><code>app.engine（&#39;art&#39;,require(&#39;express-art-template&#39;)）</code>中的第一个参数由’art’改成’html’，这样的话加载的html文件就不需要改变后缀名了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.engine（<span class="string">'art'</span>,<span class="built_in">require</span>(<span class="string">'express-art-template'</span>)）</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.render(<span class="string">'404.html'</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想要修改默认的views目录。则可以使用set方法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">app.<span class="builtin-name">set</span>(<span class="string">'views'</span>,render函数的默认路径)</span><br><span class="line">app.<span class="builtin-name">set</span>(<span class="string">'views'</span>,<span class="string">'public'</span>)</span><br></pre></td></tr></table></figure>

<p><b>总结</b></p>
<ul>
<li><p>安装</p>
<ul>
<li><code>npm install --save art-template</code></li>
<li><code>npm install --save express-art-template</code></li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li><code>app.engine（&#39;art&#39;,require(&#39;express-art-template&#39;)）</code></li>
<li>以上方法配置的时候，render的文件后缀名只能是.art</li>
<li>如果向以.html为文件后缀名，需要把上述配置语句改为： </li>
<li><code>app.engine（&#39;html&#39;,require(&#39;express-art-template&#39;)）</code></li>
</ul>
</li>
<li><p>使用</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"> app.<span class="built_in">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span>&#123;</span></span><br><span class="line"><span class="keyword">res</span>.render(<span class="string">'index.html'</span>，&#123;</span><br><span class="line">	title：<span class="string">'hello world'</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果希望修改默认的views视图渲染存储目录，可以：</p>
<ul>
<li><code>app.set(&#39;views&#39;,render函数的默认路径)</code></li>
<li>注意：第一个参数不能写错</li>
</ul>
</li>
</ul>
<h2 id="在express中配置解析表单post请求体数据"><a href="#在express中配置解析表单post请求体数据" class="headerlink" title="在express中配置解析表单post请求体数据"></a>在express中配置解析表单post请求体数据</h2><p>当以POST请求/post的时候，执行指定的处理函数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/post'</span>，<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取表单POST请求体数据</span></span><br><span class="line">	<span class="comment">//2.处理</span></span><br><span class="line">	   <span class="comment">//将数据保存到db.json文件中用以持久化</span></span><br><span class="line">	<span class="comment">//3.发送响应</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	因为文件中json存取的都是字符串，所以要先读取出来，转成对象</span></span><br><span class="line"><span class="comment">	然后往对象中push数据</span></span><br><span class="line"><span class="comment">	然后把对象转换为字符串</span></span><br><span class="line"><span class="comment">	然后把字符串再次写入文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//req.query只能获取get方法的数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	&#125;);</span></span><br></pre></td></tr></table></figure>
<p>在express中没有内置获取表单POST请求体的API，这里我们需要一个第三方的包：<code>body-parser</code></p>
<ul>
<li>安装<ul>
<li>npm install –save body-parser</li>
</ul>
</li>
<li>配置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//0 引包</span></span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line"><span class="comment">//只要加入这个配置，则在req对象上会多出来一个属性：body</span></span><br><span class="line"><span class="comment">//也就是说可以直接通过req.body来获取表单POST请求体数据了</span></span><br><span class="line"><span class="comment">//parse app</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//parse app/json</span></span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/plain'</span>)</span><br><span class="line">	res.write(<span class="string">'you posted:\n'</span>)</span><br><span class="line">	res.end(<span class="built_in">JSON</span>.stringify(req.body,<span class="literal">null</span>,<span class="number">2</span>))</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
res.send，res.redirect这些方法会自动结束响应</li>
</ul>
<h3 id="配置中间件body-parser"><a href="#配置中间件body-parser" class="headerlink" title="配置中间件body-parser"></a>配置中间件body-parser</h3><p>配置模板引擎和body-parser一定要在app.use(router)挂载路由之前，中间件加载是从上到下</p>
<h2 id="从文件中读取各种数据"><a href="#从文件中读取各种数据" class="headerlink" title="从文件中读取各种数据"></a>从文件中读取各种数据</h2><p>模板引擎循环读取一些数据的时候，首先在app的</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">res</span>.render(<span class="string">'index.html'</span>),&#123;</span><br><span class="line">		student<span class="variable">s:</span>[</span><br><span class="line">	&#123;<span class="string">"name"</span>:<span class="string">"a"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"gender"</span>:<span class="number">0</span>,<span class="string">"hobbies"</span>:<span class="string">"singing,dancing"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>:<span class="string">"b"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"gender"</span>:<span class="number">0</span>,<span class="string">"hobbies"</span>:<span class="string">"singing,dancing"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>:<span class="string">"c"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"gender"</span>:<span class="number">0</span>,<span class="string">"hobbies"</span>:<span class="string">"singing,dancing"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>:<span class="string">"d"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"gender"</span>:<span class="number">0</span>,<span class="string">"hobbies"</span>:<span class="string">"singing,dancing"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>:<span class="string">"e"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"gender"</span>:<span class="number">0</span>,<span class="string">"hobbies"</span>:<span class="string">"singing,dancing"</span>&#125;</span><br><span class="line">]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后在index.html中这样写就可以了：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!-- 模板引擎循环渲染写法格式如下 --&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="template-variable">&#123;&#123; <span class="builtin-name">each</span> fstudents &#125;&#125;</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.name &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.age &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.gender &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.hobbies &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="template-variable">&#123;&#123; /<span class="builtin-name">each</span> &#125;&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<p>从文件中读取到的数据一定是字符串，所以需要手动转换成对象，需要对象的形式来放在render的第二个参数对象之中。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fs</span>.readFile('./db.json',function(err,<span class="class"><span class="keyword">data</span>)&#123;</span></span><br><span class="line"><span class="class">		<span class="title">if</span>(<span class="title">err</span>)&#123;</span></span><br><span class="line"><span class="class">			<span class="title">return</span> <span class="title">res</span>.<span class="title">status</span>(500).<span class="title">send</span>('<span class="type">Server</span> <span class="title">error'</span>)</span></span><br><span class="line"><span class="class">		&#125;</span></span><br><span class="line">		/*console.log(<span class="class"><span class="keyword">data</span>.toString())，因为<span class="keyword">data</span>传过来是字符串，但是是二进制编码字符串，所以如果需要看清楚的话，需要加<span class="keyword">data</span>.toString（）来转换成我们能认识的字符串*/</span></span><br><span class="line">		res.render('index.html',&#123;</span><br><span class="line">			students:<span class="type">JSON</span>.parse(<span class="class"><span class="keyword">data</span>).students//从文件中读取到的数据一定是字符串，所以需要手动转换成对象</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：students:JSON.parse(data).students，一定要加.students这个对象属性，因为传过来得到的data是一个对象，对象包括了该文件里面的所有数据，所以不加.student的话，就找不到循环遍历的一些属性，students是data对象中的一个对象，必须要有这个关系存在才可以引用这个对象进行相关操作</p>
<p>小总结：</p>
<ul>
<li>nodemon</li>
<li>express <ul>
<li>art-template模板引擎配置（art-template、express-art-template）</li>
<li>body-parser解析表单POST请求体</li>
</ul>
</li>
</ul>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>增删改查</p>
<p>新建项目步骤：<br>1、新建文件夹<br>2、cd 文件夹名字，进入文件夹<br>3、在该文件夹下npm init -y 进行初始化，会在该文件夹根目录下生成package.json文件<br>4、再在该文件夹中npm install –save express下载并生成express框架依赖<br>5、新建app.js文件、public文件夹和views文件夹<br>6、要想使用res.render方法进行渲染页面的话，必须要配置模板引擎</p>
<h2 id="路由模块的提取"><a href="#路由模块的提取" class="headerlink" title="路由模块的提取"></a>路由模块的提取</h2><p>express提供了一种方式专门用来包装路由的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个路由容器</span></span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.把路由都挂载到router路由容器中</span></span><br><span class="line">router.get(<span class="string">'/students/new'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">router.post(<span class="string">'/students/new'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br><span class="line">router.get(<span class="string">'/students/new'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.把router导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>以上代码都是在router.js中写的，在app.js中没有</p>
<p>在app中的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">require</span>(<span class="string">'./router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把路由容器挂载到app服务中</span></span><br><span class="line">app.<span class="keyword">use</span>(<span class="title">router</span>)</span><br></pre></td></tr></table></figure>

<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><ul>
<li>入门模块，职责：<ul>
<li>启动服务</li>
<li>做一些服务相关配置<ul>
<li>模板引擎</li>
<li>body-parser 解析表单 post请求体</li>
<li>提供静态资源的服务</li>
</ul>
</li>
<li>挂载路由</li>
<li>监听端口启动服务</li>
</ul>
</li>
</ul>
<h3 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h3><ul>
<li>路由模块，职责：<ul>
<li>处理路由</li>
<li>根据不同的请求方法+请求路径设置具体函数</li>
</ul>
</li>
</ul>
<h3 id="student-js"><a href="#student-js" class="headerlink" title="student.js"></a>student.js</h3><p>操作数据的API</p>
<ul>
<li>数据操作文件模块<ul>
<li>操作文件中的数据，只处理数据，不关心业务<br>例如：<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有学生列表    return[]</span></span><br><span class="line">exports.find = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加保存学生</span></span><br><span class="line">exports.save = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新学生信息</span></span><br><span class="line">exports.update = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除学生信息</span></span><br><span class="line">exports.delete = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="自己编写的步骤"><a href="#自己编写的步骤" class="headerlink" title="自己编写的步骤"></a>自己编写的步骤</h3><ul>
<li>处理模板</li>
<li>配置开放静态资源</li>
<li>配置模板引擎</li>
<li>路由设计</li>
<li>提取路由模块</li>
<li>由于接下来的一系列操作都需要处理文件数据，所以需要处理业务数据文件</li>
<li>业务文件结构</li>
<li>实现具体功能</li>
<li>业务功能顺序</li>
<li>简单路由</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul>
<li>如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取</li>
<li>回调函数的目的就是为了获取异步操作的结果</li>
</ul>
<p>不成立的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">	consle.log(<span class="number">1</span>)</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">var</span> ret = x + y</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">		&#125;,<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">		<span class="comment">//执行到这里就结束了，不会等到前面的定时器，所以就直接返回了undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>,<span class="number">20</span>))<span class="comment">//1，3，undefined，2</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">	consle.log(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">var</span> ret</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">		ret = x + y</span><br><span class="line">		&#125;,<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">		<span class="comment">//执行到这里就结束了，不会等到前面的定时器，所以就直接返回了undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>,<span class="number">20</span>))<span class="comment">//1，3，undefined，2</span></span><br></pre></td></tr></table></figure>

<p>注意:凡是需要得到一个函数内部异步操作（setTimeout、readFile、writeFile、ajax，往往异步API都伴有一个回调函数：$.get(‘/‘,function(){})）的结果，这种情况必须通过回调函数取得。<br>回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y,callback</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//callback就是回调函数</span></span><br><span class="line">	<span class="comment">// var x = 10</span></span><br><span class="line">	<span class="comment">//var y = 20</span></span><br><span class="line">	<span class="comment">//var callback = function(ret)&#123; console.log(ret) &#125;</span></span><br><span class="line"></span><br><span class="line">	consle.log(<span class="number">1</span>)</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">var</span> ret = x + y</span><br><span class="line">		callback(ret)</span><br><span class="line">		&#125;,<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>,<span class="number">20</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(ret)<span class="comment">//1,3,2,30</span></span><br><span class="line">	<span class="comment">//我现在得到这个函数可以做任何操作</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="基于原生XMLHttpRequest封装get方法："><a href="#基于原生XMLHttpRequest封装get方法：" class="headerlink" title="基于原生XMLHttpRequest封装get方法："></a>基于原生XMLHttpRequest封装get方法：</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> XMLRequest()</span><br><span class="line">	<span class="comment">//当请求加载成功之后要调用指定的函数</span></span><br><span class="line">	o.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//我现在需要得到这里的o.responseText</span></span><br><span class="line">		callback(o.responseText)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.open(<span class="string">"get"</span>,<span class="built_in">url</span>,<span class="literal">true</span>)</span><br><span class="line">	o.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(<span class="string">'data.json'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--03</title>
    <url>/2019/04/18/nodejs2-03/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>模块系统<ul>
<li>核心模块</li>
<li>第三方模块</li>
<li>自己写的模块</li>
</ul>
</li>
<li>npm</li>
<li>package.json</li>
<li>Express<a id="more"></a>
<ul>
<li>第三方web开发框架</li>
<li>高度分装了http模块</li>
<li>更加专注于业务，而非底层细节</li>
<li>知其所以然</li>
</ul>
</li>
<li>增删改查<ul>
<li>使用文件来保存数据（锻炼异步编码）</li>
</ul>
</li>
<li>MongoDB（所有方法都封装好了）</li>
</ul>
<p>版本号：x（新增功能比较多，甚至可能去除了某些功能）.x（加入了新功能）.x（修复bug，提升性能）</p>
<h2 id="遍历方法解析"><a href="#遍历方法解析" class="headerlink" title="遍历方法解析"></a>遍历方法解析</h2><ul>
<li>each时art-template的模板语法，专属的<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="builtin-name">each</span> 数组&#125;&#125;</span><span class="xml">开始便利</span></span><br><span class="line"><span class="xml"><span class="tag">&lt; <span class="attr">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;$value&#125;&#125;</span><span class="xml"><span class="tag">&lt;/ <span class="attr">li</span>&gt;</span>便利项</span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">each</span></span>&#125;&#125;</span><span class="xml">结束遍历</span></span><br></pre></td></tr></table></figure></li>
<li>jQuery<br>$.each(数组，function)<br>$(‘div’).each(function)一般用于便利jQuery选择器选择到的伪数组实例对象</li>
<li>forEach是ES5中的一个数组遍历函数，是js的原生支持对象</li>
</ul>
<p>伪数组是一个对象，对象的原型链中没有forEach，对象的原型链是object.prototype</p>
<ul>
<li>jQuery的each和forEach方法基本一致，由于forEach方法是ES5才开始有的一个方法，所以在一些低版本浏览器中可能会存在兼容性问题，IE8不支持注意这两个函数参数位置正好相反forEach的function第一个参数：item，第二个参数：index，jQuery的function第一个参数：index，第二个参数：item</li>
</ul>
<p>jQuery不是专门用来遍历jQuery元素的<br>1.方便的遍历jQuery元素<br>2.可以在不兼容forEach的低版本浏览器中公用jQuery的each方法</p>
<p>网页中的所有路径其实都是url路径，不是文件路径</p>
<h2 id="php比较"><a href="#php比较" class="headerlink" title="php比较"></a>php比较</h2><p>php+Apache（默认帮你封装好了很多迪岑那个细节来操作）<br>但是再Node中比较偏底层，很多东西需要亲自写代码来实现</p>
<p>在Node中开启的服务器，是一个完全的和黑盒子，它不像php，php无论是代码还是网页，都可以直接通过web url路径来访问。<br>在node中开启的服务器，默认是黑盒子，所有资源都不允许用户来访问每用户可以访问哪些资源由据以的开发人员编写设计的代码为准</p>
<h2 id="永久重定向和临时重定向"><a href="#永久重定向和临时重定向" class="headerlink" title="永久重定向和临时重定向"></a>永久重定向和临时重定向</h2><ul>
<li>301 永久重定向，浏览器会记住<br>a.com   b.com<br>请求a的时候，浏览器不会请求a了，直接跳到b</li>
<li>302 临时重定向 浏览器不会记住<br>a.com   b.com<br>请求a的时候，浏览器还会请求a，a告诉浏览器前往b</li>
</ul>
<h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><ul>
<li>使用node编写应用程序主要就是使用<ul>
<li>es语言</li>
<li>核心模块<br>fs、http、url、path、os</li>
<li>第三方模块</li>
<li>自己写的模块</li>
</ul>
</li>
</ul>
<h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><ul>
<li>文件作用域</li>
<li>通信规则<ul>
<li>加载require</li>
<li>导出</li>
</ul>
</li>
</ul>
<h2 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h2><p>在node中的js还有一个很重要的概念：模块系统。</p>
<ul>
<li><p>模块作用域</p>
</li>
<li><p>使用require方法来加载模块</p>
</li>
<li><p>使用exports接口对象来导出模块中的成员</p>
</li>
<li><p>exports.add = add 这样做的目的是为了解决变量命名冲突的问题</p>
</li>
<li><p>exports是一个对象，我可以通过多次为这个对象添加成员实现导出多个属性或者方法</p>
</li>
<li><p>exports.str = ‘hello’  这种方法只能导出对象组</p>
</li>
<li><p>如果一个模块需要直接导出某个成员，而非挂载的方式，可以直接module.exports = 方法名</p>
</li>
<li><p>尝试：exports = add 我们可以认为在每个模块的最后return了这个exports ，但是实际情况这种方法是行不通的</p>
</li>
</ul>
<h3 id="加载-require"><a href="#加载-require" class="headerlink" title="加载 require"></a>加载 <code>require</code></h3><p>语法：<br>var 自定义变量名称 = require(‘模块’)<br>两个作用：执行被加载模块的代码，得到被加载模块中的express导出接口对象</p>
<h3 id="导出-exports"><a href="#导出-exports" class="headerlink" title="导出 exports"></a>导出 <code>exports</code></h3><p>node是模块作用域，默认文件中所有的成员旨在当前文件模块有效<br>对于希望可以被其他模块访问的成员，我们就需要把这些工改的成员都挂载到exports接口对象就可以了</p>
<ul>
<li>导出多个成员（必须在对象中）<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">exports.a</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">exports.b</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="attr">exports.c</span> = function（）&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>导出单个成员（拿到的就是函数、字符串、数组）<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">module.exports</span> = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>
注意：以下情况会覆盖 ：<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> 'hello'</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span>（）&#123;</span>&#125;</span><br></pre></td></tr></table></figure>
这种情况下，后者会覆盖前者</li>
</ul>
<p>也可以<b>导出多个成员</b>：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	add:function(<span class="symbol">x</span>,<span class="symbol">y</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="symbol">x</span>+<span class="symbol">y</span></span><br><span class="line">	&#125;,</span><br><span class="line">	str:<span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在node中每个模块内部都有一个自己的module对象<br>在该module对象中，有一个成员叫exports<br>也就是说如果需要对外导出成员，只需要把导出的成员挂载到module.exports上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">module</span> =&#123;</span><br><span class="line">	<span class="keyword">exports</span>：&#123;</span><br><span class="line">	    foo:<span class="string">'bar'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码等同于下面这一句</span></span><br><span class="line"><span class="keyword">exports</span>.foo = <span class="string">'bar'</span><span class="comment">//等同于module.exports.foo = 'bar'</span></span><br></pre></td></tr></table></figure>
<p>谁来require我，谁就得到module.exports<br>默认在代码的最后有一句：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="class"><span class="keyword">module</span>.<span class="title">exports</span></span></span><br></pre></td></tr></table></figure>

<p>由于每次导出接口成员的时候都通过module.exports.xxx = xxx的方式来导出比较麻烦，所以专门提供了一个变量exports等于module.exports，也就是在模块中还有这样一句代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">exports</span> = <span class="keyword">module</span>.<span class="keyword">exports</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">exports</span> === <span class="keyword">module</span>.<span class="keyword">exports</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>由于最后返回的是module.exports，所以直接给‘exports = add’类似这样赋值是不管用的，因为对象是引用类型，赋值是直接类型，因为最后return的是module.exports，不是exports，所以给exports重新赋值不管用，一旦改变exports的值（或者是引用地址的改变的话），此刻exports就不再指向module.exports了，也就是后续再给exports赋值的都不能返回给require引用接口看</p>
<p><b>给exports赋值会断开和module.exports的引用，给module.exprts也会断开跟exports的引用，这两个都是一个对象，我们一开始是让这两个对象相等，即这两个对象的地址指向同一个堆内存，当给其中任意一个对象重新赋值的时候，都会断开和彼此的联系，从而这个时候只要记得最终return的是module.exports，只看该对象指向的堆内存所存的内容就可以了。</b></p>
<p>真正使用的时候：<br>导出多个成员：exports.xxx = xxx<br>             module.exports = {</p>
<pre><code>}</code></pre><p>导出单个成员：module.exports</p>
<p>小总结：</p>
<ul>
<li>每个模块中都有一个module对象</li>
<li>每个module对象都有一个exports对象</li>
<li>我们可以把需要导出的成员都挂载到module.exports接口对象中</li>
<li>也就是<code>module.exports.xxx=xxx</code>的方式</li>
<li>但是每次都<code>module.exports.xxx=xxx</code>比较麻烦</li>
<li>所以node为了方便，同时在每一个模块中提供了一个成员 叫<code>exports</code></li>
<li><code>module.exports === exports</code>的结果为true</li>
<li>当一个模块需要导出单个成员的时候，必须要<code>module.exports = xxx</code></li>
<li>不要使用<code>exports = xxx</code></li>
<li>因为每个模块最终向外<code>return</code>的是<code>module.exports</code></li>
<li>而<code>exports</code>只是<code>module.exports</code>的一个引用</li>
<li>所以即便给<code>exports = xxx</code>重新赋值，，也不会影响<code>module.exports</code></li>
<li>但是有一种赋值方式比较特殊：<code>exports = module.exports</code>这个用来重新建立引用关系的连接</li>
</ul>
<h2 id="require加载规则"><a href="#require加载规则" class="headerlink" title="require加载规则"></a>require加载规则</h2><p>优先从缓存中加载，不管什么时候、谁加载过需要require的代码，只要加载过了该模块，则都会从缓存中加载，不会重新加载代码。</p>
<ul>
<li>require(‘模块标识’) ==&gt;模块标识由核心模块、第三方模块、自己写的模块三部分</li>
<li>如果是非路径形式的模块表示  （foo.js、）</li>
<li>路径模式的模块： ./（当前目录）、../、/xxx （很少用），首位的/表示当前文件模块所属磁盘根路径，.js后缀名可省略</li>
<li>核心模块的本质也是文件，不过已经编译到二进制文件中了，我们只需要使用名字来加载就可以了</li>
<li>第三方模块，凡是第三方模块都必须通过npm来下载，使用的时候就可以通过require(‘包名’)的方式来进行加载才可以使用</li>
<li>不可能有任何一个第三方包和核心模块的名字是一样的</li>
<li>既不是核心模块也不是路径形式的模块，先找到当前文件所处目录中的node_modules目录，然后再去该目录中查找该包名对应的文件夹名，然后再在该文件夹中查找package.json文件并进入查看main属性，main属性中就记录了该模块的入口模块，然后加载使用这个第三方包，实际上最终加载的还是文件</li>
<li>如果package.json文件不存在或者main指定的入口模块也没有，则node会自动找该目录下的index.js</li>
<li>也就是说index.js会作为一个默认备选项，当前面的入口和文件不存在的时候，就会从该文件进入</li>
<li>如果以上任何一个条件都不成立，则会进入上一级目录中的node_modules目录查找，查找方式和顺序同上</li>
<li>如果上一级也没有，则继续往上上一级查找。。。。以此类推</li>
<li>如果知道当前磁盘根目录还找不到，最后报错：can not find module xxx</li>
<li>注意：一个项目只有一个node_modules文件夹，放在项目的根目录，这样的话项目中的所有子目录都能引用··<br>不会出现多个node_modules</li>
</ul>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul>
<li>模块查找机制：优先从缓存中加载&gt;&gt;核心模块&gt;&gt;路径形式的文件模块&gt;&gt;第三方模块<ul>
<li>node_modules/art-template/</li>
<li>node_modules/art-template/package.json</li>
<li>node_modules/art-template/package.json  main</li>
<li>index.js  备选项</li>
<li>进入上一级目录查找node_modules</li>
<li>按照这个规则依次往上查找，直到根目录找不到在报错。</li>
<li>一个项目只有一个node_modules文件夹，放在根目录，方便所有子目录的引用，兄弟之间不能引用node_modules中的第三方模块，但是可以通过路径方法引用自己手写的的模块</li>
</ul>
</li>
</ul>
<h2 id="package-json包说明文件"><a href="#package-json包说明文件" class="headerlink" title="package.json包说明文件"></a>package.json包说明文件</h2><ul>
<li>用来描述这个项目依赖的模块和安装包或者一些信息和相关信息</li>
<li>建议每一个项目都要有一个package.json文件，包描述文件，就像产品的说明书一样。</li>
<li>这个文件可以通过npm init的方式来进行初始化</li>
<li>npm install –save xxx，会生成一个package安装包</li>
<li>目前来说，dependences选项，可以用来帮我们保存第三包的依赖信息</li>
<li>建议每个目录的根目录小都有一个package文件</li>
<li>安装的时候–save就是为了安装package，目的是用来保存依赖选项信息</li>
<li>如果node_modules删除了也不用担心，我们只需要：npm install就会自动把package.json中的dependencies中的所有依赖项都下载回来（作用）</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><ul>
<li>node package manager</li>
<li>两个含义：npm网站和npm命令行工具</li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>npmjs.com，npm的官方网站</p>
<h3 id="npm命令行工具"><a href="#npm命令行工具" class="headerlink" title="npm命令行工具"></a>npm命令行工具</h3><ul>
<li>npm –version 查看npm版本号</li>
<li>npm install –global npm  升级npm</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>npm init（初始化），npm init -y可以跳过向导，快速生成</li>
<li>npm install 安装，只下载</li>
<li>npm install –save 下载并且保存依赖项（package.json文件）</li>
<li>npm uninstall，只删除，如果有依赖会依然保存</li>
<li>npm uninstall –save，删除的同时也会把以来信息去除（npm un-S）</li>
<li>npm help 查看帮助</li>
<li>npm命令 –help 查看指定命令的帮助</li>
</ul>
<h4 id="常用几个参数"><a href="#常用几个参数" class="headerlink" title="常用几个参数"></a>常用几个参数</h4><ul>
<li>-g 将模块安装到全局环境，安装以后就可以在终端命令直接使用，作为命令使用，如果不是安装到全局则是安装到本地（局部），这种时候，就不能作为命令来使用，要引用的时候只能通过模块来引用require</li>
<li>–save将魔魁啊安装到项目node_modules目录下，并在package.json的dependencies节点写入依赖</li>
<li>–save-dev：将模块安装到项目node_modules目录下，并在package.json的devdependencies节点写入依赖</li>
<li>–production值下载dependencies节点下的依赖</li>
</ul>
<p><code>dependencies</code>节点的依赖为运行时依赖，时i项目运行时必不可少的部分，例如引入jquery、express<br><code>devdependencies</code>节点的依赖为开发时依赖，在项目正式上线后，可以不需要。例如webpack，只有在开发编译时用到，正式环境使用的都是打包后的代码了。less加载器因为正式环境使用的是编译后的css。</p>
<p>换句话说，–save安装的都是底层必须的依赖，没有这些依赖项目就无法进行。二–save-dev安装的就只是开发依赖，正式环境中没有并不影响功能。</p>
<h4 id="解决npm被墙问题"><a href="#解决npm被墙问题" class="headerlink" title="解决npm被墙问题"></a>解决npm被墙问题</h4><p>npm存储包文件的服务器默认在国外，有时候会被墙，速度很慢。<br><code>http://npm.taobao.org</code>,cnpm，即淘宝的团队把npm在国内做了一个备份<br>安装的时候，直接把npm替换为cnpm就可以了。<br>在任意目录下执行都可以。</p>
<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code>，只要经过可该命令的配置，则以后的所有npm install都会默认通过淘宝服务器来下载</li>
<li>通过<code>npm config list</code>来查看是否配置成功</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>·原生的http在某些方面表现不足以应对我们的开发需求，所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，是我们的代码更加高度统一<br>·官方网站首页：expressjs.com</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0 安装</span></span><br><span class="line"><span class="comment">//1 引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//2.创建服务器的应用程序,也就是原来的http.ANGLE_instanced_arrays</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//当服务器收到get请求/的时候，执行回调函数，和原来的server.on（）方法相同</span></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.send(<span class="string">'hello express！'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//req.query，直接用该方法就可以来获取查询字符串参数，返回的是一个对象</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.send(<span class="string">'你好，我是express'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于server.listen()</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'app is running at port 3000'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在express中开放引擎就是一个API的事</span></span><br><span class="line"><span class="comment">//公开指定目录</span></span><br><span class="line"><span class="comment">//只要这样做了,就可以直接通过/public/xx的方式访问public目录中的所有资源了</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>,express.static(<span class="string">'./public'</span>))</span><br><span class="line">app.use(<span class="string">'/static/'</span>,express.static(<span class="string">'./static'</span>))</span><br><span class="line"><span class="comment">//以上的两个文件夹由于公开了，所以以上两个文件夹都能被访问了，但是其他文件夹就不可以被访问</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--02</title>
    <url>/2019/04/17/nodejs2-02/</url>
    <content><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul>
<li>standard style<ul>
<li>细则<ul>
<li>使用两个空格进行缩进</li>
<li>字符串使用单引号-需要转义的地方除外</li>
<li>不再有冗余的变量-导致大量bug的源头</li>
<li>无分号，要注意三种情况<ul>
<li>以<code>（ [ ^</code>开头的时候，则在前面补充一个分号避免发生一些解析错误<a id="more"></a></li>
</ul>
</li>
<li>行首不要以<code>(，[,or^</code>开头</li>
<li>关键字后加空格if （）</li>
<li>函数名后加空格function name（）</li>
<li>坚持使用 === 摒弃 ==——但在需要检查<code>null||undefined</code>时可以使用obj ==null</li>
<li>一定要处理node.js中错误回调传递进来的error参数。</li>
<li>使用浏览器全局变量时加上window前缀：document和navigator除外</li>
</ul>
</li>
</ul>
</li>
<li><code>aibinb style</code></li>
</ul>
<h2 id="模板引擎不关心内容"><a href="#模板引擎不关心内容" class="headerlink" title="模板引擎不关心内容"></a>模板引擎不关心内容</h2><p>模板引擎不关心你的字符串内容，只关心自己能认识的模板标记语法 在node也可以使用art-template模板引擎模板引擎最早就是诞生于服务器领域，后来才发展到前端</p>
<ul>
<li>使用步骤<ul>
<li>1、安装 npm install art-template</li>
<li>2、 在需要使用的文件模块中加载art-template<br>   例如var template = require(‘art-template’)，使用require方法加载，参数中的art-template就是下载的包的名字，install的是什么就是什么</li>
<li>3、查文档，使用模板引擎的API<ul>
<li>模板引擎的render方法需要接收的是字符串，所以我们需要把data二进制转为字符串，才可以给模板引擎使用</li>
</ul>
</li>
<li>```<br>fs.readdir(wwwDir,function(err,files){<br>  if(err){<pre><code>return res.end(&apos;  jjj&apos;)</code></pre>}<br>  //这里只需要使用模板引擎解析替换data中的模板字符串就可以了<br>  //数据data 就是files<br>  //然后去你的temmplate.html文件中编写你的模板语法就可以了<br>  var html = template.render(data.toString(),{<pre><code>files:files</code></pre>}<br>  )<br>})<br>var template = require(‘art-template’)<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>
var ret = template.render(原始内容（会被替换）,替换对象)</li>
<li>var ret = template.render(‘hello {{ name }}‘,{<br>name:’jack’<br>})<pre><code></code></pre></li>
</ul>
</li>
</ul>
<h2 id="服务端渲染和客户端渲染"><a href="#服务端渲染和客户端渲染" class="headerlink" title="服务端渲染和客户端渲染"></a>服务端渲染和客户端渲染</h2><p>服务端渲染就是模板引擎</p>
<ul>
<li>客户端渲染<ul>
<li>1、收到服务端响应的字符串了</li>
<li>2、从上到下依次解析，在解析的过程中，如果发现ajax请求，则再次发起新的请求</li>
<li>3、发送请求</li>
<li>4、拿到ajax响应结果</li>
<li>5、模板引擎渲染</li>
</ul>
</li>
</ul>
<p>至少经过两次请求，第一次请求拿到的是页面，第二次请求拿到的是动态数据，即页面结构和数据是分开传送和请求的<br>好处是会先看到页面，尽管页面里面没有内容，所以第一次给客户端以后客户端还要进行相关处理，所以会有利于用户体验，并且可以局部刷新</p>
<ul>
<li>服务端渲染<br>页面+数据<ul>
<li>1、读取index.html</li>
<li>2、模板引擎渲染，在发送给客户端之前，我在服务端就已经把inde.html渲染处理了</li>
</ul>
</li>
</ul>
<p>服务端渲染值请求了一次，请求一次服务端就把页面和数据一起发送给客户端，服务端渲染，相应的结果就是最终的结果，客户端不需要做任何处理</p>
<p>服务端不利于用户体验，因为会一下子全部加载完，不会有一个过度的效果，并且会有利于搜索引擎优化</p>
<ul>
<li>客户端渲染和服务端渲染的区别<ul>
<li>客户端渲染不利于SEO搜索引擎优化</li>
<li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染时很难被爬虫渲染的</li>
<li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的，而是两者结合起来</li>
<li>例如京东的商品列表就是采用的服务端渲染，目的为了SEO搜索引擎优化</li>
<li>而他的商品评论列表为了用户体验，而且也不需要SEO优化，所以采用的时客户端渲染</li>
</ul>
</li>
</ul>
<h2 id="处理网站中的静态资源"><a href="#处理网站中的静态资源" class="headerlink" title="处理网站中的静态资源"></a>处理网站中的静态资源</h2><ul>
<li><p>浏览器收到HTML响应内容以后，就要开始从上到下依次解析，挡在解析的过程中，如果发现：link、script、img、iframe、video、audio等带有src或者href(link)属性标签（具有外链的资源）的时候，浏览器会自动对这些资源发起新的请求。我们把这些资源请求内容称作为静态资源</p>
</li>
<li><p>页面是一个请求，页面中的每一个资源也是一个请求。</p>
</li>
<li><p>我们为了方便的同意处理这些静态资源，所以我们约定把所有的静态资源都放在public文件夹里面<br>例如：public/css/main.css、public/js/main.js、public/lib/jquery.js这样子存放</p>
<p>注意：在哪服务端中，文件中的路径就不要去写相对路径了。因为这个时候所有的资源都是通过url标识来获取的。我的服务器开放了/public目录。所以这里的请求路径都写成：/public/xxx ；  /在这里就是根路径的意思<br>浏览器再真正发送请求的时候会自动把地址网络地址拼接上。</p>
<p>public整个目录中的资源都允许被访问</p>
</li>
</ul>
<h2 id="表单get提交"><a href="#表单get提交" class="headerlink" title="表单get提交"></a>表单get提交</h2><p>以前表单是如何提交的？<br>表单中需要提交的表单控件元素必须具有name属性，表单提交分为两种：<br>  1、默认的提交行为<br>  2、表单异步提交</p>
<p>action 就是表单提交的地址，说白了就是  请求的url地址<br>method 请求方法：get post</p>
<p>由于有一种表单提交内容会把内容包含在url上，所以，对于这种表单提交的请求路径，其中含有用户动态填写的内容，所以不可能通过完整的url去处理这个请求。</p>
<p>使用url.parse方法将路径解析为一个方便操作的对象，第二个参数为true表示将查询字符串转为一个对象（通过jquery属性来访问）</p>
<h2 id="如何通过服务器让客户端重定向"><a href="#如何通过服务器让客户端重定向" class="headerlink" title="如何通过服务器让客户端重定向"></a>如何通过服务器让客户端重定向</h2><p>1、状态码设置为302，表示临时重定向  statusCode<br>2、在响应头中通过Location告诉客户端往哪儿重定向  setHeader</p>
<p>如果客户端发现服务器的响应状态码时302，就会自动去响应头中招Location对应的url，所以就可以看到客户端自动跳转了</p>
<p>微博评论小功能实现步骤：<br>1./index.html<br>2.开放public目录中的静态资源<br>  当请求/public/xxx的时候，读取响应public目录中的具体资源<br>3./post  post.html<br>4./pinglun<br>  4.1 接收表单提交数据<br>  4.2 存储表单提交的数据<br>  4.3 让表单重定向到 /<br>      statusCode<br>      setHeader </p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js02--01</title>
    <url>/2019/04/15/nodejs2-01/</url>
    <content><![CDATA[<h1 id="node第一天"><a href="#node第一天" class="headerlink" title="node第一天"></a>node第一天</h1><h2 id="为什么学习node-js"><a href="#为什么学习node-js" class="headerlink" title="为什么学习node.js"></a>为什么学习node.js</h2><ul>
<li><p>企业需求</p>
<ul>
<li>全栈开发工程师</li>
<li>学习node的目的就是打开服务端学习大门，了解服务端才能更好的配合服务端<a id="more"></a>
</li>
</ul>
</li>
<li><p>基本的网站开发能力</p>
<ul>
<li>服务端</li>
<li>前端</li>
<li>运维部署</li>
</ul>
</li>
<li><p>学习node帮助学习前端高级内容</p>
<ul>
<li>vue </li>
<li>react</li>
<li>angular</li>
</ul>
</li>
</ul>
<h2 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h2><ul>
<li><p>采用Javascript为基础，实现的后端语言<br>·node.js不是一门语言<br>·不是库、不是框架<br>·是一个javascript运行时环境<br>·简单点来讲就是node.js可以解析执行JavaScript代码<br>·以前只有浏览器可以执行解析JavaScript代码<br>·也就是说现在的JavaScript可以完全脱离浏览器来运行</p>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>ecmascript<ul>
<li>基本语法</li>
<li>if</li>
<li>var</li>
<li>。。。。</li>
</ul>
</li>
<li>DOM</li>
<li>BOM</li>
</ul>
</li>
<li><p>node.js中的JavaScript</p>
<ul>
<li>没有BOM DOM</li>
<li>EcmaScript</li>
<li>在node这个JavaScript执行环境中为JavaScript提供了一些服务器级别的操作API<ul>
<li>例如文件读写</li>
<li>网络服务的构建</li>
<li>网络通信</li>
<li>http 服务器</li>
<li>。。。。</li>
</ul>
</li>
</ul>
</li>
<li><p>构建与chrome v8引擎之上</p>
<ul>
<li>代码只是一串特殊的字符串</li>
<li>引擎可以认识它，引擎可以帮忙去解析和执行</li>
<li>Google chrome v8的引擎目前是公认的解析执行JavaScript代码最快的</li>
</ul>
</li>
<li><p>事件驱动</p>
</li>
<li><p>非阻塞I/O模型（异步）</p>
</li>
<li><p>清凉和高效</p>
</li>
<li><p>npm是世界上最大的开源库生态系统</p>
<ul>
<li>绝大多的JavaScript相关的包都放在了npm上，这样做的目的是为了让更多的开发人员更方便的下载使用</li>
</ul>
</li>
</ul>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><ul>
<li>web服务器后台</li>
<li>命令行工具<ul>
<li>npm</li>
<li>git（C）</li>
<li>hexo</li>
<li>。。。</li>
</ul>
</li>
<li>对于前端开发工程师来说，使用最多的是它的命令行工具</li>
</ul>
<h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><p> 《深入浅出node.js》  —朴灵，偏理论没有任何实战内容 理解底层原理有帮助<br> 《node.js权威指南》  —API讲解，无实战<br> js标准参考教程：<a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/</a><br> node入门：<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">http://www.nodebeginner.org/index-zh-cn.html</a><br> 官方API文档：<a href="https://nodejs.org/dist/latest-v6.x/docs/api" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v6.x/docs/api</a><br> CNODE社区：<a href="http://cnodejs.org" target="_blank" rel="noopener">http://cnodejs.org</a><br> CNODE新手入门：<a href="http://cnode.org/getstart" target="_blank" rel="noopener">http://cnode.org/getstart</a></p>
<h2 id="能学到啥"><a href="#能学到啥" class="headerlink" title="能学到啥"></a>能学到啥</h2><ul>
<li>B/S编程模型<ul>
<li>brower server</li>
<li>任何服务器端这种BS编程模型都是一样，与语言无关</li>
<li>node 只是我们学习BS编程模型的一个工具而已</li>
</ul>
</li>
<li>模块化编程<ul>
<li>Require JS</li>
<li>SeaJS</li>
<li>@import（‘’）</li>
<li>以前认知的js只能用script标签来加载</li>
<li>在node中可以向@import（）一样来引用加载js脚本文件</li>
</ul>
</li>
<li>node常用API </li>
<li>异步编程<ul>
<li>回调函数</li>
<li>Promise</li>
<li>async</li>
<li>generator</li>
</ul>
</li>
<li>express 开发框架</li>
<li>ES6</li>
</ul>
<h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>1、创建js脚本文件<br>2、打开终端，定位到脚本所属目录<br>3、输入‘node文件名’执行相应文件<br>注意：文件名不能以node.js来命名，不然会打开文件，且最好不要使用中文   code代码中的 01-noBOMandDOM.js</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>读文件和写文件全部通过实例代码编写放在code代码文件夹里面</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http服务请求最简单的如04-http.js相关代码文件注释</p>
<h2 id="node中的js"><a href="#node中的js" class="headerlink" title="node中的js"></a>node中的js</h2><p>·EcmaScript<br>·核心模块<br>·第三方模块<br>·用户自定义模块</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>node为JavaScript提供了很多服务器级别的API，这些API绝大多数都被包装到了一个具名的核心模块中了。<br>例如文件操作的fs核心模块，http服务构建的http模块，path路基那个操作模块，os操作系统信息模块。。。。<br>已经给我们封装起来了，直接使用不过就是要引入模块</p>
<h3 id="用户自定义模块"><a href="#用户自定义模块" class="headerlink" title="用户自定义模块"></a>用户自定义模块</h3><ul>
<li>相对路径必须加./</li>
<li>在node中没有全局作用域，只有模块作用域,简单来讲就是文件作用域，只在文件作用域中有效，出了文件以后就无效，也不会污染其它文件</li>
<li>相对路径中的./不能省略（会把它当成核心模块名来进行加载了）</li>
<li>可以省略后缀名</li>
</ul>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li>计算机中只有一个物理网卡，而且同一份局域网中，网卡的地址必须是唯一的。</li>
<li>网卡是通过唯一的ip地址来进行定位的。</li>
<li>IP地址用来定位计算机，端口号用来定位具体的应用程序（所有需要联网的程序都需要端口号）。</li>
<li>服务器（相当于是一台24小时不关机的计算机）里面可能会有很多软件的内存，但是这一台服务器在一个相同的局域网内，当另外一台计算机访问服务器想要获取内容时候，必须得根据相对应的软件来在服务器中找到相对应的软件，所以这就需要端口号，用来表示同一个局域网同一台计算机中的不同软件。即通过端口号来寻找在同一个服务器上的不同应用程序</li>
<li>一切需要联网通信的软件都会占用一个端口号</li>
<li>端口号的范围在0-65536</li>
<li>计算机有一些默认的端口号，最好不要去使用<ul>
<li>例如http服务的80</li>
</ul>
</li>
<li>使用一些好记的且没有含义的就可以3000 5000 8000</li>
<li>可以同时开启多个服务，但是要保证服务的端口号不一样</li>
<li>同一时间，同意端口号只能被同意程序占用</li>
</ul>
<h2 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h2><p>用来高速浏览器我发给你的数据是什么内容<br>  解决方法就是告诉浏览器使用什么编码<br>  res.setHeader(‘Content-Type’,’text/plain;charset=utf-8’)</p>
<ul>
<li>text/plain  就是普通文本</li>
<li>如果发送的是html格式的字符串，则也要高速浏览器发送的是html文档  text/html</li>
<li>图片不需要指定编码了，因为我们常说的编码一般是：字符编码</li>
</ul>
<ul>
<li>通过网络发送文件<ul>
<li>发送的不是文件而是文件的内容</li>
<li>根据content-type来进行解析处理</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(2)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node基础</tag>
        <tag>Node.js(2)</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记06--动画和渐变</title>
    <url>/2019/04/06/css3%E7%AC%94%E8%AE%B006/</url>
    <content><![CDATA[<h2 id="CSS3–动画和渐变"><a href="#CSS3–动画和渐变" class="headerlink" title="CSS3–动画和渐变"></a>CSS3–动画和渐变</h2><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>用于元素的变形，实现元素的选装，缩放，移动，倾斜等变形效果。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>：none|<span class="built_in">functions</span></span><br><span class="line">none：默认值，不设置变形</span><br><span class="line"><span class="built_in">functions</span>：设置一个或者多个变形函数。变形函数包括：rotate（）、缩放<span class="built_in">scale</span>（）、移动<span class="built_in">translate</span>（）、倾斜skew（）、举证变形<span class="built_in">matrix</span>（）等。设置多个变形函数用空格间隔</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>rotate（）函数用于定义元素在二维空间的旋转</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rotate</span>（<span class="keyword">angle</span>）</span><br></pre></td></tr></table></figure>

<p>angle单位是deg。值为正表示顺时针旋转，值为负表示为逆时针旋转</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：rotate（<span class="number">30</span>deg）；</span><br><span class="line">-moz-transform：rotate（<span class="number">30</span>deg）；</span><br><span class="line">-o-transform：rotate（<span class="number">30</span>deg）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：rotate（<span class="number">30</span>deg）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：rotate（<span class="number">30</span>deg）；</span><br></pre></td></tr></table></figure>
<h3 id="缩放和翻转"><a href="#缩放和翻转" class="headerlink" title="缩放和翻转"></a>缩放和翻转</h3><p>scale用于实现元素在二维空间的缩放和翻转<code>scale（x，y）</code></p>
<ul>
<li>x：表示元素在水平方向上的缩放倍数</li>
<li>y：表示元素在垂直方向上的缩放倍数</li>
<li>x、y的值可以为整数、负数、小数。当绝对值大于1表示放大，绝对值小于1表示缩小。当值为负数时，元素会被翻转如果y值省略，说明垂直方向上的缩放倍数跟水平方向上的缩放倍数相同</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="built_in">transform</span>：<span class="built_in">scale</span>（<span class="number">1.5</span>）；</span><br><span class="line">-moz-<span class="built_in">transform</span>：<span class="built_in">scale</span>（<span class="number">1.5</span>）；</span><br><span class="line">-o-<span class="built_in">transform</span>：<span class="built_in">scale</span>（<span class="number">1.5</span>）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-<span class="built_in">transform</span>：<span class="built_in">scale</span>（<span class="number">1.5</span>）；<span class="comment">/*IE9*/</span></span><br><span class="line"><span class="built_in">transform</span>：<span class="built_in">scale</span>（<span class="number">1.5</span>）；</span><br></pre></td></tr></table></figure>
<p>元素会放大1.5被倍数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：scale（<span class="number">0.8</span>，<span class="number">-1.5</span>）；</span><br><span class="line">-moz-transform：scale（<span class="number">0.8</span>，<span class="number">-1.5</span>）；</span><br><span class="line">-o-transform：scale（<span class="number">0.8</span>，<span class="number">-1.5</span>）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：scale（<span class="number">0.8</span>，<span class="number">-1.5</span>）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：scale（<span class="number">0.8</span>，<span class="number">-1.5</span>）；</span><br></pre></td></tr></table></figure>
<p>水平方向缩小，垂直方向为负值，且绝对值大于1，表现为元素会在垂直方向上放大并且翻转。</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>translate用于定义元素在二维空间上的移动<code>translate：（dx，dy）</code>；</p>
<ul>
<li>dx：表示在水平方向上的偏移距离</li>
<li>dy：在垂直方向上的偏移距伦理</li>
<li>dx、dy可以为负值和带小数的值，若取值大于0表示向下或享有偏移，取值小于0表示向上或向左偏移。如果dy值省略，表示垂直方向上的偏移距离默认为0.<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：translate（<span class="number">10</span>px <span class="number">5</span>px）；</span><br><span class="line">-moz-transform：translate（<span class="number">10</span>px <span class="number">5</span>px）；</span><br><span class="line">-o-transform：translate（<span class="number">10</span>px <span class="number">5</span>px）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：translate（<span class="number">10</span>px <span class="number">5</span>px）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：translate（<span class="number">10</span>px <span class="number">5</span>px）；</span><br></pre></td></tr></table></figure>
元素会向右偏移10px，向下偏移5px<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="built_in">transform</span>：<span class="built_in">translate</span>（-10px）；</span><br><span class="line">-moz-<span class="built_in">transform</span>：<span class="built_in">translate</span>（-10px）；</span><br><span class="line">-o-<span class="built_in">transform</span>：<span class="built_in">translate</span>（-10px）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-<span class="built_in">transform</span>：<span class="built_in">translate</span>（-10px）；<span class="comment">/*IE9*/</span></span><br><span class="line"><span class="built_in">transform</span>：<span class="built_in">translate</span>（-10px）；</span><br></pre></td></tr></table></figure>
表示元素会在水平方向上向左偏移10px，垂直方向上不偏移</li>
</ul>
<h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><p>skew（）用于定义元素在二维空间上的倾斜变<code>skew（angleX，angleY）</code></p>
<ul>
<li>angleX：在水平方向的倾斜度数</li>
<li>angleY：在垂直方向上的倾斜度数<br>angleX、angleY单位是deg，值为正表示顺时针旋转，值为负，表示逆时针旋转。如果angleY省略，则说明垂直方向上的倾斜度数默认是0。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：skew（<span class="number">-30</span>deg）；</span><br><span class="line">-moz-transform：skew（<span class="number">-30</span>deg）；</span><br><span class="line">-o-transform：skew（<span class="number">-30</span>deg）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：skew（<span class="number">-30</span>deg）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：skew（<span class="number">-30</span>deg）；</span><br></pre></td></tr></table></figure>
水平方向顺时针倾斜30度。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：skew（<span class="number">30</span>deg，<span class="number">-10</span>deg）；</span><br><span class="line">-moz-transform：skew（<span class="number">30</span>deg，<span class="number">-10</span>deg）；</span><br><span class="line">-o-transform：skew（<span class="number">30</span>deg，<span class="number">-10</span>degg）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：skew（<span class="number">30</span>deg，<span class="number">-10</span>deg）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：skew（<span class="number">30</span>deg，<span class="number">-10</span>deg）；</span><br></pre></td></tr></table></figure>
水平方向倾斜30度，垂直方向逆时针倾斜10度</li>
</ul>
<h3 id="同时使用多个变形函数"><a href="#同时使用多个变形函数" class="headerlink" title="同时使用多个变形函数"></a>同时使用多个变形函数</h3><p>可以同时使用多个变形函数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：translate（<span class="number">10</span>px，<span class="number">10</span>px） rotate（<span class="number">30</span>deg） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br><span class="line">-moz-transform：translate（<span class="number">10</span>px，<span class="number">10</span>px） rotate（<span class="number">30</span>deg） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br><span class="line">-o-transform：translate（<span class="number">10</span>px，<span class="number">10</span>px） rotate（<span class="number">30</span>deg） scale（<span class="number">1</span>，<span class="number">-1</span>）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform：translate（<span class="number">10</span>px，<span class="number">10</span>px） rotate（<span class="number">30</span>deg） scale（<span class="number">1</span>，<span class="number">-1</span>）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform：translate（<span class="number">10</span>px，<span class="number">10</span>px） rotate（<span class="number">30</span>deg） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br></pre></td></tr></table></figure>
<p>当变形函数的顺序调换了不一样的时候，可能会产生不一样的变形效果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform：  rotate（<span class="number">30</span>deg） translate（<span class="number">10</span>px，<span class="number">10</span>px） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br><span class="line">-moz-transform： rotate（<span class="number">30</span>deg） translate（<span class="number">10</span>px，<span class="number">10</span>px） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br><span class="line">-o-transform： rotate（<span class="number">30</span>deg） translate（<span class="number">10</span>px，<span class="number">10</span>px） scale（<span class="number">1</span>，<span class="number">-1</span>）；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform： rotate（<span class="number">30</span>deg） translate（<span class="number">10</span>px，<span class="number">10</span>px） scale（<span class="number">1</span>，<span class="number">-1</span>）；<span class="comment">/*IE9*/</span></span><br><span class="line">transform： rotate（<span class="number">30</span>deg） translate（<span class="number">10</span>px，<span class="number">10</span>px） scale（<span class="number">1</span>，<span class="number">-1</span>）；</span><br></pre></td></tr></table></figure>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p>定义变形原点<code>transform-origin：x，y</code></p>
<ul>
<li>x：定义变形的横坐标位置，默认值是50%，取值包括left、center、right、百分比值、长度值</li>
<li>y：变形的纵坐标位置，默认是50%，取值包括top、middle、bottom、百分比值、长度值<br>百分比是相对于元素对象的宽度和高度而言的，而该坐标位置的计算，是以元素的左上角为坐标原点进行计算的。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transform-origin：<span class="number">0</span> <span class="number">0</span>；</span><br><span class="line">-moz-transform-origin：<span class="number">0</span> <span class="number">0</span>；</span><br><span class="line">-o-transform-origin：<span class="number">0</span> <span class="number">0</span>；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform-origin：<span class="number">0</span> <span class="number">0</span>；<span class="comment">/*IE9*/</span></span><br><span class="line">transform-origin：<span class="number">0</span> <span class="number">0</span>；</span><br></pre></td></tr></table></figure>
表示以该元素的左上角为原点，进行相关变形操作</li>
</ul>
<h3 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h3><p>transition</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">transition：transition-property|<span class="type">|transition</span>-duration|<span class="type">|transition</span>-timing-function|<span class="type">|transition</span>-delay</span><br></pre></td></tr></table></figure>
<ul>
<li>transition-property：定义过度的属性</li>
<li>transition-duration：定义过渡过程需要的时间</li>
<li>transition-timing-function：过渡方式</li>
<li>transition-delay：延迟时间<br>可以同时设置定义两组或两组以上的过渡效果，每组用逗号间隔。<br>包含子属性：transition-property、transition-duration、transition-timing-function、transition-delay。<br>都需要加前缀。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-transition：all <span class="number">1000</span>ms linear <span class="number">500</span>ms；</span><br><span class="line">-moz-transition：all <span class="number">1000</span>ms linear <span class="number">500</span>ms；</span><br><span class="line">-o-transform-transition：all <span class="number">1000</span>ms linear <span class="number">500</span>ms；<span class="comment">/*presto内核*/</span></span><br><span class="line">-ms-transform-transition：all <span class="number">1000</span>ms linear <span class="number">500</span>ms；<span class="comment">/*IE9*/</span></span><br><span class="line">transform-transition：all <span class="number">1000</span>ms linear <span class="number">500</span>ms；</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>过度属性。<code>transition-property：none|all|property</code></p>
<ul>
<li>none：表示没有任何CSS过度属性</li>
<li>all：为默认值，表示所有的CSS属性都有过渡效果</li>
<li>property：指定一个用逗号分隔的多个属性，针对指定的这些属性有过渡效果。</li>
</ul>
<h3 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h3><p>用于定义过渡过程中需要的时间</p>
<ul>
<li>transition-duration：time；</li>
<li>time：指定一个用逗号分隔的多个时间值，时间的单位可以是s或ms。默认情况下为0，即看不到过渡效果，看到的直接是结果。</li>
</ul>
<h3 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h3><p>transition-delay：time<br>单位可以是s，ms，默认为0.没有时间延迟，立即开始过渡效果。</p>
<h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">transition-timing-function：ease|<span class="type">linear</span>|<span class="type">ease</span>-out|<span class="type">ease</span>-<span class="built_in">in</span>|<span class="type">ease</span>-<span class="built_in">in</span>-out|<span class="type">cubic</span>-bezier（n，n，n，n）；</span><br></pre></td></tr></table></figure>
<ul>
<li>linear：过度一直是一个速度，相当于cubic-bezier（0，0，1，1）</li>
<li>ease：属性的默认值，表示过度的速度先慢再快最后非常慢，相当于cubic-bezier（0.25，0.1，0。25，1）</li>
<li>ease-in：过度速度先慢后越来越快，直至结束，相当于cubic-bezier（0.42，0，1，1）</li>
<li>ease-out：过渡速度先快后越来越慢，直至结束，相当于cubic-bezier（0，0，0.58，1）</li>
<li>ease-in-out：过渡速度在开始和结束时都很慢，相当于cubic-bezier（0.42，0，0.58，1）</li>
<li>cubic-bezier：自定义贝塞尔曲线效果，四个参数为0到1的数字。</li>
</ul>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> animationname&#123;keyframes-selector&#123;css-styleless&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>animationname：动画的名称。必须定义一个动画名称，方便与动画属性animation绑定</li>
<li>keyframes-selector：动画持续的百分比，也可以是从from到to；from=&gt;0%，to=&gt;100%。必须顶一个才能实现动画</li>
<li>css-styleless：设置的一个或多个合法的样式属性，必须定义一些样式才能实现动画</li>
</ul>
<p>关键帧动画是通过名称和动画绑定的。例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@-moz-keyframes mymove&#123;</span><br><span class="line">	<span class="number">0</span>%&#123;top：<span class="number">0</span>px；&#125;</span><br><span class="line">	<span class="number">25</span>%&#123;top：<span class="number">200</span>px； left：<span class="number">200</span>px&#125;</span><br><span class="line">	<span class="number">75</span>%&#123;top：<span class="number">50</span>px； left：<span class="number">10</span>px；&#125;</span><br><span class="line">	<span class="number">100</span>%&#123;top：<span class="number">100</span>px；left：<span class="number">60</span>px；&#125;</span><br><span class="line">&#125;</span><br><span class="line">@-webkit-keyframes mymove&#123;</span><br><span class="line">	<span class="number">0</span>%&#123;top：<span class="number">0</span>px；&#125;</span><br><span class="line">	<span class="number">25</span>%&#123;top：<span class="number">200</span>px； left：<span class="number">200</span>px&#125;</span><br><span class="line">	<span class="number">75</span>%&#123;top：<span class="number">50</span>px； left：<span class="number">10</span>px；&#125;</span><br><span class="line">	<span class="number">100</span>%&#123;top：<span class="number">100</span>px；left：<span class="number">60</span>px；&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>专门用于动画设计，可以把一个或多个关键帧动画绑定到元素上，以实现更复杂的动画</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">animation：<span class="keyword">name</span> duration timing-<span class="function"><span class="keyword">function</span></span> delay iyeration-<span class="built_in">count</span> direction</span><br></pre></td></tr></table></figure>
<ul>
<li>name：动画的名字，绑定指定的关键帧动画，默认值为none，表示没有动画</li>
<li>duration：动画播放的周期时间，默认为0</li>
<li>timing-function：动画的播放方式，即速度曲线</li>
<li>delay：动画的延迟时间，默认0</li>
<li>iyeration-count：动画应该播放的次数，infinite表示无限次的播放下去，默认属性值为1</li>
<li>direction：播放的顺序方向，normal（默认值，按照关键帧定义的动画方向播放）altenate（表示动画的播放方向与上已播放周期相反）</li>
</ul>
<p>animation可以定义一个动画的6个方面的参数信息，还可以定义多个动画，每个动画的参数信息为一组，用逗号分开来。‘<br>包含子属性：<code>animation-name、 animation-duration 、animation-timing-function、animation- delay 、animation-iyeration-count、animation- direction</code></p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记05--多列布局</title>
    <url>/2019/04/05/css3%E7%AC%94%E8%AE%B005/</url>
    <content><![CDATA[<h2 id="CSS3–多列布局"><a href="#CSS3–多列布局" class="headerlink" title="CSS3–多列布局"></a>CSS3–多列布局</h2><h3 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h3><p>用于快速定义多列的列数目和每列的宽度。基于webkit的替代私有属性是-webkit-columns，gecko内核的浏览器不支持</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">columns</span>：width|<span class="built_in">count</span></span><br><span class="line">width：每列的宽度</span><br><span class="line"><span class="built_in">count</span>：多列的列数</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>实际布局的时候，定义的多列的列数是最大列数，当外围宽度不足的时候，多列的列数会适当减少，而每列的宽度会自适应宽度，填满整个范围。<br>例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-columns： <span class="number">200</span>px <span class="number">3</span>；</span><br><span class="line">columns：<span class="number">200</span>px <span class="number">3</span>；</span><br></pre></td></tr></table></figure>
<p>每列的高度尽可能一致。如果缩小浏览窗的宽度，则文章会编程2列或一列，每列的高度尽可能一直，而每列的宽度会自适应分配，不一定是200px。</p>
<h3 id="column-width"><a href="#column-width" class="headerlink" title="column-width"></a>column-width</h3><p>用来定义多列布局中每列的宽度，基于webkit内核的替代私有属性是-webkit-column-width，基于gecko内核的替代私有属性是-moz-column-width。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">column-<span class="built_in">width</span>：<span class="keyword">auto</span>|length</span><br><span class="line"><span class="keyword">auto</span>：列的宽度由浏览器决定</span><br><span class="line">length：直接指定列的宽度。</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-column-width：<span class="number">200</span>px；</span><br><span class="line">-moz-column-width：<span class="number">200</span>px；</span><br><span class="line">column-width：<span class="number">200</span>px；</span><br></pre></td></tr></table></figure>
<p>当浏览窗口改变时，列数会及时调整，列数不固定</p>
<h3 id="colum-count"><a href="#colum-count" class="headerlink" title="colum-count"></a>colum-count</h3><p>用来定义多列布局中的列数目。基于webkit内核的是-webkit-column-count，基于gecko的是-moz-column-count</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">column</span>-<span class="built_in">count</span>：auto|number</span><br><span class="line">auto：列的数目由其他属性决定，列入<span class="built_in">column</span>-width</span><br><span class="line">number：直接指定列的数目，决定了列的最大列数</span><br><span class="line"></span><br><span class="line">-webkit-<span class="built_in">column</span>-<span class="built_in">count</span>：<span class="number">3</span>；</span><br><span class="line">-moz-<span class="built_in">column</span>-<span class="built_in">count</span>：<span class="number">3</span>；</span><br><span class="line"><span class="built_in">column</span>-<span class="built_in">count</span>：<span class="number">3</span>；</span><br></pre></td></tr></table></figure>
<p>当设置了列的数目的时候，当窗口大小改变的时候，列宽会及时调整，列数固定不变。</p>
<h3 id="column-gap"><a href="#column-gap" class="headerlink" title="column-gap"></a>column-gap</h3><p>用于定于多列布局中列与列之间的距离。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">column-gap：<span class="keyword">normal</span>|length</span><br><span class="line"><span class="keyword">normal</span>：默认值，由浏览器默认的列间距，一般是<span class="number">1</span><span class="keyword">em</span></span><br><span class="line">length:指定列与列之间的距离。</span><br><span class="line"></span><br><span class="line">-webkit-column-gap：<span class="number">3</span><span class="keyword">em</span>；</span><br><span class="line">-moz-column-gap：<span class="number">3</span><span class="keyword">em</span>；</span><br><span class="line">column-gap：<span class="number">3</span><span class="keyword">em</span>；</span><br></pre></td></tr></table></figure>
<h3 id="column-rule"><a href="#column-rule" class="headerlink" title="column-rule"></a>column-rule</h3><p>用于定义列与列之间的分割线。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">column</span>-<span class="keyword">rule</span>：<span class="keyword">column</span>-<span class="keyword">rule</span>-width||<span class="keyword">column</span>-<span class="keyword">rule</span>-style||<span class="keyword">column</span>-<span class="keyword">rule</span>-color；</span><br><span class="line"><span class="keyword">column</span>-<span class="keyword">rule</span>-width：定义分割线的宽度</span><br><span class="line"><span class="keyword">column</span>-<span class="keyword">rule</span>-style：定义分割线的样式风格（跟border-style相同）</span><br><span class="line"><span class="keyword">column</span>-<span class="keyword">rule</span>-color：颜色</span><br></pre></td></tr></table></figure>
<h3 id="派生子属性："><a href="#派生子属性：" class="headerlink" title="派生子属性："></a>派生子属性：</h3><p>column-rule-width：定义分割线的宽度<br>column-rule-style：定义分割线的样式风格（跟border-style相同）<br>column-rule-color：颜色</p>
<p>派生子属性的用法跟border属性及其子属性用法相同。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-column-rule：<span class="number">1</span>px solid #<span class="number">666</span>；</span><br><span class="line">-moz-column-rule：<span class="number">1</span>px solid #<span class="number">666</span>；</span><br><span class="line">column-rule：<span class="number">1</span>px solid #<span class="number">666</span>；</span><br></pre></td></tr></table></figure>
<p>也可以用派生子属性来定义。</p>
<h3 id="column-span"><a href="#column-span" class="headerlink" title="column-span"></a>column-span</h3><p>在多列布局中，用于定义元素跨列显示。gecko内核的浏览器不支持该属性</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">column</span>-span：<span class="number">1</span>|<span class="keyword">all</span></span><br><span class="line"><span class="number">1</span>：默认值，元素在一列中显示</span><br><span class="line"><span class="keyword">all</span>：元素跨所有列显示</span><br><span class="line"></span><br><span class="line">-webkit-<span class="keyword">column</span>-span：<span class="keyword">all</span>；</span><br><span class="line"><span class="keyword">column</span>-span：<span class="keyword">all</span>；</span><br></pre></td></tr></table></figure>
<p>一般这种方法用来表示标题，让标题能够跨所有列居中表示</p>
<p>该属性应该设置在父容器中，一般是设置在body元素中，这样的话，在body标签内的所有标签都是呈现的三列布局表示。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记04--背景+边框</title>
    <url>/2019/04/05/css3%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<h2 id="CSS3–背景-边框"><a href="#CSS3–背景-边框" class="headerlink" title="CSS3–背景+边框"></a>CSS3–背景+边框</h2><h3 id="多个背景图片"><a href="#多个背景图片" class="headerlink" title="多个背景图片"></a>多个背景图片</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>：[<span class="built_in">background</span>-<span class="built_in">image</span>]|[<span class="built_in">background</span>-origin]|[<span class="built_in">background</span>-clip]|[<span class="built_in">background</span>-repeat]|[<span class="built_in">background</span>-<span class="built_in">size</span>]|[<span class="built_in">background</span>-<span class="built_in">position</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">background</span>-origin]：指定背景的原点位置，属于新增的属性</span><br><span class="line">[<span class="built_in">background</span>-clip]：指定 背景的显示区域</span><br><span class="line">[<span class="built_in">background</span>-repeat]：背景图像是否重排</span><br><span class="line">[<span class="built_in">background</span>-<span class="built_in">size</span>]：指定而背景图片的大小</span><br><span class="line">[<span class="built_in">background</span>-<span class="built_in">position</span>]：背景图像位置</span><br></pre></td></tr></table></figure>
<p>如果定义多重背景图，则用逗号隔开各个背景图。</p>
<p>比如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">background：url（.../images/<span class="number">1.</span>png) <span class="number">120</span>px <span class="number">110</span>px no-repeat,</span><br><span class="line">            url（.../images/<span class="number">2.</span>png) <span class="number">400</span>px <span class="number">10</span>px no-repeat,</span><br><span class="line">            url（.../images/<span class="number">3.</span>png) no-repeat;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>写在前面的背景图像会显示在上面，写在后面的图像背景会显示在下面。<br>也可以改写成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">background-image：url（.../images/<span class="number">1.</span>png)，url（.../images/<span class="number">2.</span>png)，url（.../images/<span class="number">3.</span>png)；</span><br><span class="line">background-position：<span class="number">120</span>px <span class="number">110</span>px，<span class="number">400</span>px <span class="number">10</span>px，<span class="number">0</span> <span class="number">0</span>；</span><br><span class="line">background-repeat：no-repeat,no-repeat,no-repeat；</span><br></pre></td></tr></table></figure>
<h3 id="背景的原点位置"><a href="#背景的原点位置" class="headerlink" title="背景的原点位置"></a>背景的原点位置</h3><p>用新增的background-origin来指定背景图像的原点位置。在默认情况下，background-position总是以元素边框以内的左上角为坐标原点进行背景图像定位。使用background-origin属性可以对该原点位置进行调整。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">border</span>-<span class="built_in">box</span>|padding-<span class="built_in">box</span>|<span class="built_in">content</span>-<span class="built_in">box</span></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">box</span>：原点位置为边框（<span class="built_in">border</span>）区域的开始位置（默认值）</span><br><span class="line">padding-<span class="built_in">box</span>：原点位置为内边距（padding）区域的开始位置</span><br><span class="line"><span class="built_in">content</span>-<span class="built_in">box</span>：原点位置为内容（<span class="built_in">content</span>）区域的开始位置</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，要加前缀</p>
<h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">-webikit-<span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">border</span>-<span class="built_in">box</span>；</span><br><span class="line">-moz-<span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">border</span>-<span class="built_in">box</span>；</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">border</span>-<span class="built_in">box</span>；</span><br></pre></td></tr></table></figure>
<h3 id="padding-box"><a href="#padding-box" class="headerlink" title="padding-box"></a>padding-box</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">-webikit-<span class="built_in">background</span>-<span class="built_in">origin</span>：padding-<span class="built_in">box</span>；</span><br><span class="line">-moz-<span class="built_in">background</span>-<span class="built_in">origin</span>：padding-<span class="built_in">box</span>；</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span>：padding-<span class="built_in">box</span>；</span><br></pre></td></tr></table></figure>
<h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">-webikit-<span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">content</span>-<span class="built_in">box</span>；</span><br><span class="line">-moz-<span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">content</span>-<span class="built_in">box</span>；</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span>：<span class="built_in">content</span>-<span class="built_in">box</span>；</span><br></pre></td></tr></table></figure>
<h3 id="指定背景的显示区域"><a href="#指定背景的显示区域" class="headerlink" title="指定背景的显示区域"></a>指定背景的显示区域</h3><p>background-clip用来指定北京的显示区域。在CSS3下，背景的显示区域是包含元素边框在内的。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-clip：<span class="built_in">border</span>-<span class="built_in">box</span>|padding-<span class="built_in">box</span>|<span class="built_in">content</span>-<span class="built_in">box</span></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">box</span>：背景从边框开始显示</span><br><span class="line">padding-<span class="built_in">box</span>：背景从内边距开始显示</span><br><span class="line"><span class="built_in">content</span>-<span class="built_in">box</span>：背景从内容区域开始显示</span><br></pre></td></tr></table></figure>
<p>使用方式和background-origin相似，考虑兼容性需要添加前缀</p>
<h3 id="指定背景元素大小"><a href="#指定背景元素大小" class="headerlink" title="指定背景元素大小"></a>指定背景元素大小</h3><p>用background-size属性来指定背景大小</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">background-size：[&lt;length&gt;|&lt;percentage&gt;|<span class="built_in">auto</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|cover|contain</span><br><span class="line"></span><br><span class="line">length：长度值，不可为负值</span><br><span class="line">percentage：<span class="number">0</span>%~<span class="number">100</span>%之间的值，是基于背景图像的父元素的百分比</span><br><span class="line">cover：保持背景图像本身的宽高比例，将图像缩放到正好完全覆盖适应所定义的背景区域</span><br><span class="line">contain：保持背景图像本身的宽高比例，将图像缩放到正好适应所定义的背景区域</span><br><span class="line">cover和contain的区别：使用这两个属性的时候，图像都采用了缩放，不同的是，cover，背景图像按比例缩放，直至覆盖整个背景区域，但可能会裁剪掉部分图像。当属性为content时候，背景图像会完全显示出来，但可能不会完全覆盖背景区域。</span><br></pre></td></tr></table></figure>
<h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">border-radius：none|&lt;length&gt;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span><br><span class="line">none:默认值，没有圆角</span><br><span class="line">&lt; length&gt;：不可为负值。分为两组，每组有<span class="number">1</span>–<span class="number">4</span>个值，第一组为水平半径，第二组为垂直半径，如果第二组省略，则默认等于第一组的值</span><br></pre></td></tr></table></figure>
<h3 id="派生子属性"><a href="#派生子属性" class="headerlink" title="派生子属性"></a>派生子属性</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">border-<span class="built_in">top</span>-<span class="built_in">left</span>-radius：左上角</span><br><span class="line">border-<span class="built_in">top</span>-<span class="built_in">right</span>-radius：右上角</span><br><span class="line">border-<span class="built_in">bottom</span>-<span class="built_in">left</span>-radius：左下角</span><br><span class="line">border-<span class="built_in">bottom</span>-<span class="built_in">right</span>-radius：右下角</span><br></pre></td></tr></table></figure>
<p>如果有空缺的值的话，以顺时针方向来填满。</p>
<h3 id="两组半径的圆角"><a href="#两组半径的圆角" class="headerlink" title="两组半径的圆角"></a>两组半径的圆角</h3><p>可以同时指定两组半径值：第一组的值表示圆角的水平半径，第二组的值表示圆角的垂直半径。通常用该方式来画椭圆。第一组的值和第二组的值用/隔开。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">border-radius：<span class="number">20</span>px/<span class="number">40</span>px；</span><br></pre></td></tr></table></figure>
<p>此时的边框圆角每个都是1/4的椭圆</p>
<p>border-radius的派生子属性不能用两组半径的方式来赋值</p>
<h3 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h3><p>在CSS3之前，图像不能直接用于边框。border-image属性专门用来做边框图像处理<br>定义属性都跟border-radius相同，不过是把radius换成image而已</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>-source：定义图片的资源</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>-slice：定义图像的切片，设置图像的边界向内的偏移长度</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>-repeat：重复</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>-<span class="built_in">width</span>：宽度</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>-outset：偏移位置</span><br></pre></td></tr></table></figure>
<p>需要用兼容加前缀的方式来实现</p>
<h3 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a>border-color</h3><p>可以加颜色和透明度<br>派生的子属性也同上述几种情况</p>
<p>要想设计一个圆形边框，只用<code>border-radius：50% 50%</code></p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记03--界面设计</title>
    <url>/2019/04/04/css3%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<h2 id="CSS3–界面设计"><a href="#CSS3–界面设计" class="headerlink" title="CSS3–界面设计"></a>CSS3–界面设计</h2><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">resize：none|<span class="type">both</span>|<span class="type">horizontal</span>|<span class="type">vertical</span>|<span class="type">inherit</span>；</span><br></pre></td></tr></table></figure>
<ul>
<li>none：默认值，表示不能调整元素</li>
<li>both：表示可以调整元素的宽度和高度</li>
<li>horizontal：表示用户可以调整元素的宽度，但是不能调整元素的高度</li>
<li>vertical：表示可以调整元素的高度，按时不能调整元素的宽度</li>
<li>inherit：继承父元素<a id="more"></a>
注意：resize属性需要和溢出处理overflow或overflow-x或overflow-y一起使用，才能把元素定义成可以调整大小的，且溢出属性值不能为visible。<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">resize</span>：both；</span><br><span class="line">	<span class="attribute">overflow</span>：<span class="attribute">auto</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="appearance"><a href="#appearance" class="headerlink" title="appearance"></a>appearance</h3><p>可以方便的把元素伪装成其他类型的元素。但是需要考虑叫兼容性</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">appearance：normal|<span class="type">icon</span>|<span class="type">window</span>|<span class="type">button</span>|<span class="type">menu</span>|<span class="type">field</span>；</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">normal：正常的修饰元素</span><br><span class="line">icon：把元素修饰成像一个图标</span><br><span class="line"><span class="keyword">window</span>：把元素修饰成像一个视窗</span><br><span class="line"><span class="keyword">button</span>：把元素修饰成像一个按钮</span><br><span class="line"><span class="keyword">menu</span>：把元素修饰成像一个菜单</span><br><span class="line">field：把元素修饰成像一个输入框</span><br></pre></td></tr></table></figure>
<p>appearance定义的元素，仍然保留元素的功能，只在外观上做了一些改变。由于收到元素本身功能的局限，不是每一个元素都可以任意被修改，但是恰当的修饰大部分是可行的。</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">-webkit-appearance：<span class="keyword">button</span>；</span><br><span class="line">-moz-appearance：<span class="keyword">button</span>；</span><br><span class="line">appearance：<span class="keyword">button</span>；</span><br></pre></td></tr></table></figure>

<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>为元素添加内容<br>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=html]</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">"网页"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=jpg]</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">"图片"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话在连接对应位置的前面会显示相应的文字，比如在网页链接前面显示网页两个字，在图片显示前面显示图片两个字。</p>
<h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>该属性用来在元素周围定义轮廓线。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">outline-width</span>：定义宽度</span><br><span class="line"><span class="attribute">outline-style</span>：元素风格（<span class="attribute">none</span>、dotted、dashed、solid、double、groove、ridge、inset、outset、<span class="attribute">inherit</span>）</span><br><span class="line"><span class="attribute">outline-color</span>：颜色设置</span><br><span class="line"><span class="attribute">outline-offset</span>：偏移距离，轮廓线和边界的距离</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记02--文本与字体</title>
    <url>/2019/04/03/css3%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h2 id="CSS3–文本与字体"><a href="#CSS3–文本与字体" class="headerlink" title="CSS3–文本与字体"></a>CSS3–文本与字体</h2><h3 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h3><p>参数说明：<code>text-shadow：Xpx Ypx opaciety color</code><br>分别表示为：水平方向相对于字体本身偏移的距离，在垂直方向上相对于字体本身偏移的距离，以及阴影模糊作用域的距离（默认为0，没有阴影效果），颜色<br>X、Y可以为负值，就相当于，水平方向向左偏移，垂直方向向上偏移。</p>
<a id="more"></a>
<h3 id="文字的描边效果"><a href="#文字的描边效果" class="headerlink" title="文字的描边效果"></a>文字的描边效果</h3><p>可以利用text-shadow的属性，同时在上、下、左、右四个方向为文字设置多个阴影， 且不设置模糊作用距离（取默认值）。就可以实现描边效果。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">text-shadow：<span class="number">-1</span>px <span class="number">0</span> #<span class="number">333</span>，<span class="comment">/*向左偏移*/</span></span><br><span class="line">             <span class="number">1</span>px <span class="number">0</span> #<span class="number">333</span>，<span class="comment">/*向右偏移*/</span></span><br><span class="line">             <span class="number">0</span> <span class="number">1</span>px #<span class="number">333</span>，<span class="comment">/*向下偏移*/</span></span><br><span class="line">             <span class="number">0</span> <span class="number">-1</span>px #<span class="number">333</span>；<span class="comment">/*向上偏移*/</span></span><br></pre></td></tr></table></figure>
<p>在四个方向上可以分别设置1个像素的阴影，且没有模糊效果，组合起来就是描边效果了。</p>
<h3 id="文本的发光效果"><a href="#文本的发光效果" class="headerlink" title="文本的发光效果"></a>文本的发光效果</h3><p>可以利用text-shadow属性的特性，不设置水平和垂直的偏移距离，仅设置模糊作用距离，这样就可以通过修改模糊值来实现强度不同的发光效果了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">text-shadow：<span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px #fff；<span class="comment">/*没有偏移的模糊设置*/</span></span><br></pre></td></tr></table></figure>
<p>在水平和垂直方向上的偏移距离为0，只设置模糊效果，加上深灰色背景的衬托，就有了发光的效果了。</p>
<p>需要考虑兼容性的问题：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="keyword">text</span>-shadow：Xpx Ypx opaciety <span class="keyword">color</span>；</span><br><span class="line">-moz-<span class="keyword">text</span>-shadow：Xpx Ypx opaciety <span class="keyword">color</span>；</span><br><span class="line"><span class="keyword">text</span>-shadow：Xpx Ypx opaciety <span class="keyword">color</span>；</span><br></pre></td></tr></table></figure>

<h3 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">text</span>-<span class="built_in">overflow</span>：clip ellipsis elipsis-<span class="keyword">word</span></span><br></pre></td></tr></table></figure>
<p>说明：clip：标识直接裁切溢出的文本；ellpsis标识文本溢出时，显示省略标记（…），省略标记代表最后一个字符；elipsis-word表示文本溢出时候，显示省略标记（…），和ellipsis不同的是，省略标记代替的是最后一个字符。</p>
<h3 id="溢出文本省略标记"><a href="#溢出文本省略标记" class="headerlink" title="溢出文本省略标记"></a>溢出文本省略标记</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>：hidden；<span class="comment">/*溢出内容设置为隐藏*/</span></span><br><span class="line"><span class="attribute">white-space</span>：nowrap；<span class="comment">/*强制文本单行显示*/</span></span><br><span class="line"><span class="attribute">text-overflow</span>：ellipsis；<span class="comment">/*设置溢出文本为省略标记*/</span></span><br></pre></td></tr></table></figure>
<h3 id="word-wrap、word-break"><a href="#word-wrap、word-break" class="headerlink" title="word-wrap、word-break"></a>word-wrap、word-break</h3><h4 id="边界换行word-wrap"><a href="#边界换行word-wrap" class="headerlink" title="边界换行word-wrap"></a>边界换行word-wrap</h4><p>设置或检索单枪行超过指定容器的边界时候，是否断开换行。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">word</span>-<span class="keyword">wrap</span>：<span class="keyword">normal</span>|break-<span class="built_in">word</span>；</span><br><span class="line"><span class="keyword">normal</span>：连续文本换行，是默认值，允许内容超出边界。</span><br><span class="line">break-<span class="built_in">word</span>：内容将在边界内换行，如果需要，词内换行也会发生</span><br></pre></td></tr></table></figure>
<h4 id="词内换行word-break"><a href="#词内换行word-break" class="headerlink" title="词内换行word-break"></a>词内换行word-break</h4><p>设置或检索对象内文本的字内换行行为，尤其在出现多种语言时，对于中文应该使用word-break。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">word-<span class="keyword">break</span>：<span class="keyword">normal</span>|<span class="keyword">break</span>-<span class="keyword">all</span>|keep-<span class="keyword">all</span></span><br><span class="line"><span class="keyword">normal</span>：允许在字内换行；</span><br><span class="line"><span class="keyword">break</span>-<span class="keyword">all</span>：允许非亚洲语言文本的任意字内断开，该值适合包含一些非亚洲文本的亚洲文本；</span><br><span class="line">keep-<span class="keyword">all</span>：对于中文、韩文、日文不允许字断开，适合包含少量亚洲文本的非亚洲文本。</span><br></pre></td></tr></table></figure>

<h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><p>通过@font-face规则来引用互联网任一服务器中存在的字体。让客户端显示客户端没有安装的字体。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>：&#123;属性：取值；&#125;</span><br></pre></td></tr></table></figure>
<p>属性及取值如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>：设置文本的字体名称</span><br><span class="line"><span class="attribute">font-style</span>：设置文本样式</span><br><span class="line"><span class="attribute">font-variant</span>：设置文本是否为小型大写字母，字母大小写</span><br><span class="line"><span class="attribute">font-weight</span>：设置字体粗细</span><br><span class="line"><span class="attribute">font</span>-strentch：设置文本是否为横向的拉伸变形</span><br><span class="line"><span class="attribute">font-size</span>：设置文本字体大小</span><br><span class="line"><span class="attribute">src</span>：设置自定义字体的相对路径或者绝对路径，可以包含format信息，此属性只能在<span class="keyword">@font-face</span>里面使用</span><br><span class="line"><span class="attribute">src</span>是必要的属性，其他的可以选择使用</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">font</span>-<span class="title">face</span>&#123;</span><br><span class="line">	<span class="built_in">font</span>-family：myfont；<span class="comment">/*自定义字体名称*/</span></span><br><span class="line">	src：<span class="built_in">url</span>（../<span class="built_in">font</span>）format（“tyurtypr”）；<span class="comment">/*指定字体路径*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用的时候</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">p</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">	font：myfont；</span></span><br><span class="line"><span class="template-variable"></span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：通过@font-face规则使用服务器字体，不建议 应用与中文网站，因为中文的字体文件都是几MB到十几MB，大文件会影响网页的加载速度，如果是少量特殊字体，可以用图片来代替。而英文字体的文件只有几十KB，非常适合用@font-face规则。<br>如果客户端安装的字体吩咐，包含了服务端提供的字体，处于性能的考虑，我们会尽可能的选择客户端的字体，避免字体文件的网络传输中造成的性能损失。可以将规则中src属性的值通过“local（）”来指定本地系统的字体。利用src属性可以同时指定多个地址的特性。比如：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">font</span>-<span class="title">face</span>&#123;</span><br><span class="line">	<span class="built_in">font</span>-family：myfont；<span class="comment">/*自定义字体名称*/</span></span><br><span class="line">	src：local（“hemi”）；<span class="comment">/*指向客户端本地系统字体*/</span></span><br><span class="line">	    <span class="built_in">url</span>（../<span class="built_in">font</span>）format（“tyurtypr”）；<span class="comment">/*指定服务器端字体路径*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端存在相应字体时，就显示客户端的字体，当客户端不存在改字体时候，就显示服务器端提供的字体。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器04--Event Loop（1）</title>
    <url>/2019/04/02/%E6%B5%8F%E8%A7%88%E5%99%A804/</url>
    <content><![CDATA[<h2 id="从promise、process-nextTick、setTimeout出发，谈谈Event-Loop中的Job-queue"><a href="#从promise、process-nextTick、setTimeout出发，谈谈Event-Loop中的Job-queue" class="headerlink" title="从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue"></a>从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue</h2><p>原文连接：从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue</p>
<h3 id="问题的引出"><a href="#问题的引出" class="headerlink" title="问题的引出"></a>问题的引出</h3><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如<br>例1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出2,1</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>
<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>
<p>例2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出为  1  2 3</span></span><br></pre></td></tr></table></figure>
<p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>
<h3 id="Job-queue中的执行顺序"><a href="#Job-queue中的执行顺序" class="headerlink" title="Job queue中的执行顺序"></a>Job queue中的执行顺序</h3><p>在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设</p>
<ul>
<li>macro-task队列包含任务: a1, a2 , a3</li>
<li>micro-task队列包含任务: b1, b2 , b3</li>
</ul>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 a1 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行b1, b2 , b3，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。<br>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">macro</span><span class="title">-</span></span>task队列真实包含任务：</span><br><span class="line"></span><br><span class="line">script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</span><br><span class="line"></span><br><span class="line">micro-task队列真实包含任务：</span><br><span class="line">process.nextTick, Promises, Object.observe, MutationObserver</span><br></pre></td></tr></table></figure>
<p>由此我们得到的执行顺序应该为：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">script<span class="params">(主程序代码)</span>—&gt;process.nextTick—&gt;Promises…——&gt;<span class="keyword">set</span>Timeout——&gt;<span class="keyword">set</span>Interval——&gt;<span class="keyword">set</span>Immediate——&gt; I/O——&gt;UI rendering</span><br></pre></td></tr></table></figure>
<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>
<h4 id="真实环境中执行顺序的举例"><a href="#真实环境中执行顺序的举例" class="headerlink" title="真实环境中执行顺序的举例"></a>真实环境中执行顺序的举例</h4><p>(1) setTimeout和promise<br>例3:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>我们先以第1小节的例子为例，这里遵循的顺序为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">script(主程序代码)——&gt;promise——&gt;setTimeout</span><br><span class="line">对应的输出依次为：<span class="number">1</span> ——&gt;<span class="number">2</span>————&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>(2) process.nextTick和promise、setTimeout<br>例子4：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">   resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//输出2,6,5,3,4,1</span></span><br></pre></td></tr></table></figure>
<p>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>
<p>首先分析Job queue的执行顺序：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">script</span><span class="params">(主程序代码)</span></span>——&gt;process.nextTick——&gt;promise——&gt;setTimeout</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主体部分： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</p>
</li>
<li><p>process.nextTick: 输出5</p>
</li>
<li><p>promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4</p>
</li>
<li><p>setTimeout ： 最后输出1</p>
</li>
</ul>
<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>
<p>(3)更复杂的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;resolve()&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出的是  2 6 5 1 3 4</span></span><br></pre></td></tr></table></figure>
<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>浏览器event-loop</tag>
      </tags>
  </entry>
  <entry>
    <title>js零散笔记04--实现继承的方法及优缺点总结</title>
    <url>/2019/04/01/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<p>#JavaScript实现继承的方法及优缺点总结<br>本文内容参考《JavaScript高级程序设计》第三版</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<a id="more"></a>

<p>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<h3 id="原型继承："><a href="#原型继承：" class="headerlink" title="原型继承："></a>原型继承：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Super = functioin(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super(<span class="string">'eric'</span>);  <span class="comment">//通过改变原型对象实现继承</span></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub(<span class="string">'male'</span>)</span><br><span class="line">     sub2 = <span class="keyword">new</span> Sub(<span class="string">'female'</span>);</span><br><span class="line"></span><br><span class="line">sub1.setName(<span class="string">'ada'</span>);</span><br><span class="line"><span class="comment">// 这里必须通过setName方法来修改继承来的name属性。</span></span><br><span class="line"><span class="comment">// 如果通过sub1.name== 'ada',就打不到目的，因为此时sub1对象上没有name属性，</span></span><br><span class="line"><span class="comment">// 这样等于为该对象添加了新的属性，而不是修改继承而来的name属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// ada,可见此sub2的name也会被修改掉</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1.getName === sub2.getName) <span class="comment">// true,复用了方法</span></span><br></pre></td></tr></table></figure>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。<br>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。</p>
<p>总结：原型链的优点是父类的方法得到了复用；缺点是父类的属性得到了复用从而使得子类实例不能有自己的属性。这是由于原型链的共享性造成的，这样的话，一个子类实例改变属性，那么其他子类实例也会改变相应的属性。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在子类型构造函数的内部调用超类型构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
<p>通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。</p>
<h4 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h4><p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式</p>
<p>总结:优点：子类的每个实例都有自己的属性（name），不会相互影响。<br>缺点：但是继承父类方法的时候就不需要这种特性，没有实现父类方法的复用。</p>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//继承属性</span></span><br><span class="line"> SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();   <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge();   <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName();   <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge();   <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf也能够用于识别基于组合继承创建的对象。</p>
<p>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部.</p>
<p>总结:优点：继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性。<br>缺点：因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="keyword">clone</span> = Object.create(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line"> <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;   <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">  console.log(<span class="string">"hi"</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">clone</span>;     <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给object()函数，将返回的结果赋值给clone。再为clone对象添加一个新方法sayHi()，最后返回clone对象。可以像下面这样来使用createAnother()函数：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> person = &#123;</span><br><span class="line"> <span class="built_in">na</span><span class="symbol">me:</span> <span class="string">"Nicholas"</span>,</span><br><span class="line"> frien<span class="symbol">ds:</span> [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); //<span class="string">"hi"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法</p>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Super,</span><br><span class="line">    getName(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex,name</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合继承的缺点就是在继承父类方法的时候调用了父类构造函数，从而造成内存浪费，现在只要解决了这个问题就完美了。那在复用父类方法的时候，使用Object.create方法也可以达到目的，没有调用父类构造函数，问题解决。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="keyword">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">Sub</span>;</span></span><br></pre></td></tr></table></figure>
<p>再看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line"> SuperType.call(<span class="keyword">this</span>, name);   <span class="comment">//第二次调用SuperType()</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors,于是，这两个属性就屏蔽了原型中的两个同名属性</p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">inherit</span><span class="constructor">Prototype(<span class="params">subType</span>, <span class="params">superType</span>)</span>&#123;</span><br><span class="line"> var prototype = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>create(superType.prototype);  <span class="comment">//创建对象</span></span><br><span class="line"> prototype.constructor = subType;     <span class="comment">//增强对象</span></span><br><span class="line"> subType.prototype = prototype;      <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line"> SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h3 id="es6中的class"><a href="#es6中的class" class="headerlink" title="es6中的class"></a>es6中的class</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    constructor(props = &#123; name: <span class="symbol">'eri</span>c' &#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = props.name;</span><br><span class="line">    &#125;</span><br><span class="line">    setName(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props = &#123; sex: <span class="symbol">'mal</span>e' &#125;); <span class="comment">// 创建实例，继承父类属性和方法</span></span><br><span class="line">        <span class="keyword">this</span>.sex = props.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let sub1 = <span class="keyword">new</span> <span class="type">Sub</span>(&#123;</span><br><span class="line">    name: <span class="symbol">'eri</span>c',</span><br><span class="line">    sex: <span class="symbol">'mal</span>e'</span><br><span class="line">&#125;)</span><br><span class="line">let sub2 = <span class="keyword">new</span> <span class="type">Sub</span>(&#123;</span><br><span class="line">    name: <span class="symbol">'eri</span>c',</span><br><span class="line">    sex: <span class="symbol">'femal</span>e'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>js零散笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>js零散笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器03--Repaint和Reflow</title>
    <url>/2019/03/30/%E6%B5%8F%E8%A7%88%E5%99%A803/</url>
    <content><![CDATA[<h1 id="Repaint和Reflow"><a href="#Repaint和Reflow" class="headerlink" title="Repaint和Reflow"></a>Repaint和Reflow</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>浏览器解析大概的工作流程：</p>
<ul>
<li>解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。</li>
<li>构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式），根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树。</li>
<li>布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。</li>
<li>绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。<br>可以看到Repain 和 Reflow 分别出现在了第三和第四步。定义为如下：<a id="more"></a>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为<span class="built_in">ref</span>low；当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。</span><br><span class="line">可见这两个东东对浏览器渲染页面是很重要的啊，都是会影响性能的，因此我们需要了解一些常见的会引起repaint和<span class="built_in">ref</span>low的一些操作，并且应该尽量减少以提高渲染速度。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="引起原因"><a href="#引起原因" class="headerlink" title="引起原因"></a>引起原因</h3><p>Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。</p>
<h3 id="Repaint"><a href="#Repaint" class="headerlink" title="Repaint"></a>Repaint</h3><p>repaint一般在改变 DOM 元素的视觉效果时触发，即不涉及任何排版布局的问题时触发，它主要针对的是某一dom元素的重新绘制。当一个元素的外观的可见性visibility发生改变的时候，重绘(repaint)也随之发生，但是不影响布局。类似的例子包括：<code>outline, visibility, or background color</code>。一般触发repaint的常见场景有以下几个：</p>
<ul>
<li>color的修改，如color=#ddd； </li>
<li>text-align的修改，如 text-align：center；</li>
<li>a:hover也会造成重绘； </li>
<li>:hover引起的颜色等不导致页面回流的style变动；<br>等等。</li>
</ul>
<h3 id="Reflow"><a href="#Reflow" class="headerlink" title="Reflow"></a>Reflow</h3><p>reflow回流是在某一个 DOM 元素的位置发生改变后触发，而且它会重新计算所有dom元素的位置和在页面中的占有的面积，所以一般来说，reflow的影响比repaint要大得多，它将会影响它所有的children、ancestors及siblings。所以影响是针对整个页面的，整个页面都需要重新渲染。一般触发reflow的常见场景有以下几个：</p>
<ul>
<li>使用JS改变DOM元素时会触发reflow，即添加(appendChild)、删除(removeChild)DOM元素或者改变DOM元素的可见性(display:none)</li>
<li>CSS中width/height/border/margin/padding的修改，如width=778px；</li>
<li>CSS3 动画(animation)和过渡(transition)，动画的每一frame都会触发reflow；</li>
<li>读取元素的某些属性(offsetLeft/Top、offsetHeight/Width、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))时会触发reflow，因为这些属性需要依赖一些元素去计算；</li>
<li>:hover等伪类引起的元素表现改动造成页面回流；</li>
<li>scroll页面，这个不可避免；</li>
<li>字体大小改变或更换字体 (font)；</li>
<li>resize页面，桌面版本的进行浏览器大小的缩放；等等。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>如果想设定元素的样式，通过改变元素的 class 名 (尽可能在 DOM 树的最末端)（Change classes on the element you wish - to style (as low in the dom tree as possible)）</p>
</li>
<li><p>避免设置多项内联样式（Avoid setting multiple inline styles）</p>
</li>
<li><p>应用元素的动画，使用 position 属性的 fixed 值或 absolute 值（Apply animations to elements that are position fixed or absolute）</p>
</li>
<li><p>权衡平滑和速度（Trade smoothness for speed）</p>
</li>
<li><p>避免使用table布局（Avoid tables for layout）</p>
</li>
<li><p>避免使用CSS的JavaScript表达式 (仅 IE 浏览器)（Avoid JavaScript expressions in the CSS (IE only)）</p>
</li>
<li><p>尽可能在DOM树的最末端改变class</p>
</li>
<li><p>回流可以自上而下，或自下而上的回流的信息传递给周围的节点。回流是不可避免的，但可以减少其影响。尽可能在DOM树的里面改变class，可以限制了回流的范围，使其影响尽可能少的节点。例如，你应该避免通过改变对包装元素类去影响子节点的显示。面向对象的CSS始终尝试获得它们影响的类对象（DOM节点或节点），但在这种情况下，它已尽可能的减少了回流的影响，增加性能优势。</p>
</li>
<li><p>尽量采取批量更新元素样式的方式，比如可以将需要修改的样式集合放在一个class里，将这个class附给元素。</p>
</li>
<li><p>避免设置多层内联样式<br>我们都知道与DOM交互很慢。我们尝试在一种无形的DOM树片段组进行更改，然后整个改变应用到DOM上时仅导致了一个回流。同样，通过style属性设置样式导致回流。避免设置多级内联样式，因为每个都会造成回流，样式应该合并在一个外部类，这样当该元素的class属性可被操控时仅会产生一个reflow。</p>
</li>
<li><p>尽可能的减少DOM元素相互影响<br>减少DOM的层级，减少DOM的数量，DOM数量越少越好，慎改class！！去改子元素少的DOM的class</p>
</li>
<li><p>动画效果应用到position属性为absolute或fixed的元素上<br>动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。删除复杂动画，尽量给动画元素设置position:fixed/absolute，使动画元素从DOM流中独立出来，从而减少对其他元素的影响。</p>
</li>
<li><p>牺牲平滑度换取速度<br>Opera还建议我们牺牲平滑度换取速度，其意思是指可能想每次1像素移动一个动画，但是如果此动画及随后的回流使用了100%的CPU，动画就会看上去是跳动的，因为浏览器正在与更新回流做斗争。动画元素每次移动3像素可能在非常快的机器上看起来平滑度低了，但它不会导致CPU在较慢的机器和移动设备中抖动。尽量牺牲平滑度去满足性能，因为动画精度太强，会造成更多次的repaint/reflow</p>
</li>
<li><p>避免使用table布局<br>table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow.<br>避免使用table布局。可能您需要其它些避免使用table的理由，在布局完全建立之前，table经常需要多个关口，因为table是个和罕见的可以影响在它们之前已经进入的DOM元素的显示的元素。想象一下，因为表格最后一个单元格的内容过宽而导致纵列大小完全改变。然而有另外一个原因为什么表格布局是很糟糕的主意，根据Mozilla，即使一些小的变化将导致表格(table)中的所有其他节点回流。<br>Jenny Donnelly, YUI 数据表格 widget的所有者，建议使用数据表格的固定布局以便更有效的布局算法，任何表格-布局的值除了”auto”将引发一个固定布局，根据CSS2.1规范，这将允许表格一行一行的呈递。Quirksmode显示，大部分的浏览器对表格布局属性支持良好。</p>
</li>
<li><p>避免使用CSS的JavaScript表达式<br>这项规则较过时，但确实是个好的主意。主要的原因，这些表现是如此昂贵，是因为他们每次重新计算文档，或部分文档、回流。正如我们从所有的很多事情看到的：引发回流，它可以每秒产生成千上万次。当心！</p>
</li>
<li><p>尽量简写CSS样式<br>可以把许多样式合在一起的就应该把他们合在一起避免重新重复使用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>浏览器前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器02--CSRF和XSS网络攻击和防范</title>
    <url>/2019/03/29/%E6%B5%8F%E8%A7%88%E5%99%A802/</url>
    <content><![CDATA[<h1 id="浏览器笔记————CSRF和XSS网络攻击和防范"><a href="#浏览器笔记————CSRF和XSS网络攻击和防范" class="headerlink" title="浏览器笔记————CSRF和XSS网络攻击和防范"></a>浏览器笔记————CSRF和XSS网络攻击和防范</h1><p>根据网上的资料做了一些补充和修改，以下是原文链接：<br>原文链接：<a href="https://blog.csdn.net/zl834205311/article/details/81773511" target="_blank" rel="noopener">https://blog.csdn.net/zl834205311/article/details/81773511</a></p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，恶意攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。比如获取用户的 Cookie、导航到恶意网站、携带木马等。借助安全圈里面非常有名的一句话：所有的输入都是有害的。<br>大部分的 XSS 漏洞都是由于没有处理好用户的输入，导致恶意脚本在浏览器中执行。任何输入提交数据的地方都有可能存在 XSS。</p>
<a id="more"></a>
<h3 id="XSS-攻击分类"><a href="#XSS-攻击分类" class="headerlink" title="XSS 攻击分类"></a>XSS 攻击分类</h3><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型输入一些数据但是不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中。<br>用户在页面输入框中输入数据，通过 get 或者 post 方法向服务器端传递数据，输入的数据一般是放在 URL 的 query string 中，或者是 form 表单中，如果服务端没有对这些数据进行过滤、验证或者编码，直接将用户输入的数据呈现出来，就可能会造成反射型 XSS。反射型 XSS 是非常普遍的，其危害程度通常较小，但是某些反射型 XSS 还是会造成严重后果的。<br>黑客通常通过构造一个包含 XSS 代码的 URL，诱导用户点击链接，触发 XSS 代码，达到劫持访问、获取 cookies 的目的。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型是攻击者输入一些数据并且存储到了数据库中。<br>通常是因为服务器端将用户输入的恶意脚本没有经过验证就存储在数据库中，并且通过调用数据库的方式，将数据呈现在浏览器上，当页面被用户打开的时候执行，每当用户打开浏览器，恶意脚本就会执行。存储型的 XSS 攻击相比非存储型的危害性更大，因为每当用户打开页面，恶意脚本都会执行。<br>例如一个评论功能，在提交评论的表单里面：<code>&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;评论内容&quot; &gt;</code><br>正常情况下，用户填入评论内容提交，服务端将评论内容保存到数据库，其他用户查看评论时，从后台提供的接口中取出数据展示。非正常情况下，恶意攻击者在 value 中填写恶意代码：<code>&lt;img src=&#39;&#39; onerror=&#39;alert(/攻击脚本/)&#39; /&gt;</code><br>后台保存到数据库中，其他用户查看评论的时候就会执行这些恶意攻击代码。</p>
<h4 id="DOM-型-DOM-Based-XSS"><a href="#DOM-型-DOM-Based-XSS" class="headerlink" title="DOM 型( DOM Based XSS )"></a>DOM 型( DOM Based XSS )</h4><p>DOM 是一个树形结构，我们可以通过写 js 代码来修改节点，对象和值。DOM XSS 简单理解就是它的输出点在 DOM 。XSS 代码可能是插入简单的<code>&lt;script src=&quot;https://test.com/haker.js&quot;&gt;</code><br>载入第三方的恶意脚本，这些恶意脚本，通常是读取用户的 cookie 。</p>
<h3 id="XSS-常见攻击方法"><a href="#XSS-常见攻击方法" class="headerlink" title="XSS 常见攻击方法"></a>XSS 常见攻击方法</h3><p>1、绕过 XSS-Filter，利用 &lt;&gt; 标签注入 Html/JavaScript 代码；</p>
<p>2、利用 HTML 标签的属性值进行 XSS 攻击。例如：<code>&lt;img src=“javascript:alert(‘xss’)”/&gt;；</code><br>当然并不是所有的 Web 浏览器都支持 Javascript 伪协议，所以此类 XSS 攻击具有一定的局限性</p>
<p>3、空格、回车和 Tab。如果 XSS Filter 仅仅将敏感的输入字符列入黑名单，比如 javascript，用户可以利用空格、回车和 Tab 键来绕过过滤，例如：<code>&lt;img src=“javas cript:alert(/xss/);”/&gt;；</code><br>4、利用事件来执行跨站脚本。例如：<code>&lt;img src=“#” onerror= “alert(1)”/&gt;；</code><br>当 src 错误的视乎就会执行 onerror 事件；<br>5、利用 CSS 跨站。例如：<code>body {backgrund-image: url(“javascript:alert(‘xss’)”)}</code>；<br>6、扰乱过滤规则。例如：<code>&lt;IMG SRC=“javaSCript: alert(/xss/);”/&gt;</code>；<br>7、利用字符编码，通过这种技巧，不仅能让 XSS 代码绕过服务端的过滤，还能更好地隐藏 Shellcode；（ JS 支持 unicode、eacapes、十六进制、十进制等编码形式）；<br>8、拆分跨站法，将 XSS 攻击的代码拆分开来，适用于应用程序没有过滤 XSS 关键字符（如&lt;、&gt;）却对输入字符长度有限制的情况下；<br>9、DOM 型的 XSS 主要是由客户端的脚本通过 DOM 动态地输出数据到页面上，它不依赖于提交数据到服务器，而是从客户端获得DOM中的数据在本地执行。容易导致 DOM 型的 XSS 的输入源包括：<code>Document.URL、Location(.pathname|.href|.search|.hash)、Document.referrer、Window.name、Document.cookie、localStorage/globalStorage；</code></p>
<h3 id="XSS防御方法"><a href="#XSS防御方法" class="headerlink" title="XSS防御方法"></a>XSS防御方法</h3><p>XSS 漏洞是由于对用户提交的数据没有经过严格的过滤处理造成的，所以防御的原则就是不相信用户输入的数据，对输入进行过滤，对输出进行编码。防御的话大致分为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤。</p>
<h4 id="使用-XSS-Filter"><a href="#使用-XSS-Filter" class="headerlink" title="使用 XSS Filter"></a>使用 XSS Filter</h4><p>针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容。比如：</p>
<p>表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等。<br>过滤或移除特殊的 html 标签：&lt;\script&gt;、&lt;\iframe&gt;等。<br>过滤 js 事件的标签：onclick、onerror、onfocus等。</p>
<h4 id="html-实体"><a href="#html-实体" class="headerlink" title="html 实体"></a>html 实体</h4><p>当需要往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码，在 html 中有些字符对于 HTML 来说是具有特殊意义的，所以这些特殊字符不允许在文本中直接使用，需要使用实体字符。 html 实体的存在是导致 XSS 漏洞的主要愿意之一，因此我们需要将实体转化为相应的实体编号。</p>
<p>显示结果    描述    实体编号</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">空格	  ;</span><br><span class="line">&lt;	小于	&lt; ;</span><br><span class="line">&gt;	大于	&gt; ;</span><br><span class="line"><span class="meta">&amp;	和/td&gt;	&amp; ;</span></span><br><span class="line">''	引号	<span class="string">" ;</span></span><br></pre></td></tr></table></figure>
<h4 id="JavaScript编码"><a href="#JavaScript编码" class="headerlink" title="JavaScript编码"></a>JavaScript编码</h4><p>这条原则主要针对动态生成的JavaScript代码，这包括脚本部分以及HTML标签的事件处理属性（如onerror, onload等）。在往JavaScript代码里插入数据的时候，只有一种情况是安全的，那就是对不可信数据进行JavaScript编码，并且只把这些数据放到使用引号包围起来的值部分（data value）之中，除了上面的那些转义之外，还要附加上下面的转义：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\</span> 转成 <span class="string">\\</span></span><br><span class="line">/ 转成 <span class="string">\/</span></span><br><span class="line">; 转成 ；(全角;)</span><br></pre></td></tr></table></figure>
<p>注意：在对不可信数据做编码的时候，不能图方便使用反斜杠\ 对特殊字符进行简单转义，比如将双引号 ”转义成 \”，这样做是不可靠的，因为浏览器在对页面做解析的时候，会先进行HTML解析，然后才是JavaScript解析，所以双引号很可能会被当做HTML字符进行HTML解析，这时双引号就可以突破代码的值部分，使得攻击者可以继续进行XSS攻击；另外，输出的变量的时候，变量值必须在引号内部，避免安全问题；更加严格的方式，对除了数字和字母以外的所有字符，使用十六进制\xhh 的方式进行编码。</p>
<h4 id="Http-Only-cookie"><a href="#Http-Only-cookie" class="headerlink" title="Http Only cookie"></a>Http Only cookie</h4><p>许多 XSS 攻击的目的就是为了获取用户的 cookie，将重要的 cookie 标记为 http only，这样的话当浏览器向服务端发起请求时就会带上 cookie 字段，但是在脚本中却不能访问 cookie，这样就避免了 XSS 攻击利用 js 的 document.cookie获取 cookie。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库.<br>CSRF攻击攻击原理及过程如下：</p>
<p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；<br>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；<br>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。<br>CSRF攻击实例</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">受害者 <span class="keyword">Bob </span>在银行有一笔存款，通过对银行的网站发送请求 http://<span class="keyword">bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 </span>可以使 <span class="keyword">Bob </span>把 <span class="number">1000000</span> 的存款转到 <span class="keyword">bob2 </span>的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 <span class="keyword">Bob </span>已经成功登陆。</span><br><span class="line"></span><br><span class="line">黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://<span class="keyword">bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 </span>Mallory 而非 <span class="keyword">Bob，他不能通过安全认证，因此该请求不会起作用。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">这时，Mallory </span>想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://<span class="keyword">bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory </span>”，并且通过广告等诱使 <span class="keyword">Bob </span>来访问他的网站。当 <span class="keyword">Bob </span>访问该网站时，上述 url 就会从 <span class="keyword">Bob </span>的浏览器发向银行，而这个请求会附带 <span class="keyword">Bob </span>浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 <span class="keyword">Bob </span>的认证信息。但是，如果 <span class="keyword">Bob </span>当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 <span class="keyword">Bob </span>的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 <span class="keyword">Bob </span>的账号转移到 Mallory 的账号，而 <span class="keyword">Bob </span>当时毫不知情。等以后 <span class="keyword">Bob </span>发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</span><br></pre></td></tr></table></figure>
<h3 id="CSRF漏洞检测："><a href="#CSRF漏洞检测：" class="headerlink" title="CSRF漏洞检测："></a>CSRF漏洞检测：</h3><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。<br>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。<br>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p>
<h3 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h3><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。(防御方式：使用验证码，检查https头部的refer，使用token)</p>
<p><b>(1)验证 HTTP Referer 字段</b></p>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。<br>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p><b>（2）在请求地址中添加 token 并验证</b><br>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上<br>”tokenvalue”/<br>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p><b>（3）在 HTTP 头中自定义属性并验证</b></p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>浏览器前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器01--前端优化</title>
    <url>/2019/03/28/%E6%B5%8F%E8%A7%88%E5%99%A801/</url>
    <content><![CDATA[<h1 id="浏览器笔记————前端优化"><a href="#浏览器笔记————前端优化" class="headerlink" title="浏览器笔记————前端优化"></a>浏览器笔记————前端优化</h1><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><p>前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，前端优化的目的是什么 ?</p>
<p>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。<br>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。<br>　　总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</p>
<a id="more"></a>
<h3 id="页面级优化"><a href="#页面级优化" class="headerlink" title="页面级优化"></a>页面级优化</h3><p><b>减少 HTTP请求数</b><br>首先，每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的 (具体参见此处 )，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。<br>减少 HTTP请求数的主要途径包括：</p>
<ul>
<li>从设计实现层面简化页面</li>
<li>合理设置 HTTP缓存</li>
<li>资源合并与压缩</li>
<li>CSS Sprites</li>
<li>Inline Images</li>
<li>Lazy Load Images</li>
</ul>
<p><b>从设计实现层面简化页面</b><br>如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。<br><b> 合理设置 HTTP缓存</b><br>缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。<br>怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。<br>缓存可以通过以下几个方面来考虑：</p>
<ul>
<li>DNS缓存</li>
<li>CDN部署与缓存</li>
<li>http缓存<br>由于浏览器会在DNS解析步骤中消耗一定的时间，所以，对于一些高访问量网站来说，做好DNS的缓存工作，就会一定程度上提升网站效率。CDN缓存，CDN作为静态资源文件的分发网络，本身就已经提升了，网站静态资源的获取速度，加快网站的加载速度，同时也给静态资源做好缓存工作，有效的利用已缓存的静态资源，加快获取速度。http缓存，也是给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复的下载，从而提升整体网页的加载速度。<br><b>资源合并与压缩</b><br>如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。 包括以下几个方面：</li>
<li>gzip压缩</li>
<li>js混淆</li>
<li>css压缩</li>
<li>图片压缩<br>gzip压缩主要是针对html文件来说的，它可以将html中重复的部分进行一个打包，多次复用的过程。js的混淆可以有简单的压缩(将空白字符删除)、丑化(丑化的方法，就是将一些变量缩小)、或者可以使用php对js进行混淆加密。css压缩，就是进行简单的压缩。图片的压缩，主要也是减小体积，在不影响观感的前提下，尽量压缩图片，使用png等图片格式，减少矢量图、高清图等的使用。这样子的做法不仅可以加快网页显示，也能减少流量的损耗。<br><b>CSS Sprites</b><br>合并 CSS图片，减少请求数的又一个好办法。<br><b> Inline Images</b><br>使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。<br><b>Lazy Load Images</b><br>这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。</li>
</ul>
<h3 id="将外部脚本置底（将脚本内容在页面信息内容加载后再加载）"><a href="#将外部脚本置底（将脚本内容在页面信息内容加载后再加载）" class="headerlink" title="将外部脚本置底（将脚本内容在页面信息内容加载后再加载）"></a>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</h3><p>浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。<br>常见的图片懒加载的方式就是：在最初给图片的src设置一个比较简单的图片，然后将图片的真实地址设置给自定义的属性，做一个占位，然后给图片设置监听事件，一旦图片到达视口范围，从图片的自定义属性中获取出真是地址，然后赋值给src，让其进行加载。</p>
<p>Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）<br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。</p>
<h3 id="将-CSS放在-HEAD中"><a href="#将-CSS放在-HEAD中" class="headerlink" title="将 CSS放在 HEAD中"></a>将 CSS放在 HEAD中</h3><p>如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。</p>
<h3 id="异步请求-Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）"><a href="#异步请求-Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）" class="headerlink" title="异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）"></a>异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</h3><p>在某些页面中可能存在这样一种需求，需要使用 script标签来异步的请求数据。可以考虑在 DOMLoaded事件触发的时候加载，或者使用 setTimeout方式来灵活的控制加载的时机。</p>
<h3 id="减少不必要的-HTTP跳转"><a href="#减少不必要的-HTTP跳转" class="headerlink" title="减少不必要的 HTTP跳转"></a>减少不必要的 HTTP跳转</h3><p>对于以目录形式访问的 HTTP链接，很多人都会忽略链接最后是否带 ’/‘，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了 301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无 ’/‘结尾的方式访问的，于是服务器有了一次跳转。</p>
<h3 id="避免重复的资源请求"><a href="#避免重复的资源请求" class="headerlink" title="避免重复的资源请求"></a>避免重复的资源请求</h3><p>这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求。</p>
<h2 id="移动端优化"><a href="#移动端优化" class="headerlink" title="移动端优化"></a>移动端优化</h2><ul>
<li>使用长cache，减少重定向</li>
<li>首屏优化，保证首屏加载数据小于14kb</li>
<li>不滥用web字体</li>
<li>使用长cache，可以使得移动端的部分资源设定长期缓存，这样可以保证资源不用向服务器发送请求，来比较资源是否更新，从而避免304的情况。304重定向，在PC端或许并不会影响网页的加载速度，但是，在移动端网络不稳定的前提下，多一次请求，就多了一部分加载时间。 首屏优化，对于移动端来说是至关重要的。2s时间是用户的最佳体验，一旦超出这个时间，将会导致用户的流失。所以，针对移动端的网络情况，不可能在这么短时间内加载完成所有的网页资源，所以我们必须保证首屏中的内容被优先显示出来，而且基于TCP的慢启动和拥塞控制，第一个14kb的数据是非常重要的，所以需要保证首部加载数据能够小于14kb。 不滥用web字体，web字体的好处就是，可以代替某些图片资源，但是，在移动端过多的web字体的使用，会导致页面资源加载的繁重，所以，慎用web字体。</li>
<li>代码级优化<br><b>Javascript</b><br><b> DOM</b><br>DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点：</li>
</ul>
<p>HTML Collection（HTML收集器，返回的是一个数组内容信息） 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。 因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。<br>Reflow &amp; Repaint DOM操作还需要考虑浏览器的 Reflow和Repaint ，因为这些都是需要消耗资源的.具体参考我的<br><b> 慎用 with</b><br>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。<br>因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</p>
<p><b> 避免使用 eval和 Function</b><br>每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。<br>eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。<br>Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。<br>此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p>
<p><b>减少作用域链查找（这方面设计到一些内容的相关问题）</b><br>这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。<br>低效率的写法：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量 </span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span><span class="params">(info)</span></span>&#123; </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">100000</span>; i--;)&#123; </span><br><span class="line"><span class="comment">//每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 </span></span><br><span class="line">globalVar += i; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更高效的写法：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span><span class="params">(info)</span></span>&#123;</span><br><span class="line"><span class="comment">//局部变量缓存全局变量</span></span><br><span class="line"><span class="keyword">var</span> localVar = globalVar;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">100000</span>; i–;)&#123;</span><br><span class="line"><span class="comment">//访问局部变量是最快的</span></span><br><span class="line">localVar += i;</span><br><span class="line">&#125; <span class="comment">//本例中只需要访问 2次全局变量，在函数中只需要将 globalVar中内容的值赋给localVar 中区</span></span><br><span class="line">globalVar = localVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，要减少作用域链查找还应该减少闭包的使用。</p>
<p><b>数据访问</b><br>Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：<br>a. 对任何对象属性的访问超过 1次<br>b. 对任何数组成员的访问次数超过 1次<br>另外，还应当尽可能的减少对对象以及数组深度查找。<br><b> 字符串拼接</b><br>在 Javascript中使用”+” 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。</p>
<h3 id="CSS选择符"><a href="#CSS选择符" class="headerlink" title="CSS选择符"></a>CSS选择符</h3><p>在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如<br>\ #toc A { color: #444; }<br>这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项，有人已经一一列举了。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>对 HTML本身的优化，比如标签的结构化，减少不必要的div标签。</p>
<h3 id="Image压缩"><a href="#Image压缩" class="headerlink" title="Image压缩"></a>Image压缩</h3><p>图片压缩是个技术活，不过现如今这方面的工具也非常多，压缩之后往往能带来不错的效果。</p>
<h3 id="移动端优化-1"><a href="#移动端优化-1" class="headerlink" title="移动端优化"></a>移动端优化</h3><ul>
<li>长列表滚动优化</li>
<li>函数防抖和函数节流</li>
<li>使用touchstart、touchend代替click</li>
<li>HTML的viewport设置</li>
<li>开启GPU渲染加速</li></ul>
首先，长列表滚动问题，是移动端需要面对的，IOS尽量使用局部滚动，android尽量使用全局滚动。同时，需要给body添加上-webkit-overflow-scrolling: touch来优化移动段的滚动。
防抖和节流，设计到滚动等会被频繁触发的DOM事件，需要做好防抖和节流的工作。它们都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
touchstart、touchend代替click，也是移动端比较常用的操作。click在移动端会有300ms延时，这应该是一个常识呗。这种方法会影响用户的体验。所以做优化时，最简单的方法就是使用touchstart或者touchend代替click。因为它们事件执行顺序是touchstart->touchmove->touchend->click。或者，使用fastclick或者zepto的tap事件代替click事件。
HTML的viewport设置，可以防止页面的缩放，来优化性能。
开启GPU渲染加速，但是这里的GPU不能和CPU混为一谈。GPU的全名是Graphics Processing Unit，是一种硬件加速方式。一般的css渲染，浏览器的渲染引擎都不会使用到它。但是，在3D渲染时，计算量较大，繁重，浏览器会开启显卡的硬件加速来帮助完成这些操作。所以，我们这里可以使用css中的translateZ设定，来欺骗浏览器，让其帮忙开启GPU加速，加快渲染进程。

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="图片预加载和加载时进度条显示"><a href="#图片预加载和加载时进度条显示" class="headerlink" title="图片预加载和加载时进度条显示"></a>图片预加载和加载时进度条显示</h3><p>图片预加载，预加载的寓意就是提前加载内容。而图片的预加载往往会被用在图片资源比较大，即时加载时会导致很长的等待过程时，才会被使用的。常见场景：图片漫画展示时。往往会预加载一张到两张的图片。<br>首屏进度条的显示，往往对于首屏优化后的数据量并不满意的话，同时也不能进一步缩短首屏包的长度了，就可以使用进度条的方式，来提醒用户进行等待。</p>
<h3 id="异步请求的优化"><a href="#异步请求的优化" class="headerlink" title="异步请求的优化"></a>异步请求的优化</h3><ul>
<li>使用正常的json数据格式进行交互</li>
<li>部分常用数据的缓存</li>
<li>数据埋点和统计</li></ul>
JSON交互，JSON的数据格式轻巧，结构简单，往往可以大大优化前后端的数据通信。
常用数据的缓存，可以将一些用户的基本信息等常用的信息做一个缓存，这样可以保证ajax请求的减少。同时，HTML5新增的storage的内容，也不用怕cookie暴露，引起的信息泄漏问题。
数据埋点和统计，对于资深的程序员来说，比较了解。而且目前的大部分公司也会做这方面的处理。

]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>浏览器前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--零散总结</title>
    <url>/2019/03/27/nodejs07/</url>
    <content><![CDATA[<h1 id="Node-js笔记-七-————零散总结"><a href="#Node-js笔记-七-————零散总结" class="headerlink" title="Node.js笔记(七)————零散总结"></a>Node.js笔记(七)————零散总结</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>net模块包含了Node需要的所有TCP功能。用net.createServer（）方法创建一个新的TCP服务端。<br>Express模块是合同谈判模块的扩展。Express、net、http都是用Server（）创建服务器，并用listen（）来监听指定窗口。<br>Express会在后台调用http模块，Express增加了亮相http模块没有的功能：根据HTTP请求的不同方法进行过滤；根据特定的URL进行过滤。</p>
<p>采用HTTP模块时，需要创建HTTP头，res.writeHead，并且在发送请求内容之前把HTTP头先发送给客户端。Express提供了一个方便的方法，res.（http：response）对象的send（）方法。此方法发送HTTP头，同时还会调用response.end（）方法。如果给res.send（）传递一个对象，它会自动把其序列化为JSON并添加对应的HTTP头。</p>
<a id="more"></a>
<p>  http模块并非只包含了HTTP服务端的功能，它同时还提供了客户端的功能。用http.request（）工厂方法来创建新的http请求对象。接受两个参数：第一个参数是config对象，第二个参数是回调函数。回调函数是监听在http.request的response事件上的。在Express服务器中，我们用了express.bodyDecoder来处理请求数据流中所有的内容，但在客户端我们只能手动处理流数据。只有当我们把服务器返回的数据接收完整后，end事件才会被触发。</p>
<p>Node是单线程的，但是CPU处理器是多核处理器，我们可以利用cluster模块把任务分配给子进程，就是说Node把当前程序复制了一份给另一个进程。当用cluster把工作共享到一组复制的Node程序时，主进程不会参与到每个具体的事务中。主进程管理所有的子进程，但当子进程与I/O交互时，它是直接进行操作的，不需要通过主进程。如果用cluster来创建一个Web服务器，请求将不会通过主进程，而是直接连接到子进程。cluster的工作原理是每一个Node进程要么是主进程，要么是工作进程。cluster提供了跨平台时让多个进程共享socket的方法。即使多个子进程在共享一个端口上的连接，其中一个堵塞了，也不hi影响其他工作进程的新连接。</p>
<p>因为EventEmitter是接口，从其继承的类需要使用new关键字来构造。</p>
<p>HTTP服务器中，connection和close时间表示了与客户端的TCP连接与关闭。request、checkContinue、upgrade和clientError事件是关联在HTTP请求上的。每个流指挥触发connection时间一次。</p>
<p>在HTTP客户端，应该使用http.ClientRequest类。需要配置（options）对象来创建一个http.ClientRequest实例，就是调用http.request（）这个工厂方法，并传入options对象和回调函数。</p>
<p>http.get可以和http.request（）做同样的事情（GET请求），但是在request中我们把method属性从配置中去掉了，还把request.end（）也移除了。</p>
<p>每当调用ClientRequest.write（）时，数据会马上上传（不会被缓存），但服务器在ClientRequest.end（）调用之前是不会响应数据请求的。</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL模块提供了3个方法：parse（解析）、format、resolve。</p>
<p>querystring模块是用来处理query字符串的简单辅助模块。它的主要功能有parse和decode。如果有一个query字符串，可以用parse把它转换成对象。需注意：数字是返回成字符串的，并非数字类型；传入的query字符串不能包含URL中标记的？。</p>
<p>querystring也被URL模块用作辅助模块。特别是在解析YRL时候可以指定URL模块把query字符串转换成对象返回。</p>
<p>一旦把内容复制到一个Buffer后，它就会以二进制的形式存储起来。一个UTF字符可能会占用最多4个字节。创建Buffer可以使用三个参数：指定Buffer的字节长度，需要拷贝到Buffer里的字节数组，或是需要拷贝到Buffer李的字符串。</p>
<p>Buffer.byteLength（）方法获得字符串在编码上的字节长度，而不是String.length返回的字符个数。</p>
<p>Buffer.write（）会把字符串写道Buffer指定的位置上。</p>
<p>DNS模块提供了用域名来代替IP地址作为事物的引用名称功能。主要有两个方法resolve（）和reverse（），前者把域名转换成DNS记录，后者将IP地址转换成域名。</p>
<p>在哈希中使用数据时，可以调用hash.update（）来生成数据摘要。要把哈希输出，只需要调用hash.digest（）方法，这个方法会把所有通过hash.update（）输入的数据生成摘要并输出。</p>
<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>process模块是全局的。因为任何时候否能使用process，所以process.stdin也会为所有的Node进程初始化。在尝试从stdin读数据之前，需要先调用它的resume（）方法。</p>
<p><code>process.nextTick（）</code>创建了一个回调函数，它会在下一个tick或者时间循环下一次迭代时被调用。因为实现是使用队列的，所以它会取代其他事件。</p>
<p>用child_process模块来为Node主进程创建子进程。主要有两个方法:spawn（）会创建一个子进程，并且会有独立的stdin、stdout和stderr文件描述符；exec（）会创建子进程，并会在进程结束的时候以回调函数的方式返回结果。</p>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>assert是为测试代码提供基础功能的核心库。它的很多方法都是成对出现的，一个提供正面的测试，另一个提供反面的功能。比如：equal（）和notEqual（），接受两个参数，第一个是期待的值，第二个是实际的值。它们会检查相等（==）和不相等（！=）操作。在比较的时候会进行类型转换。strictEqual（）和notStrictEqual（）方法检测两个数值是否相等时会采用===和！==。assert.ok（）方法是用来测试一个对象是否为真值的渐变方法，它会使用==来对比测试对象和true是否一样。deepEqual（）和notDeepEqual（）方法提供了深入比较两个对象值的方法。这些方法会进行若干测试，而无需太多的细节。如果任何一个检查失败了，测试就会抛出异常。首先用===检查他们是否相等，然后检查他们的类型是否是Buffer，如果是就检查它们的长度，然后按字节对比。如果对象的类型按==运算符不匹配，它们就不可能相等，最后如果比较的参数是对象类型，就会进行更加严格的测试，如比较两个对象的原型、属性数量，然后对每个属性执行deepEqual（）进行递归比较。<br>assert方法的throws和doesNotThrow（），会检查指定的代码块是否会抛出异常。</p>
<h2 id="虚拟模块"><a href="#虚拟模块" class="headerlink" title="虚拟模块"></a>虚拟模块</h2><p>虚拟机模块（vm）可以让我们运行任意一块代码，并得到运行结果。它提供了一些功能可以修改指定代码运行的上下文。用vm运行有两个方法，第一种与使用eval（）方法类似，把代码内嵌运行，第二种先把代码预编译成vm.script对象。<br>第一种：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; var vm=require（‘vm’）；</span><br><span class="line">&gt; vm.runInThisContext（‘<span class="number">1</span>+<span class="number">1</span>’）；</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>跟eval（）方法很像，我们给它传入一段代码，就返回结果。但是vm并不会像eval（）那样改变本地作用域的内容。eval（）会修改周围的上下文，但vm不会。<br>例如：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&gt; var vm=require（'vm'),</span><br><span class="line">e=<span class="number">0</span>,</span><br><span class="line">v=<span class="number">0</span>;</span><br><span class="line">&gt; eval(e=e+<span class="number">1</span>);</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; e</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; vm.runInThisContext('v=<span class="number">0</span>');</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;vm.runInThisContext('v=v+<span class="number">1</span>');</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; v</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>vm.runInNewContext()，用其第二个参数作为上下文对象，该对象的作用域就成了我们用vm运行代码的上下文。如果我们继续把它传给不同的调用，此上下文就会被修改。而且这个上下文能够被全局作用域使用。</p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>生产环境通常由多种资源组成：Web服务器、缓存服务器和数据库服务器。数据库通常是部署在Web服务器之外的独立机器上，这使得面向公众的网站不必重新配置和修改复杂的数据库集群就可以垂直增长。建立一个数据库的连接的开销相对来说是很大的，为每个请求创建一个甚至多个连接会对高流量网站造成不必要的额外负担，也会导致性能下降。解决方案是在内部缓存池里维护数据库连接，当某链接不再需要时，它会被放回连接池里，这样就能立刻为下一个进入的请求服务了。当用户尝试获取一个连接时，如果没有已经打开的连接，连接池会调用创建函数。如果一个连接闲置太久了，它会被销毁并且释放内存资源。</p>
<h2 id="消息队列协议"><a href="#消息队列协议" class="headerlink" title="消息队列协议"></a>消息队列协议</h2><p>造成堵塞的原因有很多，可能是因为在注册过程中需要发送用户邮件，需要对用户输入进行大量的数学运算，或者是某个任务需要花费的时间超过了用户期望的等待时间等等。Node的事件驱动设计可以用来应对大多情况，它采用的是异步函数和回调函数的方法。但是如果一个时间特别“重”的话，就不应该放在Node内部处理，Node应该只负责快速运算和处理返回的结果。消息队列允许程序员发布事件然后继续其他操作，通过进程间通信频道，提高了并发处理的效率，并实现了更高的扩展性。工作队列的工作原理就是发布的消息在连接到队列的客户端间循环触发。</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>路由是按顺序执行的。当多个路由同时匹配上提供的URL时，只有第一个匹配的路由会执行相关的动作，也就是说如何安排路由的顺序是非常重要的。</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件是一小段特定的代码，位于原始请求时间与指定的路由之间。我们通过中间件对一些通用功能进行代码宠用，如用户授权或log记录。中间件在传递的过程中，不仅把状态传递过去，还包括了跟状态交互的方法。中间件的形式：function（req，res，next）。在实际工作中，中间件好比家里或办公室里看得见的电话线，所有电话（应用）都连接到电话线（中间件）上，而后者能把应用与对应底层的网络连接起来。</p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--Buffer(缓冲区)</title>
    <url>/2019/03/26/nodejs05/</url>
    <content><![CDATA[<h1 id="Node-js笔记-五-————Buffer-缓冲区"><a href="#Node-js笔记-五-————Buffer-缓冲区" class="headerlink" title="Node.js笔记(五)————Buffer(缓冲区)"></a>Node.js笔记(五)————Buffer(缓冲区)</h1><h2 id="Node-js-Buffer-缓冲区"><a href="#Node-js-Buffer-缓冲区" class="headerlink" title="Node.js Buffer(缓冲区)"></a>Node.js Buffer(缓冲区)</h2><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<a id="more"></a>
<h3 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h3><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">const buf = Buffer.<span class="keyword">from</span>(<span class="string">'runoob'</span>, <span class="string">'ascii'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 72756e6f6f62</span></span><br><span class="line">console.<span class="built_in">log</span>(buf.<span class="built_in">toString</span>(<span class="string">'hex'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 cnVub29i</span></span><br><span class="line">console.<span class="built_in">log</span>(buf.<span class="built_in">toString</span>(<span class="string">'base64'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h3><p>Buffer 提供了以下 API 来创建 Buffer 类：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>alloc(size<span class="literal">[, <span class="identifier">fill</span>[, <span class="identifier">encoding</span>]</span>])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 <span class="number">0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>alloc<span class="constructor">Unsafe(<span class="params">size</span>)</span>： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>alloc<span class="constructor">UnsafeSlow(<span class="params">size</span>)</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>from(<span class="built_in">array</span>)： 返回一个被 <span class="built_in">array</span> 的值初始化的新的 Buffer 实例（传入的 <span class="built_in">array</span> 的元素只能是数字，不然就会自动被 <span class="number">0</span> 覆盖）</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>from(arrayBuffer<span class="literal">[, <span class="identifier">byteOffset</span>[, <span class="identifier">length</span>]</span>])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>from(<span class="built_in">string</span><span class="literal">[, <span class="identifier">encoding</span>]</span>)： 返回一个被 <span class="built_in">string</span> 的值初始化的新的 Buffer 实例</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为 10、且用 0 填充的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且未初始化的 Buffer。</span></span><br><span class="line"><span class="comment">// 这个方法比调用 Buffer.alloc() 更快，</span></span><br><span class="line"><span class="comment">// 但返回的 Buffer 实例可能包含旧数据，</span></span><br><span class="line"><span class="comment">// 因此需要使用 fill() 或 write() 重写。</span></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.<span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf5 = Buffer.<span class="keyword">from</span>(<span class="string">'tést'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf6 = Buffer.<span class="keyword">from</span>(<span class="string">'tést'</span>, <span class="string">'latin1'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h3><p>写入 Node 缓冲区的语法如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">buf.write(string[<span class="string">, offset[, length</span>]][, encoding])</span><br></pre></td></tr></table></figure>
<p>参数描述如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> - 写入缓冲区的字符串。</span><br><span class="line"><span class="built_in">offset</span> - 缓冲区开始写入的索引值，默认为 <span class="number">0</span> 。</span><br><span class="line"><span class="built_in">length</span> - 写入的字节数，默认为 buffer.<span class="built_in">length</span></span><br><span class="line">encoding - 使用的编码。默认为 <span class="string">'utf8'</span> 。</span><br></pre></td></tr></table></figure>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">buf = Buffer.alloc(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">len</span> = buf.<span class="built_in">write</span>(<span class="string">"www.runoob.com"</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"写入字节数 : "</span>+  <span class="built_in">len</span>);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">node</span> <span class="title">main</span>.js</span><br><span class="line">写入字节数 : <span class="number">14</span></span><br><span class="line">从缓冲区读取数据</span><br></pre></td></tr></table></figure>
<p>读取 Node 缓冲区数据的语法如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">buf.<span class="keyword">to</span><span class="constructor">String([<span class="params">encoding</span>[, <span class="params">start</span>[, <span class="params">end</span>]]])</span></span><br></pre></td></tr></table></figure>
<p>参数描述如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">encoding</span> - 使用的编码。默认为 <span class="string">'utf8'</span> 。</span><br><span class="line"><span class="keyword">start</span> - 指定开始读取的索引位置，默认为 <span class="number">0</span>。</span><br><span class="line"><span class="keyword">end</span> - 结束位置，默认为缓冲区的末尾。</span><br></pre></td></tr></table></figure>
<p>解码缓冲区数据并使用指定的编码返回字符串。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">buf = <span class="module-access"><span class="module"><span class="identifier">Buffer</span>.</span></span>alloc(<span class="number">26</span>);</span><br><span class="line">for (var i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++) &#123;</span><br><span class="line">  buf<span class="literal">[<span class="identifier">i</span>]</span> = i + <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( buf.<span class="keyword">to</span><span class="constructor">String('<span class="params">ascii</span>')</span>);       <span class="comment">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line">console.log( buf.<span class="keyword">to</span><span class="constructor">String('<span class="params">ascii</span>',0,5)</span>);   <span class="comment">// 输出: abcde</span></span><br><span class="line">console.log( buf.<span class="keyword">to</span><span class="constructor">String('<span class="params">utf8</span>',0,5)</span>);    <span class="comment">// 输出: abcde</span></span><br><span class="line">console.log( buf.<span class="keyword">to</span><span class="constructor">String(<span class="params">undefined</span>,0,5)</span>); <span class="comment">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>
<h3 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h3><p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：<code>buf.toJSON()</code><br>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。<br>返回 JSON 对象</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">const buf = Buffer.<span class="keyword">from</span>([<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>, <span class="number">0x5</span>]);</span><br><span class="line">const <span class="type">json</span> = <span class="type">JSON</span>.stringify(buf);</span><br><span class="line"></span><br><span class="line">// 输出: &#123;"type":"Buffer","data":[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;</span><br><span class="line">console.log(<span class="type">json</span>);</span><br><span class="line"></span><br><span class="line">const copy = <span class="type">JSON</span>.parse(<span class="type">json</span>, (key, <span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span> &amp;&amp; <span class="keyword">value</span>.<span class="keyword">type</span> === <span class="string">'Buffer'</span> ?</span><br><span class="line">    Buffer.<span class="keyword">from</span>(<span class="keyword">value</span>.data) :</span><br><span class="line">    <span class="keyword">value</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出: &lt;Buffer <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span>&gt;</span><br><span class="line">console.log(<span class="keyword">copy</span>);//&lt;Buffer <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h3><p>Node 缓冲区合并的语法如下所示：<code>Buffer.concat(list[, totalLength])</code><br>参数描述如下：</p>
<ul>
<li>list - 用于合并的 Buffer 对象数组列表。</li>
<li>totalLength - 指定合并后Buffer对象的总长度。<br>返回一个多个成员合并的新 Buffer 对象。<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = <span class="built_in">Buffer</span>.from((<span class="string">'adv'</span>));</span><br><span class="line"><span class="keyword">var</span> buffer2 = <span class="built_in">Buffer</span>.from((<span class="string">'fffff'</span>));</span><br><span class="line"><span class="keyword">var</span> buffer3 = <span class="built_in">Buffer</span>.concat([buffer1,buffer2]);</span><br><span class="line">console.log(<span class="string">"buffer3 内容: "</span> + buffer3.toString());</span><br><span class="line"><span class="comment">//输出结果为：buffer3 内容: advfffff</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：<code>buf.compare(otherBuffer)</code>;<br>参数描述如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">otherBuffer</span> - 与 <span class="keyword">buf </span>对象比较的另外一个 <span class="keyword">Buffer </span>对象。返回一个数字，表示 <span class="keyword">buf </span>在 otherBuffer 之前，之后或相同。</span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">var</span> <span class="keyword">buffer1 </span>= <span class="keyword">Buffer.from('ABC');</span></span><br><span class="line"><span class="keyword">var </span><span class="keyword">buffer2 </span>= <span class="keyword">Buffer.from('ABCD');</span></span><br><span class="line"><span class="keyword">var </span>result = <span class="keyword">buffer1.compare(buffer2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">if(result </span>&lt; <span class="number">0</span>) &#123;</span><br><span class="line">   console.log(<span class="keyword">buffer1 </span>+ <span class="string">" 在 "</span> + <span class="keyword">buffer2 </span>+ <span class="string">"之前"</span>)<span class="comment">;</span></span><br><span class="line">&#125;<span class="meta">else</span> <span class="meta">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">   console.log(<span class="keyword">buffer1 </span>+ <span class="string">" 与 "</span> + <span class="keyword">buffer2 </span>+ <span class="string">"相同"</span>)<span class="comment">;</span></span><br><span class="line">&#125;<span class="meta">else</span> &#123;</span><br><span class="line">   console.log(<span class="keyword">buffer1 </span>+ <span class="string">" 在 "</span> + <span class="keyword">buffer2 </span>+ <span class="string">"之后"</span>)<span class="comment">;</span></span><br><span class="line">&#125;//结果为：ABC在ABCD之前</span><br></pre></td></tr></table></figure>

<h3 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h3><p>Node 缓冲区拷贝语法如下所示：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">buf.copy(targetBuffer<span class="comment">[, targetStart<span class="comment">[, sourceStart<span class="comment">[, sourceEnd]</span>]</span>]</span>)</span><br></pre></td></tr></table></figure>
<p>参数描述如下：</p>
<ul>
<li>targetBuffer - 要拷贝的 Buffer 对象。</li>
<li>targetStart - 数字, 可选, 默认: 0</li>
<li>sourceStart - 数字, 可选, 默认: 0</li>
<li>sourceEnd - 数字, 可选, 默认: buffer.length<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = <span class="built_in">Buffer</span>.from(<span class="string">'abcdefghijkl'</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = <span class="built_in">Buffer</span>.from(<span class="string">'RUNOOB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 buf2 插入到 buf1 指定位置上</span></span><br><span class="line">buf2.copy(buf1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">console.log(buf1.toString());</span><br><span class="line"><span class="comment">//输出结果为：abRUNOOBijkl</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">buf.<span class="keyword">slice</span>([<span class="keyword">start</span>[, <span class="keyword">end</span>]])</span><br><span class="line"><span class="keyword">start</span> - 数字, 可选, 默认: <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> - 数字, 可选, 默认: buffer.length</span><br></pre></td></tr></table></figure>
<p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = <span class="built_in">Buffer</span>.from(<span class="string">'runoob'</span>);</span><br><span class="line"><span class="comment">// 剪切缓冲区</span></span><br><span class="line"><span class="keyword">var</span> buffer2 = buffer1.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">console.log(<span class="string">"buffer2 content: "</span> + buffer2.toString());</span><br><span class="line"><span class="comment">//输出结果为：buffer2 content: ru</span></span><br></pre></td></tr></table></figure>
<h3 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h3><p>buf.length;<br>返回 Buffer 对象所占据的内存长度。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="built_in">Buffer</span>.from(<span class="string">'www.runoob.com'</span>);</span><br><span class="line"><span class="comment">//  缓冲区长度</span></span><br><span class="line">console.log(<span class="string">"buffer length: "</span> + buffer.length);</span><br><span class="line"><span class="comment">//输出结果为：buffer length: 14</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--全局函数</title>
    <url>/2019/03/25/nodejs06/</url>
    <content><![CDATA[<h1 id="Node-js笔记-六-————全局函数"><a href="#Node-js笔记-六-————全局函数" class="headerlink" title="Node.js笔记(六)————全局函数"></a>Node.js笔记(六)————全局函数</h1><h2 id="Node-js-全局对象"><a href="#Node-js-全局对象" class="headerlink" title="Node.js 全局对象"></a>Node.js 全局对象</h2><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<a id="more"></a>
<h3 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h3><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
<p>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>
<p>注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。<br>Node.js包括的全局函数有：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">setTimeout</span><br><span class="line">clearTimeout</span><br><span class="line">setInterval</span><br><span class="line">clearInterval</span><br><span class="line">JavaScript中的全局函数有：</span><br><span class="line"><span class="function"><span class="title">decodeURI</span><span class="params">(对编码后的URI进行解码)</span></span></span><br><span class="line">encodeURI(对URI进行完整的编码）</span><br><span class="line">encodeURIComponent(可以把字符串作为URI组件进行编码）</span><br><span class="line">对encodeURIComponent（）编码过的URI进行解码</span><br><span class="line"><span class="function"><span class="title">escape</span><span class="params">(对字符串进行编码，可以在所有的计算机上读取该字符串)</span></span></span><br><span class="line">unescape（对escape（）编码的字符串进行解码）</span><br><span class="line">eval(计算某个字符串，并执行其中的JavaScript代码）</span><br><span class="line">getClass</span><br><span class="line">isFinite(检测参数是否无限大）</span><br><span class="line">isNaN(检测该参数是否是非数字值）</span><br><span class="line"><span class="function"><span class="title">Number</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">paseFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">String</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Node-js-常用工具"><a href="#Node-js-常用工具" class="headerlink" title="Node.js 常用工具"></a>Node.js 常用工具</h2><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<h3 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h3><p>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。<br>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。<br>util.inherits 的用法，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'base'</span>; </span><br><span class="line">    <span class="keyword">this</span>.base = <span class="number">1991</span>; </span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sub'</span>; </span><br><span class="line">&#125; </span><br><span class="line">util.inherits(Sub, Base); </span><br><span class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base(); </span><br><span class="line">objBase.showName(); </span><br><span class="line">objBase.sayHello(); </span><br><span class="line"><span class="built_in">console</span>.log(objBase); </span><br><span class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub(); </span><br><span class="line">objSub.showName(); </span><br><span class="line"><span class="comment">//objSub.sayHello(); </span></span><br><span class="line"><span class="built_in">console</span>.log(objSub);</span><br></pre></td></tr></table></figure>
<p>定义了一个基础对象 Base 和一个继承自 Base 的 Sub，Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">base</span> </span><br><span class="line"><span class="selector-tag">Hello</span> <span class="selector-tag">base</span> </span><br><span class="line">&#123; <span class="attribute">name</span>: <span class="string">'base'</span>, base: <span class="number">1991</span>, sayHello: [Function] &#125; </span><br><span class="line"><span class="selector-tag">sub</span> </span><br><span class="line">&#123; <span class="attribute">name</span>: <span class="string">'sub'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被 console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">node.js:<span class="number">201</span> </span><br><span class="line">throw e; <span class="comment">// process.nextTick error, or 'error' event on first tick </span></span><br><span class="line">^ </span><br><span class="line">TypeError: Object #&amp;lt;Sub&amp;gt; <span class="keyword">has</span> no <span class="function"><span class="keyword">method</span> '<span class="title">sayHello</span>' </span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">Object</span>.&amp;<span class="title">lt</span>;</span>anonymous&amp;gt; (/home/byvoid/utilinherits.js:<span class="number">29</span>:<span class="number">8</span>) </span><br><span class="line">at <span class="keyword">Module</span>._compile (<span class="keyword">module</span>.js:<span class="number">441</span>:<span class="number">26</span>) </span><br><span class="line">at Object..js (<span class="keyword">module</span>.js:<span class="number">459</span>:<span class="number">10</span>) </span><br><span class="line">at <span class="keyword">Module</span>.load (<span class="keyword">module</span>.js:<span class="number">348</span>:<span class="number">31</span>) </span><br><span class="line">at <span class="function"><span class="keyword">Function</span>._<span class="title">load</span> <span class="params">(<span class="keyword">module</span>.js:308:12)</span> </span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">Array</span>.0 <span class="params">(<span class="keyword">module</span>.js:479:10)</span> </span></span><br><span class="line"><span class="function"><span class="title">at</span> <span class="title">EventEmitter</span>._<span class="title">tickCallback</span> <span class="params">(node.js:192:40)</span></span></span><br><span class="line"><span class="function"><span class="title">util</span>.<span class="title">inspect</span></span></span><br></pre></td></tr></table></figure>
<p>util.inspect(object,[showHidden],[depth],[colors]) 是一个将任意对象转换<br>为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>
<p>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</p>
<p>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。<br>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了 toString 方法也不会调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'byvoid'</span>; </span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj)); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Person</span> &#123; <span class="attribute">name</span>: <span class="string">'byvoid'</span>, toString: [Function] &#125;</span><br><span class="line"><span class="selector-tag">Person</span> &#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'byvoid'</span>,</span><br><span class="line">  toString: </span><br><span class="line">   &#123; [Function]</span><br><span class="line">     [length]: <span class="number">0</span>,</span><br><span class="line">     [name]: <span class="string">''</span>,</span><br><span class="line">     [arguments]: null,</span><br><span class="line">     [caller]: null,</span><br><span class="line">     [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125;</span><br><span class="line"><span class="selector-tag">util</span><span class="selector-class">.isArray</span>(<span class="selector-tag">object</span>)</span><br></pre></td></tr></table></figure>
<p>如果给定的参数 “object” 是一个数组返回true，否则返回false。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var util = require('util');</span><br><span class="line"></span><br><span class="line">util.is<span class="constructor">Array([])</span></span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">Array(<span class="params">new</span> Array)</span></span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">Array(&#123;&#125;)</span></span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">util.is<span class="constructor">RegExp(<span class="params">object</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var util = require('util');</span><br><span class="line"></span><br><span class="line">util.is<span class="constructor">RegExp(<span class="operator">/</span><span class="params">some</span> <span class="params">regexp</span><span class="operator">/</span>)</span></span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">RegExp(<span class="params">new</span> RegExp('<span class="params">another</span> <span class="params">regexp</span>')</span>)</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">RegExp(&#123;&#125;)</span></span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">util.is<span class="constructor">Date(<span class="params">object</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果给定的参数 “object” 是一个日期返回true，否则返回false。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var util = require(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">util.isDate(<span class="built_in">new</span> <span class="type">Date</span>())</span><br><span class="line">  // <span class="keyword">true</span></span><br><span class="line">util.isDate(<span class="type">Date</span>())</span><br><span class="line">  // <span class="keyword">false</span> (<span class="keyword">without</span> <span class="string">'new'</span> <span class="keyword">returns</span> a String)</span><br><span class="line">util.isDate(&#123;&#125;)</span><br><span class="line">  // <span class="keyword">false</span></span><br><span class="line">util.isError(<span class="keyword">object</span>)</span><br></pre></td></tr></table></figure>
<p>如果给定的参数 “object” 是一个错误对象返回true，否则返回false。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var util = require('util');</span><br><span class="line"></span><br><span class="line">util.is<span class="constructor">Error(<span class="params">new</span> Error()</span>)</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">Error(<span class="params">new</span> TypeError()</span>)</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.is<span class="constructor">Error(&#123; <span class="params">name</span>: 'Error', <span class="params">message</span>: '<span class="params">an</span> <span class="params">error</span> <span class="params">occurred</span>' &#125;)</span></span><br><span class="line">  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--stream模块和http模块</title>
    <url>/2019/03/24/nodejs04/</url>
    <content><![CDATA[<h1 id="Node-js笔记-四-————stream模块和http模块"><a href="#Node-js笔记-四-————stream模块和http模块" class="headerlink" title="Node.js笔记(四)————stream模块和http模块"></a>Node.js笔记(四)————stream模块和http模块</h1><h2 id="stream-模块"><a href="#stream-模块" class="headerlink" title="stream 模块"></a>stream 模块</h2><p>stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>
<a id="more"></a>
<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>
<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。<br>Node.js，Stream 有四种流类型：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Readable</span> <span class="string">- 可读操作。</span></span><br><span class="line"><span class="attr">Writable</span> <span class="string">- 可写操作。</span></span><br><span class="line"><span class="attr">Duplex</span> <span class="string">- 可读可写操作.</span></span><br><span class="line"><span class="attr">Transform</span> <span class="string">- 操作被写入数据，然后读出结果。</span></span><br></pre></td></tr></table></figure>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">data - 当有数据可读时触发。</span><br><span class="line">end - 没有更多的数据可读时触发。</span><br><span class="line"><span class="keyword">error </span>- 在接收和写入过程中发生错误时触发。</span><br><span class="line">finish - 所有数据已被写入到底层系统时触发。</span><br></pre></td></tr></table></figure>
<p>一个从文件流读取文本内容的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个流:</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DATA:'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'END'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ERROR: '</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data事件可能会有多次，每次传递的chunk是流的一部分数据。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws1 = fs.createWriteStream(<span class="string">'output1.txt'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">ws1.<span class="keyword">write</span>(<span class="string">'使用Stream写入文本数据...\n'</span>);</span><br><span class="line">ws1.<span class="keyword">write</span>(<span class="string">'END.'</span>);</span><br><span class="line">ws1.<span class="keyword">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws2 = fs.createWriteStream(<span class="string">'output2.txt'</span>);</span><br><span class="line">ws2.<span class="keyword">write</span>(new Buffer(<span class="string">'使用Stream写入二进制数据...\n'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">ws2.<span class="keyword">write</span>(new Buffer(<span class="string">'END.'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">ws2.<span class="keyword">end</span>();</span><br></pre></td></tr></table></figure>
<p>所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。</p>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。<br>在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。<br>用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'sample.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'copied.txt'</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>
<p>默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">readable</span><span class="selector-class">.pipe</span>(<span class="selector-tag">writable</span>, &#123; <span class="attribute">end</span>: false &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的全栈了。</p>
<h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。</p>
<p>request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p>response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。<br>用Node.js实现一个HTTP服务器程序非常简单。<br>实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">': '</span> + request.url);</span><br><span class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end(<span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h2><p>我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。<br>解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">url</span>.parse(<span class="string">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span>));</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Url</span> &#123;</span><br><span class="line">  <span class="attribute">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  <span class="attribute">slashes</span>: true,</span><br><span class="line">  <span class="attribute">auth</span>: <span class="string">'user:pass'</span>,</span><br><span class="line">  <span class="attribute">host</span>: <span class="string">'host.com:8080'</span>,</span><br><span class="line">  <span class="attribute">port</span>: <span class="string">'8080'</span>,</span><br><span class="line">  <span class="attribute">hostname</span>: <span class="string">'host.com'</span>,</span><br><span class="line">  <span class="attribute">hash</span>: <span class="string">'#hash'</span>,</span><br><span class="line">  <span class="attribute">search</span>: <span class="string">'?query=string'</span>,</span><br><span class="line">  <span class="attribute">query</span>: <span class="string">'query=string'</span>,</span><br><span class="line">  <span class="attribute">pathname</span>: <span class="string">'/path/to/file'</span>,</span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'/path/to/file?query=string'</span>,</span><br><span class="line">  <span class="attribute">href</span>: <span class="string">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析当前目录:</span></span><br><span class="line"><span class="built_in">var</span> workDir = path.resolve(<span class="string">'.'</span>); <span class="comment">// '/Users/michael'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合完整的文件路径:当前目录+'pub'+'index.html':</span></span><br><span class="line"><span class="built_in">var</span> filePath = path.<span class="keyword">join</span>(workDir, <span class="string">'pub'</span>, <span class="string">'index.html'</span>);</span><br><span class="line"><span class="comment">// '/Users/michael/pub/index.html'</span></span><br></pre></td></tr></table></figure>
<p>使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\Users\michael\static\index.html，这样，我们就不关心怎么拼接路径了。<br>使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\Users\michael\static\index.html，这样，我们就不关心怎么拼接路径了。<br>最后，我们实现一个文件服务器file_server.js：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">    <span class="built_in">url</span> = <span class="built_in">require</span>(<span class="string">'url'</span>),</span><br><span class="line">    path = <span class="built_in">require</span>(<span class="string">'path'</span>),</span><br><span class="line">    http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从命令行参数获取root目录，默认是当前目录:</span></span><br><span class="line"><span class="keyword">var</span> root = path.resolve(process.argv[<span class="number">2</span>] || <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Static root dir: '</span> + root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得URL的path，类似 '/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> pathname = <span class="built_in">url</span>.parse(request.url).pathname;</span><br><span class="line">    <span class="comment">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> filepath = path.join(root, pathname);</span><br><span class="line">    <span class="comment">// 获取文件状态:</span></span><br><span class="line">    fs.stat(filepath, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; stats.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 没有出错并且文件存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'200 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送200响应:</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 将文件流导向response:</span></span><br><span class="line">            fs.createReadStream(filepath).pipe(response);</span><br><span class="line">        &#125; <span class="title">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错了或者文件不存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'404 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送404响应:</span></span><br><span class="line">            response.writeHead(<span class="number">404</span>);</span><br><span class="line">            response.end(<span class="string">'404 Not Found'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>
<p>没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行node file_server.js /path/to/dir，把/path/to/dir改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html：</code></p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--EventEmitter</title>
    <url>/2019/03/23/nodejs03/</url>
    <content><![CDATA[<h1 id="Node-js笔记-三-————Node-js-EventEmitter"><a href="#Node-js笔记-三-————Node-js-EventEmitter" class="headerlink" title="Node.js笔记(三)————Node.js EventEmitter"></a>Node.js笔记(三)————Node.js EventEmitter</h1><h2 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h2><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h3 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h3><p>events 模块只提供了一个对象：<code>events.EventEmitter</code>。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<a id="more"></a>
<p>可以通过require(“events”);来访问该模块。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = require(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> <span class="type">events</span>.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p>EventEmitter 的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    event.emit(<span class="string">'some_event'</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">event</span>.js </span><br><span class="line">some_event 事件触发</span><br><span class="line">EventEmitter</span><br></pre></td></tr></table></figure>
<p>的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，运行的结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">event</span>.js </span><br><span class="line">listener1 arg1 参数 arg2 参数</span><br><span class="line">listener2 arg1 参数 arg2 参数</span><br></pre></td></tr></table></figure>
<p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>
<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>
<p>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法    描述</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">addListener(<span class="keyword">event</span>, listener)	为指定事件添加一个监听器到监听器数组的尾部。</span><br><span class="line"><span class="keyword">on</span>(<span class="keyword">event</span>, listener)	为指定事件注册一个监听器，接受一个字符串 <span class="keyword">event</span> 和一个回调函数。 server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(stream)</span> <span class="comment">&#123; console.log('someone connected!'); &#125;</span>);</span></span><br><span class="line">once(<span class="keyword">event</span>, listener)	为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 server.once(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(stream)</span> <span class="comment">&#123; console.log('Ah, we have our first user!');&#125;</span>);</span></span><br><span class="line">removeListener(<span class="keyword">event</span>, listener)	移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。 <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span><span class="params">(stream)</span> <span class="comment">&#123; console.log('someone connected!');&#125;</span>;</span> server.on(<span class="string">'connection'</span>, callback); <span class="comment">// ... server.removeListener('connection', callback);</span></span><br><span class="line">removeAllListeners([<span class="keyword">event</span>])	移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</span><br><span class="line">setMaxListeners(n)	默认情况下， EventEmitters 如果你添加的监听器超过 <span class="number">10</span> 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</span><br><span class="line">listeners(<span class="keyword">event</span>)	返回指定事件的监听器数组。</span><br><span class="line">emit(<span class="keyword">event</span>, [arg1], [arg2], [...])	按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <span class="keyword">true</span>，否则返回 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>方法    描述</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">listener<span class="constructor">Count(<span class="params">emitter</span>, <span class="params">event</span>)</span>	返回指定事件的监听器数量。 events.<span class="module-access"><span class="module"><span class="identifier">EventEmitter</span>.</span></span>listener<span class="constructor">Count(<span class="params">emitter</span>, <span class="params">eventName</span>)</span> <span class="comment">//已废弃，不推荐 events.emitter.listenerCount(eventName) //推荐</span></span><br><span class="line">事件</span><br><span class="line">事件	描述</span><br><span class="line">newListener	</span><br><span class="line">event - 字符串，事件名称</span><br><span class="line">listener - 处理事件函数</span><br><span class="line">该事件在添加新监听器时被触发。</span><br><span class="line">removeListener	</span><br><span class="line">event - 字符串，事件名称</span><br><span class="line">listener - 处理事件函数</span><br></pre></td></tr></table></figure>
<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。<br>实例<br>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。<br>创建 main.js 文件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'监听器 listener1 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener2 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener2</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listener1 函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listener1 不再受监听。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line">eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码，执行结果如下所示：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">main</span>.js</span><br><span class="line"><span class="number">2</span> 个监听器监听连接事件。</span><br><span class="line">监听器 listener1 执行。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">listener1 不再受监听。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line"><span class="number">1</span> 个监听器监听连接事件。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>
<h3 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h3><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = require(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> <span class="type">events</span>.EventEmitter(); </span><br><span class="line">emitter.emit(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">node.js:<span class="number">201</span> </span><br><span class="line">throw e; <span class="comment">// process.nextTick error, or 'error' event on first tick </span></span><br><span class="line">^ </span><br><span class="line">Error: Uncaught, unspecified <span class="string">'error'</span> event. </span><br><span class="line">at EventEmitter.emit (events.js:<span class="number">50</span>:<span class="number">15</span>) </span><br><span class="line">at Object.&lt;anonymous&gt; (/home/byvoid/error.js:<span class="number">5</span>:<span class="number">9</span>) </span><br><span class="line">at Module._compile (module.js:<span class="number">441</span>:<span class="number">26</span>) </span><br><span class="line">at Object..js (module.js:<span class="number">459</span>:<span class="number">10</span>) </span><br><span class="line">at Module.load (module.js:<span class="number">348</span>:<span class="number">31</span>) </span><br><span class="line">at Function._load (module.js:<span class="number">308</span>:<span class="number">12</span>) </span><br><span class="line">at Array<span class="number">.0</span> (module.js:<span class="number">479</span>:<span class="number">10</span>) </span><br><span class="line">at EventEmitter._tickCallback (node.js:<span class="number">192</span>:<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<h3 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h3><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--fs模块</title>
    <url>/2019/03/22/nodejs02/</url>
    <content><![CDATA[<h1 id="Node-js笔记-二-————fs模块"><a href="#Node-js笔记-二-————fs模块" class="headerlink" title="Node.js笔记(二)————fs模块"></a>Node.js笔记(二)————fs模块</h1><h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><p>Node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。<br>什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(<span class="string">'http://example.com/ajax'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'IO结果返回后执行...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不等待IO结果直接执行后续代码...'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>而同步的IO操作则需要等待函数返回：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据网络耗时，函数将执行几十毫秒~几秒不等:</span></span><br><span class="line">var data = get<span class="constructor">JSONSync('<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">example</span>.<span class="params">com</span><span class="operator">/</span><span class="params">ajax</span>')</span>;</span><br></pre></td></tr></table></figure>
<p>同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。</p>
<h3 id="异步读文件"><a href="#异步读文件" class="headerlink" title="异步读文件"></a>异步读文件</h3><p>异步读取文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.read(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：sample.txt文件必须在当前目录下，且文件编码为utf-8。<br>异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。<br>由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子演示了如何读取一个图片文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.read(<span class="string">'sample.png'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">' bytes'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。<br>Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line">var <span class="built_in">text</span> = data.<span class="built_in">toString</span>(<span class="string">'utf-8'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">text</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line">var buf = Buffer.<span class="keyword">from</span>(<span class="built_in">text</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(buf);</span><br></pre></td></tr></table></figure>
<h3 id="同步读文件"><a href="#同步读文件" class="headerlink" title="同步读文件"></a>同步读文件</h3><p>除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。<br>用fs模块同步读取一个文本文件的代码如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = fs.readFileSync(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">data</span>);</span><br></pre></td></tr></table></figure>
<p>可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。<br>如果同步读取文件发生错误，则需要用try…catch捕获该错误：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = fs.readFileSync(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">    console.log(<span class="keyword">data</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>将数据写入文件是通过fs.writeFile()实现的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'Hello, Node.js'</span>;</span><br><span class="line">fs.writeFile(<span class="string">'output.txt'</span>, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ok.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。</p>
<p>和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = <span class="string">'Hello, Node.js'</span>;</span><br><span class="line">fs.writeFileSync(<span class="string">'output.txt'</span>, <span class="built_in">data</span>);</span><br><span class="line">stat</span><br></pre></td></tr></table></figure>
<p>如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">'sample.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是文件:</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'isFile: '</span> + stat.isFile());</span><br><span class="line">        <span class="comment">// 是否是目录:</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'isDirectory: '</span> + stat.isDirectory());</span><br><span class="line">        <span class="keyword">if</span> (stat.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 文件大小:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'size: '</span> + stat.size);</span><br><span class="line">            <span class="comment">// 创建时间, Date对象:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'birth time: '</span> + stat.birthtime);</span><br><span class="line">            <span class="comment">// 修改时间, Date对象:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'modified time: '</span> + stat.mtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">isFile:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">isDirectory:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">size:</span> <span class="number">181</span></span><br><span class="line"><span class="attr">birth time:</span> <span class="string">Fri</span> <span class="string">Dec</span> <span class="number">11</span> <span class="number">2015</span> <span class="number">09</span><span class="string">:43:41</span> <span class="string">GMT+0800</span> <span class="string">(CST)</span></span><br><span class="line"><span class="attr">modified time:</span> <span class="string">Fri</span> <span class="string">Dec</span> <span class="number">11</span> <span class="number">2015</span> <span class="number">12</span><span class="string">:09:00</span> <span class="string">GMT+0800</span> <span class="string">(CST)</span></span><br></pre></td></tr></table></figure>
<p>stat()也有一个对应的同步函数statSync()。</p>
<p>stats类中的方法有：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">方法</span> <span class="string">描述</span></span><br><span class="line"><span class="string">stats.isFile()</span> <span class="string">如果是文件返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br><span class="line"><span class="string">stats.isDirectory()</span> <span class="string">如果是目录返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br><span class="line"><span class="string">stats.isBlockDevice()</span> <span class="string">如果是块设备返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br><span class="line"><span class="string">stats.isCharacterDevice()</span> <span class="string">如果是字符设备返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br><span class="line"><span class="string">stats.isSymbolicLink()</span> <span class="string">如果是软链接返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br><span class="line"><span class="string">stats.isFIFO()</span> <span class="string">如果是FIFO，返回true，否则返回</span></span><br><span class="line"><span class="literal">false</span><span class="string">。FIFO是UNIX中的一种特殊类型的命令管道。</span></span><br><span class="line"><span class="string">stats.isSocket()</span> <span class="string">如果是</span> <span class="string">Socket</span> <span class="string">返回</span> <span class="literal">true</span><span class="string">，否则返回</span> <span class="literal">false</span><span class="string">。</span></span><br></pre></td></tr></table></figure>
<p>创建 file.js 文件，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.stat(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(stats);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取文件信息成功！"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 检测文件类型</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为文件(isFile) ? "</span> + stats.isFile());</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为目录(isDirectory) ? "</span> + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">node</span> <span class="string">file.js</span> </span><br><span class="line"><span class="string">准备打开文件！</span></span><br><span class="line"><span class="string">&#123;</span> <span class="attr">dev:</span> <span class="number">16777220</span><span class="string">,</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="number">33188</span><span class="string">,</span></span><br><span class="line">  <span class="attr">nlink:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="number">501</span><span class="string">,</span></span><br><span class="line">  <span class="attr">gid:</span> <span class="number">20</span><span class="string">,</span></span><br><span class="line">  <span class="attr">rdev:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">  <span class="attr">blksize:</span> <span class="number">4096</span><span class="string">,</span></span><br><span class="line">  <span class="attr">ino:</span> <span class="number">40333161</span><span class="string">,</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">61</span><span class="string">,</span></span><br><span class="line">  <span class="attr">blocks:</span> <span class="number">8</span><span class="string">,</span></span><br><span class="line">  <span class="attr">atime:</span> <span class="string">Mon</span> <span class="string">Sep</span> <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span><span class="string">:43:55</span> <span class="string">GMT+0800</span> <span class="string">(CST),</span></span><br><span class="line">  <span class="attr">mtime:</span> <span class="string">Mon</span> <span class="string">Sep</span> <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span><span class="string">:22:35</span> <span class="string">GMT+0800</span> <span class="string">(CST),</span></span><br><span class="line">  <span class="attr">ctime:</span> <span class="string">Mon</span> <span class="string">Sep</span> <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span><span class="string">:22:35</span> <span class="string">GMT+0800</span> <span class="string">(CST)</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">读取文件信息成功！</span></span><br><span class="line"><span class="string">是否为文件(isFile)</span> <span class="string">?</span> <span class="literal">true</span></span><br><span class="line"><span class="string">是否为目录(isDirectory)</span> <span class="string">?</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="异步还是同步"><a href="#异步还是同步" class="headerlink" title="异步还是同步"></a>异步还是同步</h3><p>在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>
<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>
<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>
<p>打开文件</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fs</span>.open(<span class="built_in">path</span>, flags[, <span class="built_in">mode</span>], callback)</span><br></pre></td></tr></table></figure>
<ul>
<li>path - 文件的路径。</li>
<li>flags - 文件打开的行为。</li>
<li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li>callback - 回调函数，带有两个参数如：callback(err, fd)。</li>
<li>flags 参数可以是以下值：</li>
</ul>
<p>Flag 描述</p>
<ul>
<li>r 以读取模式打开文件。如果文件不存在抛出异常。</li>
<li>r+ 以读写模式打开文件。如果文件不存在抛出异常。</li>
<li>rs 以同步的方式读取文件。</li>
<li>rs+ 以同步的方式读取和写入文件。</li>
<li>w 以写入模式打开文件，如果文件不存在则创建。</li>
<li>wx 类似 ‘w’，但是如果文件路径存在，则文件写入失败。</li>
<li>w+ 以读写模式打开文件，如果文件不存在则创建。</li>
<li>wx+ 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。</li>
<li>a 以追加模式打开文件，如果文件不存在则创建。</li>
<li>ax 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。</li>
<li>a+ 以读取追加模式打开文件，如果文件不存在则创建。</li>
<li>ax+ 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</li>
</ul>
<p>创建 file.js 文件，并打开 input.txt 文件进行读写，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步打开文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">file</span>.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">关闭文件</span><br><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">1<span class="selector-class">.fd</span> <span class="selector-tag">-</span> 通过 <span class="selector-tag">fs</span><span class="selector-class">.open</span>() 方法返回的文件描述符。</span><br><span class="line">2<span class="selector-class">.callback</span> <span class="selector-tag">-</span> 回调函数，没有参数</span><br></pre></td></tr></table></figure>
<h3 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">fs</span><span class="selector-class">.ftruncate</span>(<span class="selector-tag">fd</span>, <span class="selector-tag">len</span>, <span class="selector-tag">callback</span>)</span><br><span class="line">1<span class="selector-class">.fd</span> <span class="selector-tag">-</span> 通过 <span class="selector-tag">fs</span><span class="selector-class">.open</span>() 方法返回的文件描述符。</span><br><span class="line">2<span class="selector-class">.len</span> <span class="selector-tag">-</span> 文件内容截取的长度。</span><br><span class="line">3<span class="selector-class">.callback</span> <span class="selector-tag">-</span> 回调函数，没有参数。</span><br></pre></td></tr></table></figure>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">fs</span><span class="selector-class">.unlink</span>(<span class="selector-tag">path</span>, <span class="selector-tag">callback</span>)</span><br><span class="line">1<span class="selector-class">.path</span> <span class="selector-tag">-</span> 文件路径。</span><br><span class="line">2<span class="selector-class">.callback</span> <span class="selector-tag">-</span> 回调函数，没有参数。</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</span><br><span class="line">fs.unlink(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">file</span>.js </span><br><span class="line">准备删除文件！</span><br><span class="line">文件删除成功！</span><br><span class="line">创建目录</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">fs.mkdir(<span class="type">path</span>[, <span class="keyword">options</span>], callback)</span><br><span class="line"><span class="number">1.</span><span class="type">path</span> - 文件路径。</span><br><span class="line"><span class="number">2.</span><span class="keyword">options</span> 参数可以是：</span><br><span class="line"><span class="keyword">recursive</span> - 是否以递归的方式创建目录，默认为 <span class="keyword">false</span>。</span><br><span class="line">mode - 设置目录权限，默认为 <span class="number">0777</span>。</span><br><span class="line"><span class="number">3.</span>callback - 回调函数，没有参数。</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// tmp 目录必须存在</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"创建目录 /tmp/test/"</span>);</span><br><span class="line">fs.mkdir(<span class="string">"/tmp/test/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"目录创建成功。"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">file</span>.js </span><br><span class="line">创建目录 /tmp/test/</span><br><span class="line">目录创建成功。</span><br><span class="line">读取目录</span><br></pre></td></tr></table></figure>
<p>fs.readdir(path, callback)<br>1.path - 文件路径。<br>2.callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。<br>创建 file.js 文件，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"查看 /tmp 目录"</span>);</span><br><span class="line">fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ node <span class="meta">file</span>.js </span><br><span class="line">查看 /tmp 目录</span><br><span class="line"><span class="meta">input</span>.<span class="meta">out</span></span><br><span class="line"><span class="meta">output</span>.<span class="meta">out</span></span><br></pre></td></tr></table></figure>
<p>test<br>test.txt<br>删除目录<br>fs.rmdir(path, callback)<br>1.path - 文件路径。<br>2.callback - 回调函数，没有参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// 执行前创建一个空的 /tmp/test 目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除目录 /tmp/test"</span>);</span><br><span class="line">fs.rmdir(<span class="string">"/tmp/test"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取 /tmp 目录"</span>);</span><br><span class="line">   fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">file</span>.js </span><br><span class="line">准备删除目录 /tmp/test</span><br><span class="line">读取 /tmp 目录</span><br><span class="line">……</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js01--CommonJS规范</title>
    <url>/2019/03/21/nodejs01/</url>
    <content><![CDATA[<h1 id="Node-js笔记-一-————CommonJS规范、回调函数和Node-js-REPL-交互式解释器"><a href="#Node-js笔记-一-————CommonJS规范、回调函数和Node-js-REPL-交互式解释器" class="headerlink" title="Node.js笔记(一)————CommonJS规范、回调函数和Node.js REPL(交互式解释器)"></a>Node.js笔记(一)————CommonJS规范、回调函数和Node.js REPL(交互式解释器)</h1><h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS对模块的规范就三个：<code>模块的定义、模块的引用、模块的标识</code>。<br>整个模块最重要的东西有：<code>module、exports、require</code>。</p>
<h3 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h3><p>CommonJS的模块只有一个唯一出口，那就是module.exports对象，我们把所有导出的变量或函数都放到这个对象里，再导出这个对象。然后我们就可以在外部访问到这些变量和函数，而没有被导出的对外部而言就是看不见的。</p>
<a id="more"></a>
<p>语法为<code>module.exports = variable</code>;<br>我们可以用module.exports={}的形式导出，也可以用exports.a=”…..”的形式导出，但是不能用exports={}形式导出。<br>一个变量中，module变量是整个模块，而这个module变量有一个属性交exports，这个属性是exports变量的引用。最后导出的是module.exports而不是exports对象。</p>
<h3 id="模块的引用"><a href="#模块的引用" class="headerlink" title="模块的引用"></a>模块的引用</h3><p>用require来进行模块的引用，require方法会返回模块中导出的module.exports对象。<br>模块的标识<br>指的是如何在require根据传入的参数找到这个模块，模块标识主要有以下几个部分：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>符合小驼峰式命名法的字符串。（从node_modules/系统模块中引入）</span><br><span class="line"><span class="number">2.</span>以’.’或’..’开头相对路径模块（相对当前目录引入）</span><br><span class="line"><span class="number">3.</span>绝对路径（例如/var/WWW等绝对路径）</span><br></pre></td></tr></table></figure>
<p>文件名的.js后缀可以省略。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Node</span>.<span class="title">js</span> 回调函数</span><br><span class="line"><span class="keyword">Node</span>.<span class="title">js</span> 异步编程的直接体现就是回调。</span><br></pre></td></tr></table></figure>
<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<p>回调函数一般作为函数的最后一个参数出现：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span><span class="params">(name, age, callback)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span><span class="params">(value, callback1, callback2)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p><b>阻塞代码实例</b><br>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hello</span> world！</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> fs = <span class="keyword">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = fs.readFileSync(<span class="string">'input.txt'</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">data</span>.toString());</span><br><span class="line">console.<span class="keyword">log</span>(<span class="string">"程序执行结束!"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">main</span>.js</span><br><span class="line">hello world！</span><br><span class="line">程序执行结束!</span><br></pre></td></tr></table></figure>
<p><b>非阻塞代码实例</b><br>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hello</span> world！</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束!"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">main</span>.js</span><br><span class="line">程序执行结束!</span><br><span class="line">hello world！</span><br></pre></td></tr></table></figure>
<p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>
<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>
<h2 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h2><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>
<p>Node 自带了交互式解释器，可以执行以下任务：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</span><br><span class="line"></span><br><span class="line">执行 - 执行输入的数据结构</span><br><span class="line"></span><br><span class="line">打印 - 输出结果</span><br><span class="line"></span><br><span class="line">循环 - 循环操作以上步骤直到用户两次按下 ctrl-<span class="keyword">c</span> 按钮退出。</span><br></pre></td></tr></table></figure>
<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>
<h3 id="开始学习-REPL"><a href="#开始学习-REPL" class="headerlink" title="开始学习 REPL"></a>开始学习 REPL</h3><p>我们可以输入以下命令来启动 Node 的终端：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>
<p>简单的表达式运算<br>接下来让我们在 Node.js REPL 的命令行窗口中执行简单的数学运算：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; <span class="number">1</span> +<span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt; <span class="number">5</span> / <span class="number">2</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line">&gt; <span class="number">3</span> * <span class="number">6</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt; <span class="number">4</span> - <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="number">1</span> + ( <span class="number">2</span> * <span class="number">3</span> ) - <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>可以将数据存储在变量中，并在你需要的时候使用它。</p>
<p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; <span class="symbol">x</span> = <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="keyword">var</span> <span class="symbol">y</span> = <span class="number">10</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="symbol">x</span> + <span class="symbol">y</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt; console.log(<span class="string">"Hello World"</span>)</span><br><span class="line">Hello World</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; console.log(<span class="string">"www.runoob.com"</span>)</span><br><span class="line">www.runoob.com</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h4><p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; <span class="keyword">var</span> <span class="symbol">x</span> = <span class="number">0</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="keyword">do</span> &#123;</span><br><span class="line">... <span class="symbol">x</span>++;</span><br><span class="line">... console.log(<span class="string">"x: "</span> + <span class="symbol">x</span>);</span><br><span class="line">... &#125; <span class="keyword">while</span> ( <span class="symbol">x</span> &lt; <span class="number">5</span> );</span><br><span class="line"><span class="symbol">x</span>: <span class="number">1</span></span><br><span class="line"><span class="symbol">x</span>: <span class="number">2</span></span><br><span class="line"><span class="symbol">x</span>: <span class="number">3</span></span><br><span class="line"><span class="symbol">x</span>: <span class="number">4</span></span><br><span class="line"><span class="symbol">x</span>: <span class="number">5</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<h4 id="下划线-变量"><a href="#下划线-变量" class="headerlink" title="下划线(_)变量"></a>下划线(_)变量</h4><p>可以使用下划线(_)获取上一个表达式的运算结果：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; <span class="keyword">var</span> <span class="symbol">x</span> = <span class="number">10</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="keyword">var</span> <span class="symbol">y</span> = <span class="number">20</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="symbol">x</span> + <span class="symbol">y</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">&gt; <span class="keyword">var</span> sum = _</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; console.log(sum)</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h4 id="REPL-命令"><a href="#REPL-命令" class="headerlink" title="REPL 命令"></a>REPL 命令</h4><ul>
<li>ctrl + c - 退出当前终端。</li>
<li>ctrl + c 按下两次 - 退出 Node REPL。</li>
<li>ctrl + d - 退出 Node REPL.</li>
<li>向上/向下 键 - 查看输入的历史命令</li>
<li>tab 键 - 列出当前命令</li>
<li>.help - 列出使用命令</li>
<li>.break - 退出多行表达式</li>
<li>.clear - 退出多行表达式</li>
<li>.save filename - 保存当前的 Node REPL 会话到指定文件</li>
<li>.load filename - 载入当前 Node REPL 会话的文件内容。</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Node.js(1)</category>
        <category>Node基础</category>
      </categories>
      <tags>
        <tag>Node.js(1)</tag>
        <tag>Node基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构1.04--递归</title>
    <url>/2019/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/</url>
    <content><![CDATA[<h1 id="数据结构与算法笔记（四）————递归"><a href="#数据结构与算法笔记（四）————递归" class="headerlink" title="数据结构与算法笔记（四）————递归"></a>数据结构与算法笔记（四）————递归</h1><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>只要同时满足以下三个条件，就可以用递归来解决。</p>
<ul>
<li>一个问题的解可以分解为几个子问题的解<br>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<a id="more"></a>
比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</li>
<li>存在递归终止条件<br>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</li>
</ul>
<h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。<br>假设递归为：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">f(<span class="name">n</span>) = f(<span class="name">n-1</span>)+f(<span class="name">n-2</span>)</span><br></pre></td></tr></table></figure>
<p>想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，这就是重复计算问题。为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。<br>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是O(1)，而是O(n)。</p>
<h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。<br>例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">int</span> ret = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"> ret = ret + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改写成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> n) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> <span class="built_in">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">int</span> pre = <span class="number">2</span>;</span><br><span class="line"> <span class="built_in">int</span> prepre = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"> ret = pre + prepre;</span><br><span class="line"> prepre = pre;</span><br><span class="line"> pre = ret;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构(1)</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构1.03--栈、队列</title>
    <url>/2019/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/</url>
    <content><![CDATA[<h1 id="数据结构与算法笔记（三）————栈、队列"><a href="#数据结构与算法笔记（三）————栈、队列" class="headerlink" title="数据结构与算法笔记（三）————栈、队列"></a>数据结构与算法笔记（三）————栈、队列</h1><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。那如何基于数组实现一个可以支持动态扩容的栈呢？<br>实现数组动态扩容时，当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。<br>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>
<a id="more"></a>
<p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了O(n)。</p>
<p>也就是说，对于入栈操作来说，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。那平均情况下的时间复杂度又是多少呢？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。<br>为了分析的方便，我们需要事先做一些假设和定义：<br>栈空间不够时，我们重新申请一个是原来大小两倍的数组；<br>为了简化分析，假设只有入栈操作没有出栈操作；<br>定义不涉及内存搬移的入栈操作为simple-push操作，时间复杂度为O(1)。<br>如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都只需要一个simple-push操作就可以完成。这K次入栈操作，总共涉及了K个数据的搬移，以及K次simple-push操作。将K个数据搬移均摊到K次入栈操作，那每个入栈操作只需要一个数据搬移和一个simple-push操作。以此类推，入栈操作的均摊时间复杂度就为O(1)。</p>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<p>栈在表达式求值中的应用<br>比如：<code>34+13*9+44-12/3</code>。对于这个四则运算，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。<br>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。<br>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h2 id="如何实现浏览器的前进和后退功能？"><a href="#如何实现浏览器的前进和后退功能？" class="headerlink" title="如何实现浏览器的前进和后退功能？"></a>如何实现浏览器的前进和后退功能？</h2><p>我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。<br>比如顺序查看了a，b，c三个页面，我们就依次把a，b，c压入栈，当通过浏览器的后退按钮，从页面c后退到页面a之后，我们就依次把c和b从栈X中弹出，并且依次放入到栈Y。这个时候又想看页面b，于是又点击前进按钮回到b页面，我们就把b再从栈Y中出栈，放入栈X中。这个时候，通过页面b又跳转到新的页面d了，页面c就无法再通过前进、后退按钮重复查看了，所以需要清空栈Y。</p>
<h2 id="队列在线程池等有限资源池中的应用"><a href="#队列在线程池等有限资源池中的应用" class="headerlink" title="队列在线程池等有限资源池中的应用"></a>队列在线程池等有限资源池中的应用</h2><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？<br>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？<br>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构(1)</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈、队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构1.02--链表</title>
    <url>/2019/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/</url>
    <content><![CDATA[<h1 id="数据结构与算法笔记（二）————链表"><a href="#数据结构与算法笔记（二）————链表" class="headerlink" title="数据结构与算法笔记（二）————链表"></a>数据结构与算法笔记（二）————链表</h1><h2 id="为何数组都从0开始编号"><a href="#为何数组都从0开始编号" class="headerlink" title="为何数组都从0开始编号"></a>为何数组都从0开始编号</h2><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式：<code>a[k]_address = base_address + k * type_size</code><br>但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：<code>a[k]_address = base_address + (k-1)*type_size</code>,对比两个公式不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p>
<a id="more"></a>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。<br>C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。实际上，很多语言中数组也并不是从0开始计数的，比如Matlab。甚至还有一些语言支持负数下标，比如Python。</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最<br>后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：<code>指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点</code>。<br>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。<br>但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。它像一个环一样首尾相连，所以叫作“循环”链表。<br>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内<br>存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。<br>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简<br>单、高效。</p>
<p>数组链表性能大比拼</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">时间复杂度	数组	链表</span><br><span class="line">插入删除	<span class="function"><span class="title">O</span>(<span class="variable">n</span>)	<span class="title">O</span>(<span class="number">1</span>)</span></span><br><span class="line">随机访问	<span class="function"><span class="title">O</span>(<span class="number">1</span>)	<span class="title">O</span>(<span class="variable">n</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="五种基本的单链表问题"><a href="#五种基本的单链表问题" class="headerlink" title="五种基本的单链表问题"></a>五种基本的单链表问题</h2><p>不管是哪一种链表问题，都最好画图来辅助理解。</p>
<h3 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h3><p>我学会的单链表反转用的方法是用三个指针，一个指针做prev前驱指针，一个指针指向头指针p，一个指针指向头指针的后继节点。思想就是这三个指针的相对位置不改变，一直从头结点往后移动，每移动一次都要改变它们的next后继节点的值，从而就改变了链表的指向，从而实现了链表的反转。<br>写的代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">function ReverseList(pHead)</span><br><span class="line">&#123;</span><br><span class="line">    var <span class="attribute">pre</span>=<span class="literal">null</span>,p=pHead,next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="attribute">next</span>=p.next;</span><br><span class="line">        p.<span class="attribute">next</span>=pre;</span><br><span class="line">        <span class="attribute">pre</span>=p;</span><br><span class="line">        <span class="attribute">p</span>=next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h3><p>这个问题的解决思想在于，用两个指针：快指针和慢指针，同时从头节点开始移动，直到它们重合的哪一个位置就是环的入口。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">huan</span><span class="params">(head)</span></span>&#123;</span><br><span class="line">	var p1=head.<span class="built_in">next</span>;//慢指针，一次走一步</span><br><span class="line">	var p2=head.<span class="built_in">next</span>.<span class="built_in">next</span>;//快指针，一次走两步</span><br><span class="line">	<span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">		p1=p1.<span class="built_in">next</span>;</span><br><span class="line">		p2=p2.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个有序的链表合并"><a href="#两个有序的链表合并" class="headerlink" title="两个有序的链表合并"></a>两个有序的链表合并</h3><p>两个有序的链表合并思想在于，我用另外一个链表来装合并后的链表，首先从两个链表的头节点开始比较大小，（如果从小到大排序）就将小的值存进新链表，并且原链表结点往后移动一位，再继续比较。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> hebing(pHead1,pHead2)&#123;</span><br><span class="line">	var result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (pHead1.<span class="keyword">val</span> &lt; pHead2.<span class="keyword">val</span>) &#123;</span><br><span class="line">        result = pHead1;</span><br><span class="line">        result.next = <span class="constructor">Merge(<span class="params">pHead1</span>.<span class="params">next</span>, <span class="params">pHead2</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = pHead2;</span><br><span class="line">        result.next = <span class="constructor">Merge(<span class="params">pHead1</span>, <span class="params">pHead2</span>.<span class="params">next</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表倒数第n个结点"><a href="#删除链表倒数第n个结点" class="headerlink" title="删除链表倒数第n个结点"></a>删除链表倒数第n个结点</h3><p>用两个指针之间的距离来表示倒数，直到最后一个指针指到末尾，这个时候的前指针指的就是倒数第你、个结点，倒数第n个结点，也就</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(</span>head,k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    var p1=head,p2=head;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.<span class="keyword">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">                p2=p2.<span class="keyword">next</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2.<span class="keyword">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">            p1=p1.<span class="keyword">next</span>;</span><br><span class="line">            p2=p2.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是借用数组来表示</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span><span class="params">(head,k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=[];</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        arr.push(head);</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len=arr.length;</span><br><span class="line">    <span class="keyword">return</span> arr[len-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求链表的中间结点"><a href="#求链表的中间结点" class="headerlink" title="求链表的中间结点"></a>求链表的中间结点</h3><p>这个也有一种巧妙的算法，也是用一个快慢指针来实现的，快指针一次走两步，慢指针一次走一步，那么在快指针走到链表末尾的时候，慢指针走的永远是快指针的一半，只是当链表节点个数是偶数的时候，指向的是中间偏后一个结点。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">function middle(head)&#123;</span><br><span class="line">	var p1=head,p2=head;</span><br><span class="line">	while(p2!=null)&#123;</span><br><span class="line">		p1=p1.next;</span><br><span class="line">		p2=p2.next;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">	return </span>p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然还可以用数组的方式来写</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middle</span><span class="params">(head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr=[];</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		arr.push(head);</span><br><span class="line">		head=head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> len=arr.length;</span><br><span class="line">	<span class="keyword">return</span> arr[length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构(1)</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构1.01--复杂度</title>
    <url>/2019/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401/</url>
    <content><![CDATA[<h1 id="数据结构与算法笔记（一）————复杂度"><a href="#数据结构与算法笔记（一）————复杂度" class="headerlink" title="数据结构与算法笔记（一）————复杂度"></a>数据结构与算法笔记（一）————复杂度</h1><h2 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h2><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。<br>图书馆储藏书籍，为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。<br>从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。</p>
<a id="more"></a>
<p>那数据结构和算法有什么关系呢？数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。<br>比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。<br>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。<br>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量<br>指标。那如何来衡量编写的算法代码的执行效率呢？时间、空间复杂度分析。</p>
<h3 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h3><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。<br>例如：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">int</span> cal(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"> <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"> for (; i &lt;= <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"> <span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line"> return <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略估计，所以可以假设每行代码执行的时间都一样，为unit_time。在这个假设的基础之上，第2、3行代码分别需要1个unit_time的执行时间，第4、5行都运行了n遍，所以需要2nunit_time的执行时间，所以这段代码总的执行时间就是(2n+2)unit_time。可 以看出来，所有代码的执行时间T(n)与每行代码的执行次数成正比。<br>再例如：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> cal(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>；</span><br><span class="line"><span class="built_in">int</span> j=<span class="number">1</span>；</span><br><span class="line"> for (; j &lt;= <span class="built_in">n</span>; ++j) &#123;</span><br><span class="line"> j = <span class="number">1</span>;</span><br><span class="line"> for (; i &lt;= <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">sum</span>=<span class="built_in">sum</span>+i*j；</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们依旧假设每个语句的执行时间是unit_time。<br>第2、3、4行代码，每行都需要1个unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n * unit_time的执行时间，第7、8行代码循环执行了n2遍，所以需要2n2 * unit_time的执行时间。所以，整段代码总的执行时间T(n) = (2n2+2n+3) * unit_time。<br>尽管不知道unit_time的具体值，但是通过这两段代码执行时间的推导过程，可以得到一个非常重要的规律，那就是，所有代码的执行时间T(n)与每行代码<br>的执行次数n成正比。<br>第一个例子中的T(n) = O(2n+2)，第二个例子中的T(n) = O(2n2+2n+3)。这就是大O时间复杂度表示法。<br>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。<br>当n很大时，可以把它想象成10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以<br>了，如果用大O表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>如何分析一段代码的时间复杂度？</p>
<h4 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h4><p>大O这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我<br>们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码<br>的时间复杂度。</p>
<p>分析：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">int</span> cal(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"> <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"> for (; i &lt;= <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"> <span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line"> return <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p>
<h4 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> cal(<span class="built_in">int</span> n) &#123;</span><br><span class="line">&#125;</span><br><span class="line">sum_1 = sum_1 + p;</span><br><span class="line"><span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">sum_2 = sum_2 + q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line"><span class="built_in">int</span> q = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">sum_3 = sum_3 + i * j;</span><br><span class="line"><span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">j = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br></pre></td></tr></table></figure>
<p>这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码<br>的复杂度。<br>第一段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽<br>管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。<br>那第二段代码和第三段代码的时间复杂度是O(n)和O(n2)。<br>综合这三段代码的时间复杂度，取其中最大的量级。所以，整段代码的时间复杂度就为O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间<br>复杂度。那将这个规律抽象成公式就是：<br>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么<code>T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</code></p>
<h4 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">如果<span class="constructor">T1(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">f</span>(<span class="params">n</span>)</span>)，<span class="constructor">T2(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">g</span>(<span class="params">n</span>)</span>)；那么<span class="constructor">T(<span class="params">n</span>)</span>=<span class="constructor">T1(<span class="params">n</span>)</span>*<span class="constructor">T2(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">f</span>(<span class="params">n</span>)</span>)*<span class="constructor">O(<span class="params">g</span>(<span class="params">n</span>)</span>)=<span class="constructor">O(<span class="params">f</span>(<span class="params">n</span>)</span>*g(n)).</span><br></pre></td></tr></table></figure>
<p>也就是说，假设<code>T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。</code><br>落实到具体的代码上，可以把乘法法则看成是嵌套循环。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ret = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">int</span> cal(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">ret = ret + f(i);</span><br><span class="line">for (; i &lt; <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line">for (; i &lt; <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">return <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) =O(n)，所以，整个cal()函数的时间复杂度就是，<code>T(n) = T1(n) * T2(n) = O(n * n) = O(n2)。</code></p>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><ul>
<li><p>O(1)<br>O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是O(1），而不是O(3)。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int j</span> = 6;</span><br><span class="line"><span class="attribute">int sum</span> = i + j;</span><br><span class="line"><span class="attribute">int i</span> = 8;</span><br></pre></td></tr></table></figure>
<p>总结一下，只要代码的执行时间不随n的增大而增长，这样代码的时间复杂度我们都记作O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
</li>
<li><p>O(logn)、O(nlogn)<br>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= n) &#123;</span><br><span class="line"><span class="built_in">i</span> = <span class="built_in">i</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。<br>从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2。当大于n时，循环结束。还实际上，变量i的取值就是一个等比数列。如果我把它一个一个列出来:2^0+2^1+2^2+….+2^x=n;<br>通过2x=n求解x,x=log2n，所以，这段代码的时间复杂度就是O(log2n)。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= n) &#123;</span><br><span class="line"><span class="built_in">i</span> = <span class="built_in">i</span> * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的时间复杂度为O(log3n)。<br>实际上，不管是以2为底、以3为底，还是以10为底，可以把所有对数阶的时间复杂度都记为O(logn)。<br>因为对数之间是可以互相转换的，log3n就等于<code>log32 * log2n，所以O(log3n) = O(C * log2n)</code>，其中C=log32是一个常量。基于前面的一个理论：在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。<br>如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。而且，O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)。</p>
</li>
<li><p>O(m+n)、O(m * n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">int</span> cal(<span class="built_in">int</span> m, <span class="built_in">int</span> n) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> sum_1 = sum_1 + i;</span><br><span class="line"> <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line"> <span class="built_in">int</span> j = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> sum_2 = sum_2 + j;</span><br><span class="line"> <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line"> <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。<br>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：<code>T1(m) + T2(n) = O(f(m) + g(n))</code>。但是乘法法则继续有效：<code>T1(m)*T2(n) = O(f(m) * f(n))</code>。</p>
</li>
</ul>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> void print(int n) &#123;</span><br><span class="line"> int[] a = new int[n];</span><br><span class="line"> int <span class="built_in">i</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">i</span>; <span class="built_in">i</span> &lt;n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line"> a[<span class="built_in">i</span>] = <span class="built_in">i</span> * <span class="built_in">i</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">i</span> = n<span class="number">-1</span>; <span class="built_in">i</span> &gt;= <span class="number">0</span>; --<span class="built_in">i</span>) &#123;</span><br><span class="line">  print out a[<span class="built_in">i</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟时间复杂度分析一样，我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申<br>请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。<br>常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构(1)</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>js零散笔记03</title>
    <url>/2019/03/15/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<h1 id="JavaScript个人零散笔记（三）"><a href="#JavaScript个人零散笔记（三）" class="headerlink" title="JavaScript个人零散笔记（三）"></a>JavaScript个人零散笔记（三）</h1><h2 id="DOM的样式编程"><a href="#DOM的样式编程" class="headerlink" title="DOM的样式编程"></a>DOM的样式编程</h2><p>对于样式编程的理解就是通过JavaScript来操作页面HTML元素的样式，来改变页面的一些显示效果，例如页面的隐藏显示效果、旋转效果等</p>
<h3 id="className属性"><a href="#className属性" class="headerlink" title="className属性"></a>className属性</h3><p>className属性可以用来读取或设置HTML元素对象的class属性。当将className属性设置为空时，代表一处所有的样式。</p>
<a id="more"></a>

<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">obj.<span class="built_in">className</span>=<span class="string">"style"</span>;<span class="comment">//添加样式</span></span><br><span class="line">obj.<span class="built_in">className</span>=<span class="string">""</span>；<span class="comment">//移除所有样式</span></span><br><span class="line">obj.<span class="built_in">className</span>;<span class="comment">//读取样式</span></span><br></pre></td></tr></table></figure>
<h3 id="classList对象"><a href="#classList对象" class="headerlink" title="classList对象"></a>classList对象</h3><p>className属性比较简单，但如果HTML元素对象的class属性值中有多个样式类应用时，对其样式控制就不太方便，例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"mydiv"</span> <span class="built_in">class</span>=<span class="string">"style1 style2 style3"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，在HTML5API中，页面DOM里的每个节点上都有一个classList对象，提供了新增、是你出、修改节点的样式类。</p>
<p>方法    具体描述</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">length	返回HTML元素对象<span class="keyword">class</span>属性中样式类的个数</span><br><span class="line"><span class="symbol">add</span>(<span class="symbol">className</span>)	给<span class="symbol">HTML</span>元素对象的<span class="symbol">class</span>属性添加一个样式类</span><br><span class="line"><span class="symbol">remove</span>(<span class="symbol">className</span>)	从<span class="symbol">HTML</span>元素对象的<span class="symbol">class</span>属性中删除一个指定的样式类</span><br><span class="line"><span class="symbol">toggle</span>（<span class="symbol">className</span>）	若<span class="symbol">HTML</span>元素对象的<span class="symbol">class</span>属性有指定的样式类，则执行<span class="symbol">remove</span>操作，没有则执行<span class="symbol">add</span>操作</span><br><span class="line"><span class="symbol">contains</span>(<span class="symbol">className</span>)	检测<span class="symbol">HTML</span>元素对象的<span class="symbol">class</span>属性中是否包含指定的样式类</span><br></pre></td></tr></table></figure>
<p>应用时举例：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.classList</span><span class="selector-class">.lenght</span>;<span class="comment">//样式类长度</span></span><br><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.classList</span><span class="selector-class">.add</span>(<span class="string">"style1"</span>);<span class="comment">//添加style1样式</span></span><br><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.classList</span><span class="selector-class">.contains</span>(<span class="string">"style1"</span>);<span class="comment">//包含style1样式类吗</span></span><br><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.classList</span><span class="selector-class">.remove</span>(<span class="string">"style1"</span>);<span class="comment">//删除style1样式类</span></span><br><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.classList</span><span class="selector-class">.toggle</span>(<span class="string">"style1"</span>);<span class="comment">//有style1样式类就删除，没有就添加</span></span><br></pre></td></tr></table></figure>
<h3 id="style对象"><a href="#style对象" class="headerlink" title="style对象"></a>style对象</h3><p>使用className和classList对象已经可以很方便的修改HTML元素对象的样式，但这种方式只适合于央视的值是固定不变的，如果央视的值需要引入变量形式，则必须借助于每个HTML元素对象的上腾娱乐对象，用它来访问HTML元素对象的样式信息。<br>style对象包含了与每个css属性对应的属性，只是格式略有不同：</p>
<p>对于单个单词的css样式，以相同名字属性来表示（例如：color样式通过style.color表示）<br>对于两个单词的CSS样式，则是通过取出横杠，将第一个单词加上首字母大写的第二个单词（例如：background-color样式对应style.backgroundColor）<br>举例如下</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">CSS样式	<span class="built_in">style</span>中的属性</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">color</span>	<span class="built_in">style</span>.backgroundColor</span><br><span class="line"><span class="built_in">color</span>	<span class="built_in">style</span>.<span class="built_in">color</span></span><br><span class="line"><span class="built_in">font</span>	<span class="built_in">style</span>.<span class="built_in">font</span></span><br><span class="line"><span class="built_in">font</span>-family	<span class="built_in">style</span>.fontFamily</span><br><span class="line"><span class="built_in">font</span>-weight	<span class="built_in">style</span>.fontWeight</span><br></pre></td></tr></table></figure>
<p>使用style对象可以方便的获取HTML元素对象的style属性定义的css央视之，但它无法获取在外部定义的CSS样式。<br>使用style对象设置样式时，实际就是修改HTML元素对象的style属性。</p>
<h2 id="浏览器私有前缀的属性的调用"><a href="#浏览器私有前缀的属性的调用" class="headerlink" title="浏览器私有前缀的属性的调用"></a>浏览器私有前缀的属性的调用</h2><p>对于带有浏览器私有前缀的调用跟带有两个单词的样式属性调用不一样的是，该调用方法会使第一个单词都是首字母大写，也就是每一个单词都是首字母大写，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">obj.style.MozUserSelect</span>=<span class="string">"none"</span>；//表示的是调用css中的-moz-user-select属性</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>js零散笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>js零散笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js零散笔记02</title>
    <url>/2019/03/14/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="JavaScript个人零散笔记（二）"><a href="#JavaScript个人零散笔记（二）" class="headerlink" title="JavaScript个人零散笔记（二）"></a>JavaScript个人零散笔记（二）</h1><h2 id="JavaScript-弹窗"><a href="#JavaScript-弹窗" class="headerlink" title="JavaScript 弹窗"></a>JavaScript 弹窗</h2><p>可以在 JavaScript 中创建三种消息框：<code>警告框、确认框、提示框</code>。</p>
<h3 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h3><p>警告框经常用于确保用户可以得到某些信息。<br>当警告框出现后，用户需要点击确定按钮才能继续进行操作。<br>语法</p>
<a id="more"></a>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"sometext"</span>);</span><br><span class="line"><span class="built_in">window</span>.alert() 方法可以不带上<span class="built_in">window</span>对象，直接使用alert()方法。</span><br></pre></td></tr></table></figure>
<h3 id="确认框"><a href="#确认框" class="headerlink" title="确认框"></a>确认框</h3><p>确认框通常用于验证是否接受用户操作。<br>当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。<br>当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false。<br>语法</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">window</span>.<span class="keyword">confirm</span>(<span class="string">"sometext"</span>);</span><br><span class="line"><span class="keyword">window</span>.<span class="keyword">confirm</span>() 方法可以不带上<span class="keyword">window</span>对象，直接使用<span class="keyword">confirm</span>()方法。</span><br></pre></td></tr></table></figure>
<h3 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h3><p>提示框经常用于提示用户在进入页面前输入某个值。<br>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。<br>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。<br>语法</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.prompt(<span class="string">"sometext"</span>,<span class="string">"defaultvalue"</span>);</span><br><span class="line"><span class="built_in">window</span>.prompt() 方法可以不带上<span class="built_in">window</span>对象，直接使用prompt()方法。</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-计时事件"><a href="#JavaScript-计时事件" class="headerlink" title="JavaScript 计时事件"></a>JavaScript 计时事件</h2><p>通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。<br>在 JavaScritp 中使用计时事件是很容易的，两个关键方法是:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setInterval</span><span class="params">()</span></span> - 间隔指定的毫秒数不停地执行指定的代码。</span><br><span class="line"><span class="function"><span class="title">setTimeout</span><span class="params">()</span></span> - 暂停指定的毫秒数后执行指定的代码</span><br></pre></td></tr></table></figure>
<p>Note: setInterval() 和 setTimeout() 是 HTML DOM Window对象的两个方法。</p>
<h3 id="setInterval-方法"><a href="#setInterval-方法" class="headerlink" title="setInterval() 方法"></a>setInterval() 方法</h3><p>setInterval() 间隔指定的毫秒数不停地执行指定的代码<br>语法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.set<span class="constructor">Interval(<span class="string">"javascript function"</span>,<span class="params">milliseconds</span>)</span>;</span><br><span class="line">window.set<span class="constructor">Interval()</span> 方法可以不使用window前缀，直接使用函数set<span class="constructor">Interval()</span>。</span><br><span class="line">set<span class="constructor">Interval()</span> 第一个参数是函数（<span class="keyword">function</span>）。</span><br></pre></td></tr></table></figure>
<p>第二个参数间隔的毫秒数<br>注意: 1000 毫秒是一秒。<br>实例<br>每三秒弹出 “hello” ：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">setInterval(<span class="name">function</span>()&#123;alert(<span class="string">"Hello"</span>)&#125;,<span class="number">3000</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以下实例将显示当前时间。 setInterval() 方法设置每秒钟执行一次代码，就是和手表一样。<br>实例<br>显示当前时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;myTimer()&#125;,<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTimer</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">var</span> d=<span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line"><span class="keyword">var</span> t=d.toLocaleTimeString(); </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何停止执行?<br>clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。<br>语法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.clear<span class="constructor">Interval(<span class="params">intervalVariable</span>)</span></span><br><span class="line">window.clear<span class="constructor">Interval()</span> 方法可以不使用window前缀，直接使用函数clear<span class="constructor">Interval()</span>。</span><br></pre></td></tr></table></figure>
<p>要使用 clearInterval() 方法, 在创建计时方法时你必须使用全局变量：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">myVar</span>=setInterval(<span class="string">"javascript function"</span>,milliseconds)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后你可以使用clearInterval() 方法来停止执行。<br>实例<br>以下例子,我们添加了 “Stop time” 按钮：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"myStopFunction()"</span>&gt;</span>Stop time<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> myVar=setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;myTimer()&#125;,<span class="number">1000</span>); </span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">myTimer</span><span class="params">()</span> </span></span></span><br><span class="line">&#123; </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d=<span class="keyword">new</span> <span class="built_in">Date</span>(); </span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> t=d.toLocaleTimeString(); </span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=t; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">myStopFunction</span><span class="params">()</span> </span></span></span><br><span class="line">&#123; </span><br><span class="line">clearInterval(myVar); </span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="setTimeout-方法"><a href="#setTimeout-方法" class="headerlink" title="setTimeout() 方法"></a>setTimeout() 方法</h3><p>语法</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">window.<span class="built_in">setTimeout</span>(<span class="string">"javascript 函数"</span>,毫秒数);</span><br></pre></td></tr></table></figure>
<p>setTimeout() 方法会返回某个值。在上面的语句中，值被储存在名为 t 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。<br>setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 “alert(‘5 seconds!’)”，或者对函数的调用，诸如”alertMsg()”。<br>第二个参数指示从当前起多少毫秒后执行第一个参数。<br>提示：1000 毫秒等于一秒。<br>实例<br>等待3秒，然后弹出 “Hello”:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="name">function</span>()&#123;alert(<span class="string">"Hello"</span>)&#125;,<span class="number">3000</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如何停止执行?<br>clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。<br>语法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.clear<span class="constructor">Timeout(<span class="params">timeoutVariable</span>)</span></span><br></pre></td></tr></table></figure>
<p>window.clearTimeout() 方法可以不使用window 前缀。<br>要使用clearTimeout() 方法, 你必须在创建超时方法中（setTimeout）使用全局变量:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">myVar</span>=setTimeout(<span class="string">"javascript function"</span>,milliseconds)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果函数还未被执行，你可以使用 clearTimeout() 方法来停止执行函数代码。<br>实例<br>以下是同一个实例, 但是添加了 “Stop the alert” 按钮:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">myVar=setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;alert(<span class="string">"Hello"</span>)&#125;,<span class="number">3000</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myStopFunction</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">clearTimeout(myVar); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="什么是-Cookies？"><a href="#什么是-Cookies？" class="headerlink" title="什么是 Cookies？"></a>什么是 Cookies？</h2><p>Cookies 是一些数据, 存储于你电脑上的文本文件中。<br>当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。<br>Cookies 的作用就是用于解决 “如何记录客户端的用户信息”:</p>
<p>当用户访问 web 页面时，他的名字可以记录在 cookie 中。<br>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。<br>Cookies 以名/值对形式存储，如下所示: username=John Doe 当浏览器从服务器上请求 web 页面时， 属于该页面的 cookies 会被添加到该请求中。服务端通过这种方式来获取用户的信息。<br>CSS3相同的地方<br>JavaScript中表单填写和css3相同的地方:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">css3用placeholder：“默认样式显示文本”，用<span class="keyword">required</span>属性：<span class="keyword">required</span> aria-<span class="keyword">required</span>=“<span class="literal">true</span>”；来表明该表单为必填项。</span><br><span class="line">autofocus属性可以让表单在加载完成时就有一个表单域被默认聚焦，以便用户输入。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>js零散笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>js零散笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js零散笔记01</title>
    <url>/2019/03/13/js%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="JavaScript个人零散笔记（一）"><a href="#JavaScript个人零散笔记（一）" class="headerlink" title="JavaScript个人零散笔记（一）"></a>JavaScript个人零散笔记（一）</h1><h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><p>三种原始类型：<code>数值（Number）、字符串（String）、布尔值（Boolean）</code><br>typeof运算符：</p>
<ul>
<li>原始类型：数值、字符串、布尔值分别返回number、string、boolean。<a id="more"></a></li>
<li>函数返回function</li>
<li>undefined返回undefined</li>
<li>除此之外其余全部返回object：数组、null、对象</li>
</ul>
<p>instanceof运算符：主要用来检测引用类型。typeof用来检测基本数据类型</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>查看对象所有属性：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line"><span class="type">name</span>："a"；</span><br><span class="line">age：<span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Object</span>.keys（o）//["name","age"]</span><br></pre></td></tr></table></figure>
<p>返回的是一个数组。</p>
<p>删除属性delete</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">name："a"；</span></span><br><span class="line"><span class="comment">age：12</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">delete o.<span class="keyword">name</span></span><br><span class="line">o.<span class="keyword">name</span> <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>delete只能删除自有属性，不能删除继承属性。删除一个不存在的属性，delete不报错，而且返回true。只有一种情况delete命令会返回false，那就是该属性存在且不能删除。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="string">'a'</span>,&#123;name:<span class="string">'a'</span>&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;];</span><br></pre></td></tr></table></figure>
<p>数组属于一种特殊的对象。用typeof检测是返回object。<br>length属性是可写的。如果认为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</p>
<p>将数组清空的一个有效办法就是讲length属性设为0。<br>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr=[<span class="number">1</span>];</span><br><span class="line">arr.length=<span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>]<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的添加和删除"><a href="#数组的添加和删除" class="headerlink" title="数组的添加和删除"></a>数组的添加和删除</h3><ul>
<li>push()方法是在数组末尾添加一个或多个元素；</li>
<li>pop()方法是在数组末尾删除元素。</li>
<li>unshift()方法是在数组头部添加元素</li>
<li>shift()方法是在删除数组的第一个元素。</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   </span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (i &lt; a.length) &#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);   </span><br><span class="line">  i++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for..in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach</span></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="number">0</span>]  <span class="comment">// "a"</span></span><br><span class="line">o[<span class="number">1</span>]  <span class="comment">// "b"</span></span><br><span class="line">o.length <span class="comment">// 2</span></span><br><span class="line">o.push(<span class="string">'d'</span>) <span class="comment">// TypeError: o.push is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量o是一个对象，虽然使用的时候看上去跟数组很像，但是无法使用数组的方法。这就是类数组对象。</p>
<p>类数组对象有一个特征，就是具有length属性。换句话说，只要有length属性，就可以认为这个对象类似于数组。但是，对象的length属性不是动态值，不会随着成员的变化而变化。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数就是一段可以反复调用的代码块。</p>
<p>函数使用function关键字来定义，还包括一个称为形参（parameter）的标识符列表，这些参数在函数体内像局部变量一样工作。</p>
<p>函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。</p>
<p>除了实参之外，每次调用还会拥有另一个值—本次调用的上下文—这就是this关键字的值。</p>
<p>如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。</p>
<p>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment"> console.log(a)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span>  <span class="comment">//1</span></span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，函数f内部可以读取全局变量a。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v  <span class="comment">//ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  var a=2;</span></span></span><br><span class="line"><span class="function"><span class="comment">  console.log(a);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span>  <span class="comment">//2</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>  <span class="comment">//1</span></span></span><br></pre></td></tr></table></figure>
<p>注意：对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。<br>函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</p>
<h2 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h2><p>eval命令的作用是，将字符串当作语句执行。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eval<span class="comment">('var a=1')</span>;</span><br><span class="line">a  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>eval没有自己的作用域，都在当前作用域内执行</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">function</span>()&#123;</span><br><span class="line">  <span class="symbol">'use</span> strict'<span class="comment">;</span></span><br><span class="line">  eval(<span class="symbol">'var</span> a=1')<span class="comment">;</span></span><br><span class="line">  console.log(<span class="name">a</span>)<span class="comment">;  //ReferenceError: a is not defined</span></span><br><span class="line">&#125;)()<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>js零散笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>js零散笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery06--jQuery AJAX</title>
    <url>/2019/03/13/jQuery06/</url>
    <content><![CDATA[<h1 id="jQuery-AJAX技术学习笔记"><a href="#jQuery-AJAX技术学习笔记" class="headerlink" title="jQuery AJAX技术学习笔记"></a>jQuery AJAX技术学习笔记</h1><h2 id="jQuery-AJAX技术"><a href="#jQuery-AJAX技术" class="headerlink" title="jQuery AJAX技术"></a>jQuery AJAX技术</h2><h3 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h3><p>AJAX是英文词组Asynchronous JavaScrip and XML的首字母缩写。<br>是一种可以和服务器异步交互数据的网页开发技术。使用AJAX技术可以再不重新加载整个页面的前提下，直接更新当前页面中的指定内容。<br>AJAX是由多种当前主流的技术组合而成，包含如下内容</p>
<a id="more"></a>
<ul>
<li>使用XTHML和CSS进行标准化表达</li>
<li>使用DOM实现动态展示和交互。</li>
<li>使用XMLHttpRequest实现异步数据获取。</li>
<li>使用JavaScript绑定所有技术综合应用。</li>
</ul>
<h3 id="AJAX-常用方法"><a href="#AJAX-常用方法" class="headerlink" title="AJAX 常用方法"></a>AJAX 常用方法</h3><p><b>load（）</b><br>该方法可以向服务器端发送数据获取请求，并将已获取到的数据加载到指定的HTML元素中，语法格式为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">$（selector）.load（<span class="type">URL</span>，［<span class="class"><span class="keyword">data</span> ］［，callback］）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>URL：该参数用于规定需要获取数据的URL地址，可以是文本、XML、JSON数据</li>
<li>data：该参数用于规定与请求一起发送给服务器的字符串，该字符串以键/对结合的形式组成。</li>
<li>callback：该参数用于规定load（）方法完成后需要执行的函数。<br>1、常规使用<br>例如将文件test.txt的内容加载到id=“demo”的段落元素中<code>$（“#demo”）.load（“test.txt”）；</code><br>jQuery将使用.innerHTML属性将指定元素中的所有内容更新为test.txt的文本内容。如果只需要加载的文件中的某个HTML元素，则可以在URL参数中追加选择器，来筛选需要加载的元素。<br>例如<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$（“#<span class="built_in">demo</span>”）.<span class="built_in">load</span>（“test.txt div.<span class="built_in">style</span>”）；</span><br></pre></td></tr></table></figure>
表示将test.txt中的class=“style”的元素加载到id=“demo”的段落元素中。<br>需要注意的是，以上两种情况的选择器都必须是在网页文档中实际存在的HTML元素，否则请求将不会被发出。</li>
</ul>
<p>2、回调函数的使用<br>该方法中的可选参数callback 规定的数据下载完成后需要执行的回调函数，该函数包含三个参数，语法格式为</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$（selector）.<span class="built_in">load</span>（<span class="built_in">URL</span>，［data］，<span class="function"><span class="keyword">function</span>（<span class="title">response</span>，<span class="title">status</span>，<span class="title">xhr</span>）&#123;</span></span><br><span class="line">//回调函数内部代码</span><br><span class="line">&#125;）；</span><br></pre></td></tr></table></figure>
<ul>
<li>response：该参数为调用成功时的结果内容。</li>
<li>status：该参数为调用的状态。例如“success”或“error”等</li>
<li>xhr：该参数表示XMLHttpRequest对象</li>
</ul>
<h3 id="jQuery-AJAX-get（）方法"><a href="#jQuery-AJAX-get（）方法" class="headerlink" title="jQuery AJAX get（）方法"></a>jQuery AJAX get（）方法</h3><p>该方法用于通过HTTP GET请求从服务器端获取数据，语法格式为</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$（selector）.get（<span class="type">URL</span>，［data］，［success］，［data<span class="keyword">type</span>］）；</span><br></pre></td></tr></table></figure>
<ul>
<li>URL：该参数用于规定请求的URL地址</li>
<li>data：刚才说，用于规定于请求一起发送给服务器的字符串，该字符串以键/值结合的形式组成。</li>
<li>success：该参数用于规定请求成功后需要执行的函数，如果没有该参数，这返回的数据将被忽略。</li>
<li>datatype：该参数用于规定从服务器端获取的数据类型。例如XML、JSON、HTML等<br>如果没有数据需要发送给服务器，也无需处理获取的数据，可以只使用参数URL。<br>例如<code>$.get（“demo.php”）；</code><br>表示向demo.php请求数据，但是获取到的数据将被忽略，不做任何处理。</li>
</ul>
<h3 id="jQuery-AJAX-post（）方法"><a href="#jQuery-AJAX-post（）方法" class="headerlink" title="jQuery AJAX post（）方法"></a>jQuery AJAX post（）方法</h3><p>该方法通过HTTP POST 请求从服务器端获取数据，语法格式为</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$（selector）.post（<span class="type">URL</span>，［data］，［success］，［data<span class="keyword">type</span>］）；</span><br></pre></td></tr></table></figure>
<p>参数同上<br>post（）与get（）方法的区别在于请求方式不同，而代码格式基本一致，因此这里不再去更多的例子。在实际开发中，如果只是获取数据或查询结果，建议使用get（）方法。如果需要更新资源信息，建议使用post（）方法。还可以根据以下两点考虑选用post（）还是get（）</p>
<p>HTTP GET请求只能向服务器发送1024字节的数据；HTTP POST请求可以向服务器发送大量数据（理论上无限制根据浏览器的类型上限稍微有不同）。<br>HTTP GET请求提交的数据将明文显示在URL上；通过HTTP POST（）请求提交的数据会被放在HTTP包的包体中，更为安全。<br>AJAX ajax（）方法<br>该方法是最为完整的AJAX请求方法，包含了一系列参数的配置，可供开发者自定义更为灵活的个性化要求。事实上load（）、get（）、post（）方法均为ajax（）方法的简化版，当简化版无法解决某些设置要求的时候可以选择使用ajax（）方法。<br>语法格式为</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">$.ajax（&#123;</span><br><span class="line"><span class="built_in">na</span><span class="symbol">me1:va</span>lue1；</span><br><span class="line"><span class="built_in">na</span><span class="symbol">me2:va</span>lue2；</span><br><span class="line">…</span><br><span class="line">nameN：<span class="built_in">value</span> Ｎ</span><br><span class="line">&#125;</span><br><span class="line">）；</span><br></pre></td></tr></table></figure>
<p>该方法内部有一个或多个名称/值组成，这些参数的数量、顺序以及值均可以由开发者根据实际开发需求自定义。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery05--jQuery遍历</title>
    <url>/2019/03/12/jQuery05/</url>
    <content><![CDATA[<h1 id="jQuery遍历学习笔记"><a href="#jQuery遍历学习笔记" class="headerlink" title="jQuery遍历学习笔记"></a>jQuery遍历学习笔记</h1><h2 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h2><h3 id="jQuery后代遍历"><a href="#jQuery后代遍历" class="headerlink" title="jQuery后代遍历"></a>jQuery后代遍历</h3><ul>
<li><p>jQuery children（）<br>该方法只能查找指定元素的第一层子元素，语法结构<code>.children（［selector］）</code><br>selector参数为可选内容，用于进一步筛选需要匹配的子元素。如果不填写任何参数，则表示查找所有的子元素。<br>例如<code>$（“p”）.children（）</code><br>表示查找页面上所有段落元素&lt;\p&gt;的子元素。</p>
<a id="more"></a>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$（“p”）<span class="string">.children</span>（“<span class="string">.style</span>”）</span><br></pre></td></tr></table></figure>
<p>表示查找页面上所有段落元素&lt;\p&gt;中class=“style”的子元素。</p>
</li>
<li><p>jQuery find（）<br>该方法可用于查找指定元素的所有后代元素，语法结构为<code>.find（selector）</code><br>可以进一步筛选需要匹配的元素，例如<code>$（“p”）.find（“span”）</code><br>表示在段落元素&lt;\p&gt;中找到所有的&lt;\span&gt;元素。<br>selector参数位置也可以填入元素对象，例如上述代码可以改写为以下</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">var spans=<span class="variable">$（</span>“span”）；</span><br><span class="line"><span class="variable">$（</span>“p”）.find（spans）；</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="jQuery同胞遍历"><a href="#jQuery同胞遍历" class="headerlink" title="jQuery同胞遍历"></a>jQuery同胞遍历</h3><p>同胞遍历指的是以指定元素为出发点，遍历与该元素具有相同，父元素的同胞元素，直到全部查找完毕。</p>
<p><b>jQuery siblings（）</b><br>该方法可以查找指定元素的所有同胞元素，语法结构为<code>.siblings（［selector］）</code><br>可以通过改变参数的值进一步筛选，需要匹配的同胞元素，如果不填写任何参数则表示查找所有的同胞元素，比如<code>$（“p”）.siblings（）</code><br>表示查找段落元素&lt;\p&gt;的所有同胞元素。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$（“p”）<span class="string">.siblings</span>（“<span class="string">.style</span>”）</span><br></pre></td></tr></table></figure>
<p>该代码表示查找所有与段落元素&lt;\p&gt;具有相同的父元素并且class=“style”的元素</p>
<p><b>jQuery next（）、nextAll（）和nextUntil（）</b></p>
<ul>
<li><p>next（）该方法可以查找指定元素的下一个同胞元素，语法结构为<code>.next（［selector ］）</code>可以通过改变参数的词进一步筛选需要匹配的同胞元素，如果不填写任何参数则表示查找指定元素的下一个同胞元素。例如<code>$（“p”）.next（）</code>该代码表示，查找段落元素的下一个同胞元素。如果加上参数可以进一步匹配同胞元素，例如<code>$（“p”）.next（“.style”）</code>表示查找段落元素的下一个同胞元素，并且该元素必须带有class=style属性的元素。</p>
</li>
<li><p>nextAll（）<br>该方法可以查找指定元素后面的所有同胞元素，语法结构<code>.nextAll（［selector ］）</code>参数的意义和选取同上。</p>
</li>
<li><p>nextUntil（）<br>该方法可以查找从指定元素开始往后水平遍历，直到指定元素结束的所有同胞元素，不包括作为结束标识的元素本身，语法结构为<code>.nextUntil（［selector ］［filter］）</code>selector 参数意义和选取同上。filter参数表示进一步筛选指定范围内的同胞元素。</p>
</li>
</ul>
<p><b>jQuery prev（）、prevAll（）、prevUntil（）</b></p>
<ul>
<li><p>prev（）该方法可以查找指定元素的前一个同胞元素，语法结构为<code>.prev（［selector ］）</code>参数选取和意义和next（）同</p>
</li>
<li><p>prevAll（）<br>该方法可以查找指定元素前面的所有同胞元素，语法结构为<code>.prevAll（［selector ］）</code>参数选取和意义和nextAll（）同。<br>该方法可以查找从指定元素开始往前水平遍历直到指定元素结束的所有同胞元素，不包括作为结束标识的元素本身，语法结构为<code>.prevUntil（［selector ］［filter］）</code>参数选取和意义同nextUntill（）。</p>
</li>
</ul>
<h3 id="jQuery祖先遍历"><a href="#jQuery祖先遍历" class="headerlink" title="jQuery祖先遍历"></a>jQuery祖先遍历</h3><p>祖先遍历指的是以指定元素为出发点遍历该元素的父、祖父、曾祖父元素等，直到全部查找完毕。</p>
<p><b>jQuery parent（）</b><br>该方法可以查找指定元素的直接父元素，语法结构<code>.parent（［selector ］）</code>参数选取和意义同上。</p>
<p><b>jQuery parents（）</b><br>该方法可以查找指定元素的所有祖先元素，语法结构为<code>.parents（［selector ］）</code>参数选取和意义同上。</p>
<p><b> jQuery parentsUntil（）</b><br>该方法可以查找指定元素的所有祖先元素，语法结构为<code>.parentsUntil（［selector ］［filter］）</code>参数选取和意义同上。</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>jQuery提供了一个each方法，使用它可以遍历数组、对象并进行处理，而不需要使用繁琐的循环语句</p>
<h3 id="遍历HTML元素对象"><a href="#遍历HTML元素对象" class="headerlink" title="遍历HTML元素对象"></a>遍历HTML元素对象</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">[index]</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//处理代码，this关键字指向当前的对象，index代表当前序号，可选参数</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">"img"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.src);</span><br><span class="line">	<span class="keyword">if</span>(index!=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">this</span>.src=<span class="string">"../img/163.png"</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br></pre></td></tr></table></figure>
<p>在each方法的回调函数中，可以使用this关键字访问到当前遍历的相应HTML元素对象，它的index参数是可选的，表示当前遍历的元素的序号。</p>
<h3 id="遍历数组对象"><a href="#遍历数组对象" class="headerlink" title="遍历数组对象"></a>遍历数组对象</h3><p>语法格式为</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$.each(array,<span class="function"><span class="keyword">function</span>(<span class="params">[index]</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//处理代码，this关键字指向当前的对象，index代表当前序号，可选参数</span></span><br><span class="line">	&#125;)；</span><br></pre></td></tr></table></figure>
<p>举例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray=[<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>];</span><br><span class="line">			$.each(myArray, <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">				alert(<span class="string">"第"</span>+index+<span class="string">"项的值为："</span>+<span class="keyword">this</span>);</span><br><span class="line">			&#125;);</span><br></pre></td></tr></table></figure>
<p>会依次输出数组中的每一项字符串</p>
<h3 id="遍历JSON对象"><a href="#遍历JSON对象" class="headerlink" title="遍历JSON对象"></a>遍历JSON对象</h3><p>语法格式为</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$.each(object,<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//处理代码，key代表属性</span></span><br><span class="line">	&#125;)；</span><br></pre></td></tr></table></figure>
<p>举例如下</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=&#123;<span class="string">"name"</span>:<span class="string">"黄波"</span>,<span class="string">"age"</span>:<span class="number">40</span>,<span class="string">"course"</span>:<span class="string">"HTML5应用开发"</span>&#125;;</span><br><span class="line">			$.each(data, <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">				alert(key+<span class="string">"="</span>+data[key]);</span><br><span class="line">			&#125;);</span><br></pre></td></tr></table></figure>
<p>会一次输出对象中的对象和属性。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery04--jQuery HTML DOM</title>
    <url>/2019/03/11/jQuery04/</url>
    <content><![CDATA[<h1 id="jQuery-HTML-DOM学习笔记"><a href="#jQuery-HTML-DOM学习笔记" class="headerlink" title="jQuery HTML DOM学习笔记"></a>jQuery HTML DOM学习笔记</h1><h2 id="jQuery-HTML-DOM-获取和设置"><a href="#jQuery-HTML-DOM-获取和设置" class="headerlink" title="jQuery HTML DOM 获取和设置"></a>jQuery HTML DOM 获取和设置</h2><h3 id="jQuery-text（）"><a href="#jQuery-text（）" class="headerlink" title="jQuery text（）"></a>jQuery text（）</h3><p>该方法可用于获取或设置选定元素标签之间的文本内容，不包含元素标签本身。</p>
<ul>
<li>获取文本内容<br>使用不带任何参数的text（）方法可以获取选定元素标签之间的所有文本内容语法，格式为<code>$（selector）.text（）</code>；<br>该方法的返回结果为字符串类型，包含了所有匹配元素内部的文本内容。<a id="more"></a>
返回，只只返回文本内容，不带前后HTML标签。<br>如果是元素内部的后代元素中包含有文本，则使用text（）也会获取其中的文本内容。<br>需要注意的是，text（）方法不能用于处理表单元素的文本内容，如果需要获取或设置表单中&lt;\textarea&gt;或&lt;\input&gt;元素的文本值需要使用val（）方法。</li>
<li>设置文本内容<br>设置选定元素标签之间文本内容的方法如下<code>$（selector）.text（“新文本内容”）</code>；<br>该方法会用新文本内容替换就文本内容。</li>
</ul>
<h3 id="jQuery-html（）"><a href="#jQuery-html（）" class="headerlink" title="jQuery html（）"></a>jQuery html（）</h3><p>该方法用于获取或设置选定元素标签的全部内容，包括内部的文本以及其他HTML标签。该方法调用的是JavaScript原生属性inneHTML。</p>
<ul>
<li><p>获取HTML内容<br>获取选定元素标签之间HTML代码内容的方法如下<code>$（selector）.html（）</code>；<br>刚用来获取元素的HTML内容时，该方法无需带有参数。<br>需要注意的是，如果符合要求的元素不止一个，该方法只获取第一个符合选择器要求的元素内部的HTML代码。</p>
</li>
<li><p>设置HTML内容<br>设置选定元素标签之间HTML内容的方法如下<code>$（selector）.html（“新的HTML内容”）</code>；</p>
</li>
</ul>
<h3 id="jQuery-val（）"><a href="#jQuery-val（）" class="headerlink" title="jQuery val（）"></a>jQuery val（）</h3><p>该方法用来获取或设置选定表单元素的value属性值。</p>
<ul>
<li>获取表单元素值<br>获取选定元素标签之间文本内容的方法如<code>$（selector）.val（）</code>；</li>
<li>设置表单元素值<br>设置选定元素标签之间文本内容的方法如下<code>$（selector）.val（“新文本文件”）</code>；</li>
</ul>
<h3 id="jQuery-attr（）"><a href="#jQuery-attr（）" class="headerlink" title="jQuery attr（）"></a>jQuery attr（）</h3><p>该方法用于获取或设置选定元素的属性值。</p>
<ul>
<li>获取元素属性值<br>获取选定元素标签之间文本内容的方法如下<code>$（selector）.attr（attributeName）</code>；<br>该方法只能获取符合条件的第一个元素的值。</li>
<li>设置元素属性值<br>设置选定元素标签之间文本内容的方法如下<code>$（selector）.attr（attributeName，value）</code>；<br>该方法可以将所有符合条件的元素属性值全部设置。</li>
</ul>
<h3 id="jQuery-css（）"><a href="#jQuery-css（）" class="headerlink" title="jQuery css（）"></a>jQuery css（）</h3><p>该方法用于获取或设置选定元素的CSS属性值。</p>
<ul>
<li>获取CSS属性值<br>获取选定元素标签CSS属性的方法如下<code>$（selector）.css（propertyName）</code>；<br>该方法可以获得符合条件的第一个元素的指定CSS属性值。</li>
</ul>
<p>新增数组类型的propertyName参数，用于批量获取元素的多个属性值，语法格式为<code>$（selector）.css（［propertyName1，propertyName2…propertyNameＮ］）</code>；<br>属性只名称需要像字符串一样带引号。</p>
<ul>
<li>设置CSS属性值<br>设置选的元素标签CSS属性值的方法如下<code>$（selector）.css（propertyName，value）</code>；<br>两个参数都要带引号。<br>如果有多个CSS属性需要同时设置，语法结构为<code>$（selector）.css（{propertyName1:value1，propertyName2:value2…}）</code>； </li>
</ul>
<h2 id="jQuery-添加"><a href="#jQuery-添加" class="headerlink" title="jQuery 添加"></a>jQuery 添加</h2><h3 id="jQuery-append（）和prepend（）"><a href="#jQuery-append（）和prepend（）" class="headerlink" title="jQuery append（）和prepend（）"></a>jQuery append（）和prepend（）</h3><p>append（）方法用于在所有符合条件的元素内部的结尾处追加内容。<br>语法结构为<code>append（content，［content］）</code>；<br>其中content参数的类型可以是文本、数组。、HTML代码或元素标签。<br>prepend（）参数方法和append（）方法的参数完全相同，只不过追加位置从指定元素内部的结尾处变更为开头处。<code>prepend（content，［content］）</code>；</p>
<ul>
<li>追加文本<br>使用这两种方法添加文本内容允许带有格式化标签。<br>例如<code>$（“div#text”）.append（“这段文本带有&lt;i&gt;格式化&lt;/i&gt;标签”）</code>；</li>
<li>追加元素<br>用这两种方法添加新元素，可以直接在参数位置填入相关HTML代码。<br>例如<code>$（“div#text”）.append（“&lt;p&gt;这段文本&lt;/p&gt;”）</code>；</li>
<li>追加混合内容<br>如果有不同类型的内容（例如文本和HTML元素）需要同时添加可以在参数位置添加若干个变量，其间用逗号隔开，例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### jQuery after（）和before（）</span><br><span class="line">after（）方法用于在选定元素之后加入新的内容，before（）方法用于在选定元素之前加入新的内容。</span><br><span class="line">~~~</span><br><span class="line">after（content，［content］）；</span><br><span class="line">before（content，［content］）；</span><br><span class="line">~~~</span><br><span class="line">- 追加文本</span><br><span class="line">使用这两种方法添加文本内容，允许带有格式化标签。</span><br><span class="line">规则和append（）同</span><br><span class="line"></span><br><span class="line">- 追加元素</span><br><span class="line">使用这两种方法添加新元素，可以直接在参数位置填入相关HTML代码。语法结构和append（）方法同。</span><br><span class="line">- 追加混合内容</span><br><span class="line">如果有不同类型的内容需要同时添加，可以在参数位置添加若干个变量，语法和append（）相同。</span><br><span class="line"></span><br><span class="line">## jQuery 删除</span><br><span class="line">### jQuery remove（）</span><br><span class="line">该方法用于删除指定元素及其子元素，语法格式如下</span><br></pre></td></tr></table></figure>
$（selector）.remove（）；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如</span><br></pre></td></tr></table></figure>
$（“p”）.remove（）；<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">表示删除页面上所有段落元素。</span><br><span class="line">该方法也可以在括号中填了一个参数，用于筛选出特定的元素进行删除。</span><br><span class="line">例如</span><br><span class="line">```$（“p”）.remove（“.style”）；</span><br></pre></td></tr></table></figure>
<h3 id="jQuery-empty（）"><a href="#jQuery-empty（）" class="headerlink" title="jQuery empty（）"></a>jQuery empty（）</h3>该方法用于清空元素即从指定元素中删除其子元素和文本内容，语法格式为<br>例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该方法仅用于清空元素内部的内容，但保留元素本身的结果。也就是说，当用该方法的时候标签里面的内容被清除了当标签本身还是存在的。</span><br><span class="line"></span><br><span class="line">### jQuery removeAttr（）</span><br><span class="line">该方法用于删除元素的指定属性，语法结构为&#96;&#96;&#96;$（selector）.removeAttr（property Name）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="jQuery-类属性"><a href="#jQuery-类属性" class="headerlink" title="jQuery 类属性"></a>jQuery 类属性</h2><h3 id="jQuery-addClass（）"><a href="#jQuery-addClass（）" class="headerlink" title="jQuery addClass（）"></a>jQuery addClass（）</h3><p>当需要为元素设置多项CSS样式属性时，除了可以使用css（）方法逐行添加以外，还可以使用addClass（）方法直接为元素添加CSS要是表中的类名称。<br>如果有多个CSS类需要同时添加，可以都写在addClass（）方法的参数位置，之间用空格隔开。例如</p>
<figure class="highlight plain"><figcaption><span>style2”）```；</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### jQuery removeClass（）</span><br><span class="line">如果需要为元素取消某个CSS样式的类名称，只要使用removeClass（）方法即可，语法格式如下</span><br><span class="line">&#96;&#96;&#96;$（selector）.removeClass（className）</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示删除class&#x3D;“style1”的属性。</span><br><span class="line"></span><br><span class="line">#### toggleClass（）</span><br><span class="line">如果需要为元素切换某个CSS样式的类名称，只要使用toggleClass（）方法即可，语法格式为</span><br><span class="line">&#96;&#96;&#96;$（selector）.toggleClass（className）</span><br></pre></td></tr></table></figure>
<p>例如<br><code>$（“p”）.toggleClass（“style1”）</code><br>表示为段落元素添加或删除class=“style1”的属性</p>
<h2 id="jQuery尺寸"><a href="#jQuery尺寸" class="headerlink" title="jQuery尺寸"></a>jQuery尺寸</h2><p>jQuery还提供了一系列方法用于获取和设置元素或浏览器窗口的尺寸。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">width</span>（）：获取或设置元素的宽度（不包括内外边距和边框宽度）</span><br><span class="line"><span class="built_in">height</span>（）：获取或设置元素的高度（不包括内外边距和边框宽度）</span><br><span class="line">innerWidth（）：获取或设置元素的宽度（包括内边距）</span><br><span class="line">innerHeight（）：获取或设置元素的高度（包括内边距）</span><br><span class="line">outerWidth（）：获取或设置元素的宽度（包括内边距和边框宽度）</span><br><span class="line">outerHeight（）：获取或设置元素的高度（包括内边距和边框宽度）</span><br></pre></td></tr></table></figure>
<p>当以上方法不带任何参数表示获取元素的尺寸。<br>例如</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">width</span>=$（“div”）.<span class="built_in">width</span>（）；</span><br></pre></td></tr></table></figure>
<p>表示div块的宽度<br>如果需要获取带有外边距的尺寸，可以使用outerWidth（）方法加上参数值true表示。例如</p>
<figure class="highlight cal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width=$（“<span class="keyword">div</span>”）.outerWidth（）；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery03--jQuery特效</title>
    <url>/2019/03/10/jQuery03/</url>
    <content><![CDATA[<h1 id="jQuery特效学习笔记"><a href="#jQuery特效学习笔记" class="headerlink" title="jQuery特效学习笔记"></a>jQuery特效学习笔记</h1><h2 id="jQuery特效"><a href="#jQuery特效" class="headerlink" title="jQuery特效"></a>jQuery特效</h2><h3 id="jQuery隐藏和显示"><a href="#jQuery隐藏和显示" class="headerlink" title="jQuery隐藏和显示"></a>jQuery隐藏和显示</h3><p><b>jQuery hide（）</b><br>该方法用于隐藏指定的HTML元素，语法结构为</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$（selector）.<span class="keyword">hide</span>（［duration，］［，callback］）；</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>duration：动画设置隐藏的持续时间，可以填入slow（600ms）、fast（200ms）或者具体的时间长度（毫秒单位）；</li>
<li>callback：隐藏动作后下一步需要的执行函数，若无可以不填<br>使用不带任何参数的hide（）函数可以实现无动画效果的隐藏动作，相当于将选择器元素设置为display：none$（“p”）.hide（）。</li>
</ul>
<p><b>jQuery show（）</b><br>该方法用于显示指定元素，语法结构为</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">$（selector）.<span class="keyword">show</span>（［duration，］［，callback］）；</span><br></pre></td></tr></table></figure>
<p>参数的意义同hide（）方法的参数。</p>
<p><b>jQuery toggle（）</b><br>该方法用于切换元素的隐藏和显示。该方法可以替代hide（）和show（）方法单独使用，用于显示已隐藏的元素，和隐藏正在显示的元素。<br>语法结构为<code>$（selector）.toggle（）；</code><br>可以点击一个按钮循环实现隐藏和显示，如果显示状态就代表隐藏，如果隐藏状态就表示显示状态。</p>
<h3 id="jQuery淡入淡出"><a href="#jQuery淡入淡出" class="headerlink" title="jQuery淡入淡出"></a>jQuery淡入淡出</h3><h4 id="fadeIn（）淡入"><a href="#fadeIn（）淡入" class="headerlink" title="fadeIn（）淡入"></a>fadeIn（）淡入</h4><p>fadeIn（）实现元素的淡入效果，即将原先隐藏的元素显示出来，语法结构为</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$（</span>selector）.fadeIn（［duration，］［，callback］）；</span><br></pre></td></tr></table></figure>
<h4 id="fadeOut（）"><a href="#fadeOut（）" class="headerlink" title="fadeOut（）"></a>fadeOut（）</h4><p>该方法用于实现元素的淡出效果，即将原先存在的元素逐渐隐藏起来，语法结构为</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$（</span>selector）.fadeOut（［duration，］［，callback］）；</span><br></pre></td></tr></table></figure>
<p>fadeIn（）和fadeOut（）不添加任何参数就是没有动画效果，立刻就完成动画过程。</p>
<h4 id="fadeToggle（）"><a href="#fadeToggle（）" class="headerlink" title="fadeToggle（）"></a>fadeToggle（）</h4><p>该方法用于切换元素的淡入和淡出效果，语法结构为</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$（</span>selector）.fadeToggle（［duration，］［，callback］）；</span><br></pre></td></tr></table></figure>
<p>如果原先为淡出状态，按钮则代表淡入；如果原先为淡入状态，按钮就代表淡出，交替使用。</p>
<h4 id="fadeTo（）"><a href="#fadeTo（）" class="headerlink" title="fadeTo（）"></a>fadeTo（）</h4><p>该方法用于指定渐变效果的透明度，透明度取值为0～1，语法结构如下：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$（</span>selector）.fadeTo（duration，opacity［，callback］）；</span><br></pre></td></tr></table></figure>
<p>其中opacity表示透明度，0为完全透明，1为非透明。</p>
<h3 id="jQuery滑动"><a href="#jQuery滑动" class="headerlink" title="jQuery滑动"></a>jQuery滑动</h3><h4 id="jQuery-slideDown（）"><a href="#jQuery-slideDown（）" class="headerlink" title="jQuery slideDown（）"></a>jQuery slideDown（）</h4><p>该方法用于向下滑动元素，语法结构如下：<code>$（selector）.slideDown（［duration，］［，callback］）；</code><br>该方法中的两个参数均为可选。其他参数的意义同上。</p>
<h4 id="jQueryslideUp（）"><a href="#jQueryslideUp（）" class="headerlink" title="jQueryslideUp（）"></a>jQueryslideUp（）</h4><p>该方法用于向上滑动元素，语法结构如下：<code>$（selector）.slideUp（［duration，］［，callback］）；</code><br>参数意义同上。</p>
<h4 id="jQuery-slideToggle（）"><a href="#jQuery-slideToggle（）" class="headerlink" title="jQuery slideToggle（）"></a>jQuery slideToggle（）</h4><p>该方法用于切换滑动方向，语法结构如下：<code>$（selector）.slideToggle（［duration，］［，callback］）；</code><br>如果元素原先处于向上滑动，那么按下按钮代表向下滑动，如果元素原先是向下滑动状态，那么按下按钮代表向上滑动。</p>
<h2 id="jQuery-动画"><a href="#jQuery-动画" class="headerlink" title="jQuery 动画"></a>jQuery 动画</h2><p>animate（）方法通过更改元素的CSS属性值实现动画效果。语法结构：<code>（selector）.animate（{params}，［duration，］［，callback］）；</code><br>参数意义如下：</p>
<ul>
<li>params：表示形成动画的C S S属性，允许同时实现多个属性的改变。</li>
<li>duration：表示规定的效果时长，默认单位为毫秒。</li>
<li>callback：表示动画完成后需要执行的函数名称，若无下一步需执行的函数，可省略不填。</li>
</ul>
<h3 id="改变元素的基本属性"><a href="#改变元素的基本属性" class="headerlink" title="改变元素的基本属性"></a>改变元素的基本属性</h3><p>animate（）方法可以用于实现绝大部分C S S属性的变化，例如元素的宽度、高度、透明度等的变化。但是jQuery和辛苦中并没有包含色彩变化效果，因此如果要实现颜色动画需要在jQuery官方网站上另外，下载色彩动画的相关插件。<br>当CSS属性名称中包含连字符“-”时，需要使用驼峰标记法。<br>animate（）方法可以用于各种HTML元素。<br>例如</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$（“#btn”）.click（function（）&#123;</span><br><span class="line">$（“div”）.animate（&#123;</span><br><span class="line">width：“<span class="number">400</span>px”，</span><br><span class="line">fontSize：“<span class="number">300</span>px”，</span><br><span class="line">opacity：<span class="number">0.23</span>&#125;，<span class="number">2000</span>）；</span><br><span class="line">&#125;）；</span><br></pre></td></tr></table></figure>
<h3 id="改变元素的位置"><a href="#改变元素的位置" class="headerlink" title="改变元素的位置"></a>改变元素的位置</h3><p>animate（）方法也可以通过使用CSS属性的left、right、top、bottom改变元素位置实现移动效果。由于这些属性值均为相对值，而在HTML中所有元素的position属性值均默认为静态（static）无法移动的，因此需要事先设置指定元素的position为relative、absolute或者fixed才能生效。<br>例如</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$（</span>“<span class="comment">#btn”）.click（function（）&#123;</span></span><br><span class="line"><span class="variable">$（</span>“div”）.animate（&#123;</span><br><span class="line">left：“+=<span class="number">200</span>”，</span><br><span class="line">top：“+=<span class="number">100</span>”&#125;，<span class="number">2000</span>）；</span><br><span class="line">&#125;）；</span><br></pre></td></tr></table></figure>
<p>动画队列<br>可以为多个连续的animate（）方法创建动画队列，然后依次执行队列中的每一项动画，从而实现更加复杂的动画效果。在同一个animate（）方法中描述的多个动画效果会同时发生，但在不同的animate（）方法中描述的动画效果会按照动画队列冲的先后次序发生。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$（“#btn”）.click（function（）&#123;</span><br><span class="line">$（“div”）.animate（&#123;left：“+=<span class="number">200</span>”，top：“+=<span class="number">100</span>”&#125;，<span class="number">2000</span>）；</span><br><span class="line">$（“div”）.animate（&#123;right：“+=<span class="number">200</span>”，bottom：“+=<span class="number">100</span>”&#125;，<span class="number">2000</span>）；</span><br><span class="line">$（“div”）.animate（&#123;left：“-=<span class="number">200</span>”，top：“-=<span class="number">100</span>”&#125;，<span class="number">2000</span>）；</span><br><span class="line">&#125;）；</span><br></pre></td></tr></table></figure>
<p>单击按钮会依次发生动画效果。</p>
<h4 id="方法链接"><a href="#方法链接" class="headerlink" title="方法链接"></a>方法链接</h4><p>jQuery允许在同一个元素上连续运行多条jQuery命令，这种技术称为jQuery方法链接对于同一个元素，如果有多个动作需要依次举行，只需将新的动作追加到上一个动作的后面，形成一个方法链，无需每次重复查找选择相同的元素。基本语法为：<code>$（selector）.action1（）.action 2（）.action3（）…actionＮ（）；</code><br>每个动作也可以另起一行</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$（selector）<span class="string">.action1</span>（）</span><br><span class="line"><span class="string">.action</span> 2（）</span><br><span class="line"><span class="string">.action3</span>（）</span><br><span class="line">…</span><br><span class="line"><span class="string">.action</span>Ｎ（）；</span><br></pre></td></tr></table></figure>
<h4 id="jQuery停止动画"><a href="#jQuery停止动画" class="headerlink" title="jQuery停止动画"></a>jQuery停止动画</h4><p>可用stop（）方法停止动画或效果，语法结构为<code>$（selector）.stop（［stopAll]，［gotoEnd］）；</code><br>参数意义如下：</p>
<ul>
<li>stopAll：用于规定是否清除后续的所有动画内容，可填入布尔值。其默认值为false，表示，仅停止当前动画，允许动画队列中的后续动画继续执行。</li>
<li>gotoEnd：用于规定是否立即完成当前的动画内容，可填入布尔值，其默认值为false，表示直接终止当前的动画效果。</li>
</ul>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery02--jQuery事件</title>
    <url>/2019/03/09/jQuery02/</url>
    <content><![CDATA[<h1 id="jQuery事件学习笔记"><a href="#jQuery事件学习笔记" class="headerlink" title="jQuery事件学习笔记"></a>jQuery事件学习笔记</h1><h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><h3 id="jQuery事件概述"><a href="#jQuery事件概述" class="headerlink" title="jQuery事件概述"></a>jQuery事件概述</h3><p>语法结构为：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$（selector）.action（<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line">	<span class="comment">//事件触发后需要执行的自定义脚本&#125;）</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如为段落元素&lt;\p&gt;添加鼠标单击事件click</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$（<span class="string">"p＂）.click（function（）&#123;</span></span><br><span class="line">alert（“单击成功”）；</span><br><span class="line">&#125;）；</span><br></pre></td></tr></table></figure>
<h3 id="jQuery常用事件"><a href="#jQuery常用事件" class="headerlink" title="jQuery常用事件"></a>jQuery常用事件</h3><h4 id="文档-窗口事件"><a href="#文档-窗口事件" class="headerlink" title="文档/窗口事件"></a>文档/窗口事件</h4><ul>
<li><p>1、ready（）事件<br>ready（）事件又称为准备就绪事件，该事件只在文档准备就绪时触发，因此其选择器只能$（document）。一般来说，为了避免文档在准备就绪之前执行了其他jQuery代码而导致错误，所有的jQuery函数都需要写在文档准备就绪函数中，语法结构为：$（document）.ready（function）。<br>在实际使用时，文档准备就绪函数function的内部代码可以更加丰富，可以是多个独立的jQuery语句或者jQuery函数的调用组合而成，浏览器会按照先后顺序执行其内部的全部代码。</p>
</li>
<li><p>2、load（）事件<br>当页面中指定的元素被加载完毕时会触发load（）事件，该事件通常用于监听具有可加载内容的元素，例如图像元素&lt;\img&gt;、内敛框架&lt;\iframe&gt;等。语法格式为：<code>$（selector）.load（function）</code>其中参数function为必填内容，表示元素加载完毕时需要执行的函数。</p>
</li>
<li><p>3、unload（）事件<br>当用户离开当前页面时会触发unload（）事件，该事件只适用于window对象，可能导致触发unload（）事件的行为如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">关闭整个浏览器或当前页面；</span><br><span class="line">在当前页面的浏览器地址栏中输入新的<span class="built_in">URL</span>地址并进行访问；</span><br><span class="line">单击浏览器上的“前进”或“后退”按钮；</span><br><span class="line">单击浏览器上的“刷新”按钮或以当前浏览器支持的快捷方式刷新页面；</span><br><span class="line">单击当前页面中的某个超链接导致跳转新页面。</span><br></pre></td></tr></table></figure>
<p>语法格式为：<code>$（window）.unload（function）</code>其中参数function为必填内容，表示离开页面时需要执行的函数。</p>
</li>
</ul>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul>
<li>1、keydown（）事件<br>当键盘的按键处于按下状态时将触发keydown（）事件，语法格式为<code>$（selector）.keydown（function）</code></li>
<li>2、keyup（）事件<br>当键盘上已经按下去的按键处于被释放状态时将触发keyup（）事件，语法格式为<code>$（selector）.keyup（function）</code></li>
<li>3、keypress（）事件<br>当键盘上的按键处于按下状态并快速释放时将触发keypress（）事件，语法格式为```$（selector）.keypress（function）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 鼠标事件</span><br><span class="line">- 1、click（）事件</span><br><span class="line">当用户使用鼠标左键点击网页文档中的任意HTML元素时均可触发click（）事件，语法格式&#96;&#96;&#96;$（selector）.click（function）</span><br></pre></td></tr></table></figure></li>
<li>2、dbclick（）事件<br>当用户使用鼠标左键双击网页文档中的任意HTML元素时均可触发dbclick（）事件，语法格式为<code>$（selector）.dbclick（function）</code></li>
<li>3、hover（）事件<br>当用户将鼠标悬停在网页文档中的任意HTML元素上时将会触发hover（）事件，语法格式为<code>$（selector）.hover（function）</code></li>
<li>4、mousexxx（）系列<br>以关键字mouse开头的一系列鼠标事件是根据鼠标移动方向或效果来区分的，语法结构为<code>$（selector）.mousexxx（function）</code><br>xxx替换成具体的动作效果，可替换的关键字如下：<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">down</span>：鼠标按键按下。</span><br><span class="line"><span class="meta">up</span>：鼠标按键被释放时，与<span class="meta">down</span>相反。</span><br><span class="line">move：鼠标处于移动状态。</span><br><span class="line"><span class="keyword">enter</span>：鼠标进入指定元素。</span><br><span class="line"><span class="keyword">leave</span>：鼠标离开指定元素，与<span class="keyword">enter</span>相反。</span><br><span class="line"><span class="keyword">out</span>：鼠标离开指定元素或其子元素。</span><br><span class="line">over：鼠标穿过指定元素或其子元素，与<span class="keyword">out</span>相反。</span><br></pre></td></tr></table></figure></li>
<li>5、toggle（）事件<br>toggle（）事件可以看作是一种特殊的鼠标单击事件，可以一次绑定两个或两个以上函数。当元素被单击时，会按照先后顺序每次只触发其中一个函数。语法格式为<code>（selector）.toggle（function1，function2，…，functionＮ）</code><br>其中function1～functionＮ可以替换成需要触发的若干个函数，函数之间用逗号隔开。每次单击鼠标按键都会触发一次toggle事件，按照单击顺序运行函数，当最后一个函数被执行时会下一次触发该事件会重新运行第一个函数。</li>
</ul>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><ul>
<li>1、blur（）事件<br>当某个处于选中状态的元素失去焦点时将触发blur事件，语法格式为<code>$（selector）.blur（function）</code></li>
<li>2、focus（）事件<br>当某个处于未选中状态的元素获得焦点时将触发focus（）事件，语法格式为<code>$（selector）.focus（function）</code></li>
<li>3、change（）事件<br>当输入框或下拉菜单中的内容发生变化时将触发change（）事件，语法格式为<code>$（selector）.change（function）</code><br>其选择器可以是表单中的输入框&lt;\input&gt;、多行文本框&lt;\textarea&gt;或者下拉菜单&lt;\select&gt;。触发效果不同为：<br>选择器为&lt;\input&gt;或&lt;\textarea&gt;：用户更改输入框中的内容，然后让输入框失去焦点才触发change（）事件。<br>选择器为&lt;\select&gt;：用户选择不同的选项时触发change（）事件。</li>
<li>4、select（）事件<br>当文本输入框中有文字内容被选中时，将触发该元素的select（）事件，语法格式为<code>$（selector）.select（function）</code><br>其选择器只能是单行文本框&lt;\input type=“text”&gt;或多行文本框&lt;\textarea&gt;。</li>
<li>5、submit（）事件<br>当用户尝试提交表单时，将触发表单元素&lt;\form&gt;的submit事件，语法格式为<code>$（selector）.submit（function）</code><br>该事件的选择器只能是表单元素&lt;\form&gt;。<br>用户有两种提交表单的方式—单击特定的“提交”按钮或者使用键盘上的Enter键，特定的“提交”按钮包括<code>&lt;\input type=“submit”&gt;、&lt;\input type=“image”&gt;</code>以及<code>&lt;\button type=“submit”&gt;</code>；使用Enter键的前提是表单中只有一个文本域，或者表单中包含了“提交”按钮。<br>由于submit（）事件会在表单正式提交给服务器之前触发，因此常用其进行有效性检测：当表单中填写的内容验证不通过时显示提示语句，并停止表单提交的动作；当内容验证通过时继续完成表单提交动作。</li>
</ul>
<h2 id="jQuery事件的绑定和接触"><a href="#jQuery事件的绑定和接触" class="headerlink" title="jQuery事件的绑定和接触"></a>jQuery事件的绑定和接触</h2><h3 id="jQuery事件的绑定"><a href="#jQuery事件的绑定" class="headerlink" title="jQuery事件的绑定"></a>jQuery事件的绑定</h3><h4 id="bind（）方法"><a href="#bind（）方法" class="headerlink" title="bind（）方法"></a>bind（）方法</h4><p>bind（）方法可以用于给指定的元素绑定一个或多个事件，语法结构为<code>$（selector）.bind（event，［data，］function）</code><br>参数解释：</p>
<ul>
<li>event：必填参数，用于指定事件名称，例如“click”</li>
<li>data：可选参数，用于规定需要传递给函数的额外数据</li>
<li>function：必填参数，用于规定事件触发时的执行函数<br>例如<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$（“button”）.<span class="keyword">bind</span>（“click”，<span class="function"><span class="keyword">function</span></span>（）&#123;</span><br><span class="line">alert（“触发”）；&#125;）</span><br></pre></td></tr></table></figure>
如果指定元素绑定的多个事件需要调用同一个函数，可以将这些事件名称有空格隔开后并列添加在参数event中，例如<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$（“button”）.<span class="keyword">bind</span>（“click dbclick mouseover”，<span class="function"><span class="keyword">function</span></span>（）&#123;</span><br><span class="line">alert（“触发”）；&#125;）</span><br></pre></td></tr></table></figure>
如果需要为指定元素同时绑定多个事件并触发不同的函数，语法结构为<code>$（selector）.bind（event1:function1，event2:function2，…eventＮ，functionＮ）</code></li>
</ul>
<h4 id="delegate（）方法"><a href="#delegate（）方法" class="headerlink" title="delegate（）方法"></a>delegate（）方法</h4><p>delegate方法可以用于给指定元素的子元素绑定一个或多个事件，语法格式为<code>$（selector）.delegate（childSelector，event，［data，］function）</code><br>参数说明：</p>
<ul>
<li>childSelector：必填参数，用于规定需要绑定事件的一个或多个事件子元素。</li>
<li>event：必填参数，用于指定需要绑定给子元素的一个或多个事件名称，用法后bind（）方法同。</li>
<li>data：可选参数，用于规定需要传递给函数的额外数据</li>
<li>function：必填参数，用于规定需要绑定的事件触发时的执行函数。<br>delegate（）方法的优势在于还可以为指定元素的未来子元素（当前未创建，后续通过代码动态添加的子元素）绑定事件。</li>
</ul>
<h4 id="on（）方法"><a href="#on（）方法" class="headerlink" title="on（）方法"></a>on（）方法</h4><p>on（）方法可以用于给指定元素的子元素绑定一个后多个事件，包含了bind（）和delegate（）方法全部功能。<br>语法结构为<code>$（selector）.on（event，［childSelector，］［data，］function）</code><br>参数解释和上述bind（）和delegate（）方法的参数相同，只是加了方括号的都是可选参数。</p>
<h3 id="jQuery事件的解除"><a href="#jQuery事件的解除" class="headerlink" title="jQuery事件的解除"></a>jQuery事件的解除</h3><h4 id="unbind（）方法"><a href="#unbind（）方法" class="headerlink" title="unbind（）方法"></a>unbind（）方法</h4><p>语法格式为<code>$（selector）.unbind（［event］，［，function］）</code></p>
<ul>
<li>event：可选参数，用于指定需要解除的一个或多个事件名称，如果该参数不填写，则表示解除指定元素的全部事件</li>
<li>function：可选参数，用于规定需要解除的事件触发时的执行函数。</li>
</ul>
<h4 id="undelegate（）"><a href="#undelegate（）" class="headerlink" title="undelegate（）"></a>undelegate（）</h4><p>语法格式为<code>$（selector）.undelegate（［childSelector，］［event］［，function］）</code><br>childSelector：可选参数，用于规定需要解除事件的一个或多个子元素<br>该方法主要是解除之前使用delegate（）方法绑定的事件，不能用于解除其他方法绑定的事件。</p>
<h4 id="off（）方法"><a href="#off（）方法" class="headerlink" title="off（）方法"></a>off（）方法</h4><p>包含unbind（）方法和undelegate（）方法的全部功能。<br>语法格式为<code>$（selector）.off（［childSelector，］［event］［，function］）</code><br>参数解释同上。</p>
<h3 id="jQuery临时事件"><a href="#jQuery临时事件" class="headerlink" title="jQuery临时事件"></a>jQuery临时事件</h3><p>在某些特殊情况下，为元素绑定的事件仅需要执行一次就必须解除绑定，此类情况称为元素的临时事件。<br>例如为按钮元素绑定临时的单击事件：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$（“button”）.<span class="literal">on</span>（“click”，<span class="keyword">function</span>（）&#123;</span><br><span class="line">alert（“ok”）；</span><br><span class="line">$（<span class="keyword">this</span>）.<span class="literal">off</span>（“click”）；&#125;）</span><br></pre></td></tr></table></figure>
<p>用on（）方法为按钮进行click事件绑定，当click事件首次触发时立刻调用off方法解绑事件。</p>
<p>可以用专门的one（）方法来代替on（）和off（）方法。one（）方法在触发一次后就自动解绑，语法格式为<code>$（selector）.one（［childSelector，］［event］［，function］）</code><br>参数解释同上</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery01</title>
    <url>/2019/03/08/jQuery01/</url>
    <content><![CDATA[<h1 id="jQuery选择器与过滤器"><a href="#jQuery选择器与过滤器" class="headerlink" title="jQuery选择器与过滤器"></a>jQuery选择器与过滤器</h1><h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><h4 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h4><p>全局选择器用于选择文档中所有元素，其语法结构为：<code>$（&quot;\*＂）；</code>全局选择器会遍历文档中所有的元素标签，甚至包括首部标签head及其内部的标签，运行速度较慢。</p>
<a id="more"></a>
<h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><p>元素选择器用于选择所有指定标签名称的元素，其语法结构为：<code>$（&quot;element＂）</code>；<br>这里的element 在使用的时候要换成真正的元素标签名称。例如$（”h1＂）；表示选中所有的h1标题元素。在使用元素选择器时候，jQuery会调用JavaScript中的原生getElmentsByTagName（）来获取指定的元素，该方法简化了原先JavaScript的代码量。</p>
<h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><p>ID选择器用于选择指定ID名称的单个元素，语法结构为：<code>$（&quot;#ID＂）</code>；<br>这里的ID在使用时要换成元素真正的ID名称。例如<code>$（&quot;#test＂）</code>；<br>表示选中<code>ID=”test＂</code>的元素。在使用ID选择器时，jQuery会调用JavaScript中的原生方法<code>getElementById（）</code>来获取指定ID名称的元素。<br>ID选择器也可以和元素选择去配合使用，例如</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$（<span class="string">"p#test＂）；</span></span><br></pre></td></tr></table></figure>
<p>表示选择<code>id=test</code>的段落元素&lt;\p&gt;</p>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>类选择器用于筛选出具有同一个class属性值的所有元素，其语法结构为：<code>（&quot;·class＂）</code>；<br>这里的class在使用的时候需要换成真正的类名称，例如<code>$（&quot;.box＂）</code>；<br>表示选择<code>class=”box＂</code>的元素。如果一个元素包含了多个类，只要其中的任意一个类满足条件即可 被选中。在使用这个方法的时候，jQuery会调用JavaScript的原生方法<code>getElementsByClassName</code>来获取指定的元素。<br>类选择器也可以和元素选择器配合使用，例如</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$（<span class="string">"p.box＂）；</span></span><br></pre></td></tr></table></figure>
<p>表示选择所有c<code>lass=”box＂</code>的&lt;\p&gt;元素</p>
<h4 id="多重选择器"><a href="#多重选择器" class="headerlink" title="多重选择器"></a>多重选择器</h4><p>多重选择器适用于需要批量处理的多种元素，可以将不同的筛选条件用逗号隔开写入同一个选择器中，语法结构为<code>$（&quot;selector1，selector2，selector3＂）</code>；<br>这里的选择器可以是元素选择器、ID选择器、类选择器中的一种或组合使用，只要是满足其中任意一个条件即可。</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>常见属性选择器有</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">［attribute］：带有指定属性的元素，例如<span class="variable">$</span>（<span class="string">"［alt］＂）表示所有带alt属性的元素</span></span><br><span class="line"><span class="string">［attribute=value］：属性等于特定值的元素，例如<span class="variable">$</span>（"</span>［href=‘<span class="comment">#’］＂）表示所有href属性值等于“#”的元素</span></span><br><span class="line">［attribute！=value］：属性不等于特定值的元素，例如<span class="variable">$</span>（<span class="string">"［href！=‘#’］＂）表示所有href属性值 不等于“#”的元素。</span></span><br><span class="line"><span class="string">［attribute<span class="variable">$</span>=value］：属性以指定值结尾的元素，例如<span class="variable">$</span>（"</span>［src<span class="variable">$</span>=‘.png’］＂）表示src属性值以.png结尾的元素。</span><br></pre></td></tr></table></figure>
<h4 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h4><p>jQuery表单选择器可用于指定类型或处于指定状态的表单元素。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">input</span> 所有&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:<span class="type">text</span> 选择<span class="keyword">type</span>=“<span class="type">text</span>”的&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:<span class="keyword">password</span> 选择<span class="keyword">type</span>=“<span class="keyword">password</span>”的&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:radio 选择<span class="keyword">type</span>=“pradio”的&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:checkbox 选择<span class="keyword">type</span>=“checkbox”的&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:submit 选择<span class="keyword">type</span>=“submit”的&lt;\<span class="keyword">input</span>&gt;和&lt;\button&gt;元素</span><br><span class="line">:<span class="keyword">reset</span> 选择<span class="keyword">type</span>=“<span class="keyword">reset</span>”的&lt;\<span class="keyword">input</span>&gt;和&lt;\button&gt;元素</span><br><span class="line">:button 选择<span class="keyword">type</span>=“button”的&lt;\<span class="keyword">input</span>&gt;和&lt;\button&gt;元素</span><br><span class="line">:image 选择<span class="keyword">type</span>=“image”的&lt;\<span class="keyword">input</span>&gt;元素</span><br><span class="line">:file 选择<span class="keyword">type</span>=“file”的&lt;\<span class="keyword">input</span>&gt;</span><br><span class="line">:enabled 所有启用的的&lt;\<span class="keyword">input</span>&gt;和&lt;\button&gt;元素</span><br><span class="line">:disabled 所有被禁用的&lt;\<span class="keyword">input</span>&gt;和&lt;\button&gt;元素</span><br><span class="line">:selected 下拉表中所有处于选中状态的&lt;\<span class="keyword">option</span>元素&lt; li&gt;</span><br><span class="line">:checked 所有被选中的单选按钮或者复选按钮</span><br></pre></td></tr></table></figure>
<h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><ul>
<li><p>子元素选择器<br>子元素选择器只能选择指定元素的第一层子元素，语法结构为<code>$（&quot;parent&gt;child＂）</code>其中parent可以是任何一个有效的jQuery选择器，child只能是parent的第一层子元素。</p>
</li>
<li><p>后代选择器<br>后代选择器可用于选择指定元素内包含的所有后代元素，比子元素选择器包括范围更广，语法结构为<code>$（&quot;ancestor descendant＂）</code>其中参数ancestor可以是任何一个有效的jQuery选择器，参数descendant填入的必须是ancestor元素的后代元素。</p>
</li>
<li><p>后相邻选择器<br>后相邻选择器可用于选择与指定元素相邻的后一个元素，其语法结构为<code>$（&quot;prev+next＂）</code><br>prev可以是任何一个选择器，next只能是prev相邻的后一个选择器。</p>
</li>
<li><p>后兄弟选择器<br>后兄弟选择器可用于选择指定元素后面跟随的所有符合条件的兄弟元素，语法结构为：<code>$（&quot;prev～siblings＂）</code><br>其中参数prev可以是任何一个jQuery选择器，参数siblings填入的选择器筛选的必须是位置在prev元素后面的兄弟元素。与<code>$（”prev+next＂）</code>不同的是，<code>$（”prev+next＂）</code>只能筛选指定元素后面的下一个相邻元素，而<code>$（”prev～siblings＂）</code>可以筛选指定元素后面所有符合条件的兄弟元素，可以是多个元素。</p>
</li>
</ul>
<h3 id="jQuery-CSS选择器"><a href="#jQuery-CSS选择器" class="headerlink" title="jQuery CSS选择器"></a>jQuery CSS选择器</h3><p>css选择器用于改变指定HTML元素的css属性，语法结构为<code>$（selector）.css（propertyName，value）</code>；<br>其中propertyName是css属性名称，value是需要设置的属性值。例如将所有的h1标签的颜色改为灰色，写法为：<code>$（“h1”）.css（“color”，“grey”）；</code></p>
<h2 id="jQuery过滤器"><a href="#jQuery过滤器" class="headerlink" title="jQuery过滤器"></a>jQuery过滤器</h2><p>jQuery过滤器可以单独使用，也可以组合使用，根据筛选条件可归纳为基础过滤器、子元素过滤器、内容过滤器和可见性过滤器。</p>
<h3 id="基础过滤器"><a href="#基础过滤器" class="headerlink" title="基础过滤器"></a>基础过滤器</h3><h4 id="：first和：last"><a href="#：first和：last" class="headerlink" title="：first和：last"></a>：first和：last</h4><p>：first用于筛选第一个符合条件的元素，语法结构为：<code>$（&quot;：first＂）</code><br>例如为：<code>$（&quot;div：first＂）</code><br>选择页面上的第一个&lt;\div&gt;元素。<br>：last过滤器用于筛选最后一个符合条件的元素，语法结构为为：<code>$（&quot;：last＂）</code><br>.：last过滤器可以单独使用也可以和其他选择器组合使用。</p>
<h4 id="：even和：odd"><a href="#：even和：odd" class="headerlink" title="：even和：odd"></a>：even和：odd</h4><p>：even过滤器用于筛选符合条件的偶数个元素，计数从0开始，语法结构为为：<code>$（&quot;：even＂）</code><br>例如筛选偶数行的表格为为：<code>$（&quot;tr：even＂）</code><br>：odd过滤器筛选符合条件的奇数个元素，计数从0开始，语法结构为：<code>$（”：odd＂）</code></p>
<h4 id="：eq（）、：gt（）和：lt（）"><a href="#：eq（）、：gt（）和：lt（）" class="headerlink" title="：eq（）、：gt（）和：lt（）"></a>：eq（）、：gt（）和：lt（）</h4><ul>
<li>：eq（）用于选择指定序号为n的元素，序号从0开始计数 ，（equal）。语法结构为为：<code>$（&quot;：eq（index）＂）</code> 参数index可以替换为指定的序号。若index填入负数，表示倒数第n个元素。其中：eq（0）和：first相同效果。</li>
<li>：gt（）过滤器用于选择所有大于序号为n的元素，序号从0开始计数。（greater than）。语法结构为为： <code>$（&quot;：gt（index）＂）</code>参数index可以替换为指定的序号。若index填入负数，表示大于倒数第n个元素。</li>
<li>：lt（）过滤器用于选择所有小于序号为n的元素，序号从0开始计数。（less than）。语法结构为为：<code>$（&quot;：lt（index）＂）</code>参数index可以替换为指定的序号。若index填入负数，表示小于倒数第n个元素。其中：lt（1）相当于：first效果。</li>
</ul>
<h4 id="：not（）"><a href="#：not（）" class="headerlink" title="：not（）"></a>：not（）</h4><p>：not（）过滤器用于筛选所有不符合条件的元素，语法结构为<code>$（&quot;：not（selector）＂）</code><br>所有的选择器都可以和：not（）配合使用来筛选相反的条件。</p>
<h4 id="：header（）"><a href="#：header（）" class="headerlink" title="：header（）"></a>：header（）</h4><p>：header（）过滤器用于筛选所有的标题元素，从&lt;\h1&gt;到&lt;\h6&gt;均在此选择范围内，语法结构为<code>$（&quot;：header＂）</code></p>
<h3 id="子元素过滤器"><a href="#子元素过滤器" class="headerlink" title="子元素过滤器"></a>子元素过滤器</h3><p>子元素过滤器可筛选指定元素的子元素。</p>
<h4 id="：first-child"><a href="#：first-child" class="headerlink" title="：first-child"></a>：first-child</h4><p>：first-child过滤器用于筛选页面上每个父元素中的第一个子元素，语法结构为<code>$（&quot;：first-child＂）</code><br>和只能选择唯一元素的：first过滤器不同，只要是页面上的父元素，可以同时使用：first-child过滤器从中选出其第一个子元素，因此选择结果可能不止一个元素。<br>：first-child过滤器可以单独使用也可以和其他选择器组合使用。例如<code>$（&quot;p：first-child＂）</code><br>表示在页面上所有包含段落元素&lt;\p&gt;的父元素中筛选出每个父元素内部的第一个段落子元素。</p>
<h4 id="：last-child"><a href="#：last-child" class="headerlink" title="：last-child"></a>：last-child</h4><p>：last-child过滤器用于筛选页面上每个父元素中的最后一个子元素，语法结构为<code>$（&quot;：last-child＂）</code><br>与：first-child类似，其选择结果也可能不止一个。例如<code>$（&quot;p：last-child＂）</code><br>表示在页面上所有包含段落元素&lt;\p&gt;的父元素中筛选出每个父元素内部的最后一个个段落子元素。</p>
<h4 id="：nth-child"><a href="#：nth-child" class="headerlink" title="：nth-child"></a>：nth-child</h4><p>：nth-child（）过滤器用于筛选页面上每个父元素中的第n个子元素，序号从1开始计数，语法结构为：<code>$（&quot;：nth-child（index）＂）</code><br>例如：<code>（&quot;：nth-child（2）＂）</code><br>表示筛选父元素中的第二个子元素。index还可以填入odd和even表示奇数偶数位置，也可以填入表达式如3n+1表示1、4、7…</p>
<h4 id="：only-child"><a href="#：only-child" class="headerlink" title="：only-child"></a>：only-child</h4><p>：only-child过滤器用于筛选所有在父元素中有且只有一个的子元素，语法结构<code>$（&quot;：only-child＂）</code><br>可以单独使用也可以组合使用<br>如果父元素中包含了其他子元素则不匹配。即使其他子元素是&lt;\br&gt;或&lt;\hr&gt;等内容也会失效。</p>
<h3 id="内容过滤器"><a href="#内容过滤器" class="headerlink" title="内容过滤器"></a>内容过滤器</h3><p>jQuery内容过滤器可以根据元素所包含的子元素或文本内容进行过滤筛选。</p>
<h4 id="：contains（）"><a href="#：contains（）" class="headerlink" title="：contains（）"></a>：contains（）</h4><p>：contains（）过滤器用于筛选出所有包含指定文本内容的元素，语法结构为：<code>$（&quot;：contains（text）＂）</code><br>其中text替换成指定的字符串文本，由于过滤器外面已经存在一对引号，因此该文本可以用单引号括住具体文字内容。例如：<code>$（&quot;p：contains（‘hi’）＂）</code><br>表示选择所有文本内容包含“hi”字样的段落元素&lt;\p&gt;。<br>：contains（）过滤器的筛选文本对大小写是敏感的。</p>
<h4 id="：empty"><a href="#：empty" class="headerlink" title="：empty"></a>：empty</h4><p>：empty过滤器用于选择未包含子节点（子元素和文本）的元素，语法结构<code>$（&quot;：empty＂）</code><br>：empty过滤器可以和其他有效选择器配合使用，例如：<code>$（&quot;td：empty＂）</code><br>表示选择所有无内容的表格单元格元素&lt;\td&gt;。</p>
<h4 id="：parent"><a href="#：parent" class="headerlink" title="：parent"></a>：parent</h4><p>：parent过滤器用于选择包含子节点（子元素和文本）的元素，语法结构为：<code>$（&quot;：parent＂）</code><br>可以单独使用也可以配合使用。例如：<code>$（&quot;td：parent＂）</code><br>表示选择所有包含内容的表格单元格元素&lt;\td&gt;。注意段落元素&lt;\p&gt;起码包含一个子节点，即使该元素中没有任何文本内容。</p>
<h3 id="可见性过滤器"><a href="#可见性过滤器" class="headerlink" title="可见性过滤器"></a>可见性过滤器</h3><p>可见性过滤器根据元素的当前状态是否可见进行筛选。</p>
<h4 id="：hidden"><a href="#：hidden" class="headerlink" title="：hidden"></a>：hidden</h4><p>：hidden过滤器用于筛选出所有处于隐藏状态的元素，语法结构为：<code>$（&quot;：hidden＂）</code><br>可以单独使用也可以配合使用。例如：<code>$（&quot;p：hidden＂）</code><br>表示查找所有隐藏的段落元素&lt;\p&gt;。<br>如果元素在网页中不占用任何位置空间就被认为是隐藏的，具体有以下几种情况：</p>
<p>元素的高度和宽度明确设置为0；<br>在元素的css属性中的display的值设置为none；<br>表单元素的type属性设置为hidden；<br>元素的父元素处于隐藏状态，因此元素也一并无法显示出来；<br>下拉列表中的所有选项元素&lt;\option&gt;也被认为是隐藏的，无论其是否为selected状态。</p>
<h4 id="：visible"><a href="#：visible" class="headerlink" title="：visible"></a>：visible</h4><p>：visible过滤器用于筛选出所有处于可见状态的元素，语法结构为：<code>$（&quot;：visible＂）</code><br>可以单独使用也可以配合使用。：visible过滤器和：hidden过滤器的筛选条件完全相反，因此无法同时使用。<br>需要注意的是，元素处于以下几种特殊情况也被认为是可见状态</p>
<p>元素的透明度属性opacity设置为0，此时元素依然占据原来位置；<br>元素的可见性属性visibility设置为除hidden以外的其他值，此时元素依然占据原来位置；<br>当元素处于逐渐被隐藏的动画效果中时，到动画结束之前都被认为依然是可见的<br>当元素处于逐渐被显现的动画效果中时，从动画一开始启动就被认为是可见的。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>jQuery基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JS04--引用类型</title>
    <url>/2019/03/08/js04/</url>
    <content><![CDATA[<h1 id="JavaScript-引用类型"><a href="#JavaScript-引用类型" class="headerlink" title="JavaScript 引用类型"></a>JavaScript 引用类型</h1><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型的值是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也被称为类，引用类型有时候也被称为对象定义，因为它表述的是一类对象所具有的属性和方法。<br>ECMAScript提供了很多原生引用类型。</p>
<a id="more"></a>

<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>Object是ECMAScript使用最多的一个类型。创建Object实例的方式有两种：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var <span class="attribute">person</span>=new Object（）；</span><br><span class="line">person.<span class="attribute">name</span>=“Sara”；</span><br><span class="line">person.<span class="attribute">age</span>=29；</span><br></pre></td></tr></table></figure>
<p>使用对象字面量表示法。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">name：“Sara”，</span><br><span class="line">age：<span class="number">29</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>另一种表示方法：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=<span class="comment">&#123;&#125;</span>；<span class="comment">//与new Object（）相同</span></span><br><span class="line">person.<span class="keyword">name</span>=“Sara”；</span><br><span class="line">person.age=<span class="number">29</span>；</span><br></pre></td></tr></table></figure>
<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><p>虽然ECMAScript中的数据与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，第二个位置来保存数值，<br>第三个位置来保存对象，以此类推。而且ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p>
<ul>
<li>var colors=new Array（）；在使用Array构造函数的时候，可以省略new操作符。</li>
<li>使用数组字面量方法。<code>var colors=[“red”，“blue”，“green”]//创建一个包含三个字符串的数组</code><br>利用length属性在数组末尾添加新项：<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">var colors=[“red”，“blue”，“green”]<span class="comment">；//创建一个包含三个字符串的数组</span></span><br><span class="line">colors[colors.<span class="built_in">length</span>]=“<span class="keyword">black</span>”<span class="comment">；//在位置3添加一种颜色</span></span><br><span class="line">colors[colors.<span class="built_in">length</span>]=“brown”<span class="comment">；//在位置4添加一种颜色</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><p>用<code>instanceof</code>操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。为了解决这个问题，ECMAScript5<br>新增了<code>Array.isArray（）</code>方法。这个方法的目的是最终确定某个值到底是不是数组，而不管他是在那个全局执行环境中创建的。</p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>ECMAScript专门为数组提供了<code>push（）</code>和<code>pop（）</code>方法，以实现数组类似栈的行为。<code>push（）</code>方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而<code>popo（）</code>方法则从数组末尾移除最后一项，减少数组的lengh值，然后返回移除的项。例如：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span>=<span class="keyword">new</span> <span class="built_in">Array</span>（）；</span><br><span class="line"><span class="keyword">var</span> count=<span class="built_in">color</span>.push（“red”，“green”）；<span class="comment">//推入两项</span></span><br><span class="line">alert（count）；<span class="comment">//2</span></span><br><span class="line">count=<span class="built_in">color</span>.push（“black”）；<span class="comment">//推入另一项</span></span><br><span class="line">alert（count）；<span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> item=<span class="built_in">color</span>.pop（）；</span><br><span class="line">alert（item）；<span class="comment">//“black”，取得最后一项</span></span><br><span class="line">alert（<span class="built_in">color</span>.length）；<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>实现队列操作的数组方法就是<code>shift（）</code>，它能够移除数组中的第一个项并返回该项，同时将数组长度减1.结合<code>shift（）</code>和<code>push（）</code>方法，可以像使用队列一样使用数组。</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span>=<span class="keyword">new</span> <span class="built_in">Array</span>（）；</span><br><span class="line"><span class="keyword">var</span> count=<span class="built_in">color</span>.push（“red”，“green”）；<span class="comment">//推入两项</span></span><br><span class="line">alert（count）；<span class="comment">//2</span></span><br><span class="line">count=<span class="built_in">color</span>.push（“black”）；<span class="comment">//推入另一项</span></span><br><span class="line">alert（count）；<span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> item=<span class="built_in">color</span>.shift（）；</span><br><span class="line">alert（item）；<span class="comment">//“red”，取得第一项</span></span><br><span class="line">alert（<span class="built_in">color</span>.length）；<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript还为数组提供了一个<code>unshift（）</code>方法 ，同时使用<code>unshift（）</code>和<code>pop（）</code>方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p>数组中已经存在两个可以直接用来重排序的方法：<code>reverse（）和sort（）</code>。reverse（）方法会反转数组项的顺序。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var value=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>]；</span><br><span class="line">value.reverse（）；</span><br><span class="line">alert（value）；<span class="comment">//5，4，3，2，1</span></span><br></pre></td></tr></table></figure>
<p>sort（）按升序排列数组项———即最小的值位于前面，最大的值位于后面。为了实现排序，sort（）方法会调用每个数组项的toString（）转型方法，然后比较得到的字符串，以确定如何排序。即使数组中<br>的每一项都是数值，sort（）方法比较的也是字符串，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var value=[<span class="number">0</span>，<span class="number">1</span>，<span class="number">5</span>，<span class="number">10</span>，<span class="number">15</span>]</span><br><span class="line">value.sort（）；</span><br><span class="line">alert（value）；<span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>这种比较方法在很多时候都不是最佳方案，因此sort（）方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数位于第二个参数前面就返回一个负数，如果两个<br>参数相等，就返回0，如果第一个参数位于第二个参数后面就返回一个正数。<br>比较函数：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> compare（<span class="keyword">value</span><span class="number">1</span>，<span class="keyword">value</span><span class="number">2</span>）&#123;</span><br><span class="line"><span class="keyword">if</span>（<span class="keyword">value</span><span class="number">1</span>&lt;\<span class="keyword">value</span><span class="number">2</span>）</span><br><span class="line">&#123;<span class="keyword">return</span>-<span class="number">1</span>；&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>（<span class="keyword">value</span><span class="number">1</span>&gt;<span class="keyword">value</span><span class="number">2</span>）&#123;<span class="keyword">return</span> <span class="number">1</span>；&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="number">0</span>；&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var value=[<span class="number">0</span>，<span class="number">1</span>，<span class="number">5</span>，<span class="number">10</span>，<span class="number">15</span>]；</span><br><span class="line">value.sort（compare）；</span><br><span class="line">alert（value）；<span class="comment">//0，1，5，10，15</span></span><br></pre></td></tr></table></figure>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>其中<code>concat（）</code>方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
<p>下一个方法是<code>slice（）</code>，它能够基于当前数组中的一个或多个项创建一个新数组。可以包含以一个或两个参数，只有一个参数，则返回从该参数指定位置开始到结束位置的项。如果有两个参数，则返回起始位置和结束位置<br>之间的项，但是不包括结束位置的项。<code>slice（）</code>方法不会影响原数组。</p>
<h4 id="splice（）"><a href="#splice（）" class="headerlink" title="splice（）"></a>splice（）</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">删除：可以删除任意数量的项，splice（<span class="number">0</span>，<span class="number">2</span>）会删除数组中的前两项，要删除的第一项的位置和要删除的项数</span><br><span class="line">插入：起始位置、<span class="number">0</span>（要删除的项数）、和要插入的项。</span><br><span class="line">替换：可以向指定位置插入任意数量的项，起始位置、要删除的项数和要插入的任意数量的项。</span><br></pre></td></tr></table></figure>
<p>splice（）方法始终都会返回一个数组，该数组包含从原数组删除的项（没有删除就是返回一个空数组）。<br>位置方法<br>indexOf（）和lastIndexOf（）。其中indexOf（）方法从数组的开头开始向后查找，lastIndexOf（）方法则从数组的末尾开始向前查找。这两个方法都返回要查找项在数组中的位置，或者在没找到的情况下返回-1.<br>归并方法<br>reduce（）和reduceRight（）。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值，其中reduce（）从数组的第一项开始，reduceRight（）从数组的最后一项开始遍历到第一项。</p>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><p>创建一个日期对象：<code>var now =new Date（）</code>；再调用Date（）构造函数而不传递参数的情况下，创建的对象自动获得当前日期和时间。如果想获得特定的日期和时间可用两个方法<code>Date.parse（）</code>和<code>Date.UTC（）</code>。<br>其中<code>Date.parse（）</code>表示接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。例如为2004年5月25日创建一个日期对象：<code>var someDate=new Date（Date.parse（“May 25，2004”））.</code><br>等价于<code>var someDate=new Date（“May 25，2004”）</code>.因为后台会自动调用<code>Date.parse（）</code>方法。<br>Date.UTC（）在构建数值时使用不同的信息。参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天、小时数、分钟、秒以及毫秒数。只有两个参数是必须的：年和月。如果没有提供天数，则<br>假设天数为1，如果省略其他参数，则统统假设为0。<br>Date.now表示调用这个方法时的日期和时间的毫秒数</p>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><ul>
<li>toDateString():以特定于实现的格式显示星期几、月、日和 年</li>
<li>toTimeString()：以特定的格式显示时、分、秒和时区</li>
<li>toLocaleDateString()：以特定于地区的格式显示星期几、月、日和年</li>
<li>toLocaleTimeString():以特定的格式显示时、分、秒</li>
<li>toUTCStriing()：以特定于实现的格式完整的UTC日期</li>
</ul>
<h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><p>通过该类型来支持正则表达式。语法：<code>var expression=/pattern/flags</code>；每个正则表达式都可带有一个或多个标志，用以标明正则表达式的行为，正则表达式的匹配模式支持下列三个标志：</p>
<ul>
<li>g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配时立即停止；</li>
<li>i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写</li>
<li>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>例如：<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">匹配字符串中所有“<span class="built_in">at</span>”的实例：<span class="built_in">var</span> pattern1=/<span class="built_in">at</span>/g； 匹配第一个“bat”或“cat”，不区分大小写：<span class="built_in">var</span> pattern2=/【bc】<span class="built_in">at</span>/i； 匹配所有以“<span class="built_in">at</span>”结尾的<span class="number">3</span>个字符的组合，不区分大小写：<span class="built_in">var</span> pattern3=/.<span class="built_in">at</span>/gi 模式中所有的元字符必须使用转义，例如 匹配第一个“【bc】<span class="built_in">at</span>”，不区分大小写：<span class="built_in">var</span> pattern2=/\[bc\]<span class="built_in">at</span>/i； 匹配所有“.<span class="built_in">at</span>”，不区分大小写：<span class="built_in">var</span> pattern4=/\.<span class="built_in">at</span>/gi;</span><br></pre></td></tr></table></figure>
另一种创建正则表达式的方法是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串表达式，另一个是可选的标志字符串。<br>匹配第一个“bat”或“cat”，不区分大小写：<code>var pattern2=/[bc]at/i；</code><br>与pattern2相同，只不过是使用构造函数创建的：var pattern3=new RegExp（“[bc]at”，“i”）；</li>
</ul>
<h4 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h4><ul>
<li>global：布尔值，表示是否设置了g标志。</li>
<li>ignoreCase：布尔值，表示是否设置了i标志。</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline：布尔值，表示是都设置了m标志。</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>对象的主要方法有<code>exec（）</code>和<code>test（）</code>两种。<br>对于exec（）方法来讲，即使在模式中设置了全局标志（g），它每次也会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec（）将始终返回第一个匹配项的信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var text=“<span class="number">000</span><span class="number">-00</span><span class="number">-0000</span>”；</span><br><span class="line">var pattern=/\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">2</span>&#125;-\d&#123;<span class="number">4</span>&#125;/；</span><br><span class="line"><span class="keyword">if</span>（pattern.test（text））&#123;alert（“the pattern was matched”）&#125;；</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们想知道输入是不是有效。<br>RegExp实例继承的<code>toLacaleString（）</code>和<code>toString（）</code>方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var pattern=<span class="keyword">new</span> RegExp（“\\<span class="literal">[<span class="identifier">bc</span>\\]</span>at”,<span class="string">"gi"</span>）;</span><br><span class="line">alert(pattern.<span class="keyword">to</span><span class="constructor">String()</span>);<span class="comment">// /\[bc\]at/gi</span></span><br><span class="line">alert(pattern.<span class="keyword">to</span><span class="constructor">LocaleString()</span>);<span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>

<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><p>函数是对象，函数名是指针。所以一个函数可能会有多个名字。例如：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">function <span class="keyword">sum</span>（num1，num2）&#123;<span class="keyword">return</span> sum1+sum2；&#125;</span><br><span class="line">alert（<span class="keyword">sum</span>（<span class="number">10</span>，<span class="number">10</span>））；<span class="comment">//20</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">var</span> anotherSum=<span class="keyword">sum</span>；</span><br><span class="line">alert（anotherSum（<span class="number">10</span>，<span class="number">10</span>））；<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sum</span>=<span class="built_in">null</span>；</span><br><span class="line">alert（anotherSum（<span class="number">10</span>，<span class="number">10</span>））；<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>声明变量anotherSum与sum相等。此时sum和anotherSum都指向了同一个函数，因此anotherSum（）也可以调用并返回结果。即使sum设置为null，但仍然可以正常调用anotherSum（）。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>（<span class="title">num</span>）</span>&#123;<span class="keyword">return</span> num+<span class="number">100</span>；&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>（<span class="title">num</span>）</span>&#123;<span class="keyword">return</span> num+<span class="number">200</span>；&#125;</span><br><span class="line"><span class="keyword">var</span> result=add（<span class="number">100</span>）；<span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>这个例子声明了两个同名函数，结果是后面的函数覆盖了前面的 函数。以上代码和以下代码没有区别：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">add</span><span class="bash">=<span class="keyword">function</span>（num）&#123;<span class="built_in">return</span> num+100；&#125;；</span></span><br><span class="line"><span class="keyword">add</span><span class="bash">=<span class="keyword">function</span>（num）&#123;<span class="built_in">return</span> num+200；&#125;；</span></span><br><span class="line">var result=<span class="keyword">add</span><span class="bash">（100）；//300</span></span><br></pre></td></tr></table></figure>
<p>通过这个例子可以看出，在创建第二个函数时，实际上覆盖引用了第一个函数的变量。</p>
<h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><p>在函数内部，有两个特殊的对象：<code>arguments</code>和<code>this</code>。其中，arguments是一个类数组对象，包含着传入函数的所有参数。虽然arguments的主要用途是保存函数参数，但是这个对象还有一个名叫callee的属性，该属性是<br>一个指针，指向拥有这个arguments对象的函数。例子：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">function <span class="built_in">factorial</span>（<span class="built_in">num</span>）&#123;</span><br><span class="line"><span class="keyword">if</span>（<span class="built_in">num</span>&lt;=<span class="number">1</span>）&#123;<span class="built_in">return</span> <span class="number">1</span>；&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="built_in">return</span> <span class="built_in">num</span>*<span class="built_in">factorial</span>（<span class="built_in">num</span>-<span class="number">1</span>）；&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种耦合现象，可以用下列代码：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">function <span class="built_in">factorial</span>（<span class="built_in">num</span>）&#123;</span><br><span class="line"><span class="keyword">if</span>（<span class="built_in">num</span>&lt;=<span class="number">1</span>）&#123;<span class="built_in">return</span> <span class="number">1</span>；&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="built_in">return</span> <span class="built_in">num</span>*arguments.callee（<span class="built_in">num</span>-<span class="number">1</span>）；&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有引入函数名，这时无论函数使用的是什么名字，都可以保证正常完成递归调用。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial1=factorial；</span><br><span class="line">factorial=<span class="function"><span class="keyword">function</span>（）</span>&#123;<span class="keyword">return</span> <span class="number">0</span>；&#125;；</span><br><span class="line">alert （factorial1（<span class="number">5</span>））；<span class="comment">//120</span></span><br><span class="line">alert（factorial（<span class="number">5</span>））；<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>如果是用函数名来调用的话，这个函数出来的结果两个都为0.<br>一定要记住，函数的名字仅仅是一个包含指针的变量而已，函数才是对象，当复制函数名给另一个变量的时候，这时两个变量名都指向函数内容对象。</p>
<p>函数内部的另一个特殊对象是this。this引用的是函数执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)</p>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>每个函数都包含两个属性：<code>length</code>和<code>prototype</code>。其中，length属性表示函数希望接收的命名参数的个数。</p>
<p>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。诸如toString（）和valueOf()方法都保存在prototype名下。prototype属性是不可枚举的，，因此使用for-in方法无法实现。</p>
<p>每个函数都包括两个非继承而来的方法：<code>apply（）</code>和<code>call（）</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply（）方法接收两个参数：</p>
<ul>
<li>一个是在其中运行函数的作用域，另一个是参数数组。</li>
<li>第二个参数可以是Array实例也可以是arguments对象。<br>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>（<span class="title">num1</span>，<span class="title">num2</span>）</span>&#123;<span class="keyword">return</span> num1+num2；&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>（<span class="title">num1</span>，<span class="title">num2</span>）</span>&#123;<span class="keyword">return</span> sum.apply（<span class="keyword">this</span>，<span class="built_in">arguments</span>）；&#125;<span class="comment">//传入arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>（<span class="title">num1</span>，<span class="title">num2</span>）</span>&#123;<span class="keyword">return</span> sum.apply（<span class="keyword">this</span>，【num1，num2】）&#125;；<span class="comment">//传入数组</span></span><br><span class="line">alert（sum1（<span class="number">10</span>，<span class="number">10</span>））；<span class="comment">//20</span></span><br><span class="line">alert（sum2（<span class="number">10</span>，<span class="number">10</span>））；<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
call方法跟apply的作用相同，它们的区别仅在于接收参数的方式不同。对于call（）方法而言，第一个参数值是this值没有变化，变化的是其余参数都直接传递给函数。也就是说在使用call（）方法时，传递给函数的参数<br>必须逐个列举出来，如：<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>（num1，num2）&#123;<span class="keyword">return</span> num1+num2；&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> sum1（num1，num2）&#123;<span class="keyword">return</span> <span class="built_in">sum</span>.<span class="keyword">call</span>（this，num1，num2）；&#125;</span><br><span class="line">alert（sum1（<span class="number">10</span>，<span class="number">10</span>））；//<span class="number">20</span></span><br></pre></td></tr></table></figure>
事实上，传递参数并非call和apply的最大作用，它们真正强大的地方是能够扩充函数赖以运行的作用域。使用它们来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。</li>
</ul>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>ECMAScript还提供了3个特殊的引用类型：<code>Boolean（）</code>、<code>Number（）</code>、<code>String（）</code>。<br>引用类型与基本包装类型的只要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则指存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">var s1=“<span class="built_in">text</span>”；</span><br><span class="line">s1.<span class="built_in">color</span>=“<span class="built_in">red</span>”；</span><br><span class="line">alert（s1.<span class="built_in">color</span>）；<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>第二行代码试图为字符串添加一个color属性。但是当第三行代码再次访问s1时，color属性不见了。这是因为第二行创建的String对象在执行第三行代码时已经被销毁了。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>JS基础</tag>
        <tag>红宝书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JS03--变量</title>
    <url>/2019/03/07/js03/</url>
    <content><![CDATA[<h1 id="JavaScript变量笔记"><a href="#JavaScript变量笔记" class="headerlink" title="JavaScript变量笔记"></a>JavaScript变量笔记</h1><h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><p>ECMAScript变量可能包含两种不同数据类型的值：<code>基本类型值和引用类型值</code>。基本类型值指的是简单的数据端，而引用类型值指那些可能由多个值构成的对象。<br>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<a id="more"></a>

<h3 id="基础类型和引用类型的值"><a href="#基础类型和引用类型的值" class="headerlink" title="基础类型和引用类型的值"></a>基础类型和引用类型的值</h3><h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><p>1、如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var <span class="attribute">num1</span>=5；</span><br><span class="line">var <span class="attribute">num2</span>=num1；</span><br></pre></td></tr></table></figure>
<p>虽然用num1的值来初始化num2 的值，使num2也保存了5.但是num2中的5和num1中的5是完全独立的，该值只是num1中5的一个副本。此后两个变量可以参与任何操作而不会相互影响。</p>
<p>2、如果从一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个变量。复制操作结束后，两个变量实际上将引用同一个对象。因此改变其中一个变量，就会影响另一个变量。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=new <span class="keyword">Object</span>（）；</span><br><span class="line"><span class="keyword">var</span> obj2=obj1；</span><br><span class="line">obj1.<span class="keyword">name</span>=“Sara”；</span><br><span class="line">alert(obj2.<span class="keyword">name</span>);<span class="comment">//Sara</span></span><br></pre></td></tr></table></figure>
<p>因为obj1和obj2都是指向的同一个对象，所以这两个变量引用的也都是同一个对象，所以改变一个值以后，另一个也改变。</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>ECMAScript中所有函数的参数都是按值传递的。基本类型值的传递如同基本类型值变量的复制一样，引用类型值的传递如同引用类型变量的复制一样。<br>例子：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>（<span class="title">num</span>）&#123;</span></span><br><span class="line"><span class="built_in">num</span>+=<span class="number">10</span>；</span><br><span class="line"><span class="literal">return</span> <span class="built_in">num</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var count=<span class="number">20</span>；</span><br><span class="line">var <span class="built_in">result</span>=<span class="built_in">add</span>（count）；</span><br><span class="line">alert（count）<span class="comment">；//20，没有变化</span></span><br><span class="line">alert（<span class="built_in">result</span>）<span class="comment">；//30</span></span><br></pre></td></tr></table></figure>
<p>这里的函数add有一个参数num；而参数实际上是函数的局部变量。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20.于是数值20被复制给参数num一边在add（）中使用。在函数内部，参数num的值被加上了10，但这一变化不会印象函数外部的count<br>变量。参数num与变量count互不相识，它们仅仅是具有相同的值。假如是按引用传递的话，那么变量count的值也将变成30，从而反映函数内部的修改。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>（<span class="title">obj</span>）</span>&#123;</span><br><span class="line">obj.name=“Sara”；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>（）；</span><br><span class="line">setName（person）；</span><br><span class="line">alert（person.name）；<span class="comment">//“Sara”</span></span><br></pre></td></tr></table></figure>
<p>以上代码创建一个对象，并将其保存在了变量person中。然后这个变量被传递到了setName函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。修改例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>（<span class="title">obj</span>）</span>&#123;</span><br><span class="line">obj.name=“Sara”；</span><br><span class="line">obj=<span class="keyword">new</span> <span class="built_in">Object</span>（）；</span><br><span class="line">obj.name=“green”；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>（）；</span><br><span class="line">setName（person）；</span><br><span class="line">alert（person.name）；<span class="comment">//“Sara”</span></span><br></pre></td></tr></table></figure>
<p>这个例子与前面粒子的区别是，添加的两行代码，一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。如果person是按引用传递的话，那么person就会被自动修改为指向<br>其name属性值的新对象。但上式的结果说明了即使在函数内部修改了参数的值，但原始的引用仍然保持未变。在obj重写时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕之后立即被销毁。</p>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>用<code>typeof</code>操作符。<code>typeof</code>操作符是确定一个变量是字符串、数值、布尔值还是undefined的最佳工具。虽然在检测基本数据类型<code>typeof</code>是非常好的方法，但是我们在检测引用类型的值时，这个操作符的用处不大。通常我们并不是很想知道某个值是对象，而是想知道它是什么类型的对象。因此ECMAScript提供了<code>instanceof</code>操作符。如果变量是引用类型，那么<code>instanceof</code>操作符就会返回true。<br>例子：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">alert（person <span class="keyword">instanceof</span> <span class="built_in">Object</span>）；<span class="comment">//变量person是Object吗？</span></span><br><span class="line">alert（<span class="built_in">color</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>）；<span class="comment">//变量color是Array吗？</span></span><br><span class="line">alert（pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>）；<span class="comment">//变量pattern是RegExp吗？</span></span><br></pre></td></tr></table></figure>
<p>所以当检测基本数据类型的时候就可以用tyoeof操作符，当我们检测引用类型的数据类型时候就用instanceof操作符。</p>
<h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h3><p>执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>
<p>全局执行环境是最外围的一个执行环境。在Web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是最为window对象的属性和方法创建的。某个执行环境中的所有代码执行完以后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。</p>
<p>每个函数都有自己的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数有序访问。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>虽然执行环境的内容总共只有两种：全局和局部（函数），但还是有其他办法来延长作用域链。具体来说，就是当执行流进入到下列任何一个语句时，作用域链就会得到加长：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">catch</span>语句的<span class="keyword">catch</span>块</span><br><span class="line"><span class="keyword">with</span>语句</span><br></pre></td></tr></table></figure>
<p>这两个语句都会在作用域链的前端添加一个变量对象。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>例如：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（<span class="keyword">true</span>）</span><br><span class="line">&#123;</span><br><span class="line">var <span class="built_in">color</span>=“<span class="built_in">blue</span>”；</span><br><span class="line">&#125;</span><br><span class="line">alert（<span class="built_in">color</span>）；<span class="comment">//"blue”</span></span><br></pre></td></tr></table></figure>
<p>这里是在一个if语句中定义了变量color。如果实在c、c++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。<br>在使用for语句时候，尤其记住这一点。对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i计时在for循环执行结束后<br>也依旧会存在循环外部的执行环境中。</p>
<p><b>1、声明变量</b><br>使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with与剧中，最接近的环境就是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。</p>
<p><b>2、查询标识符</b><br>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上级逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程<br>停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到该变量名，则意味着该变量尚未声明。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理：找出那些不再继续使用的变量，然后释放其占用的内存。因此，垃圾收集器会按照固定的时间间隔，周期性的执行这一操作。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>JavaScript最常用的方式：<code>标记清除</code>，当变量进入环境就标记为“进入环境”，当变量离开就标记为“离开环境”。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>含义是跟踪记录每个值被引用的次数。当声明了一个引用类型值赋给该变量时，=则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另一个值，<br>则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>垃圾收集是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。<br>IE的垃圾收集是根据内存分配两运行的，具体说就是256个变量、4096个对象字面量和数组元素或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种是想方式的问题在于如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多变量。而这样一来，垃圾收集就不得不频繁的运行。结果由此引发的严重性能问题促使IE7重写了其垃圾收集例程。<br>触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>JavaScript在进行内存管理及垃圾收集时面临的问题还是优点与众不同。其中最主要的问题就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br>优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再游泳，最好通过将其值设置为null来释放引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。<br>不过解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让其值脱离执行环境，一边垃圾收集器下次运行时将其回收。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>JS基础</tag>
        <tag>红宝书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JS02--操作符</title>
    <url>/2019/03/06/js02/</url>
    <content><![CDATA[<h1 id="JavaScript操作符"><a href="#JavaScript操作符" class="headerlink" title="JavaScript操作符"></a>JavaScript操作符</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元加操作符"><a href="#一元加操作符" class="headerlink" title="一元加操作符"></a>一元加操作符</h3><p>放在数值前面，对数值不会产生任何影响。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span>=<span class="number">25</span>；<span class="built_in">num</span>=+<span class="built_in">num</span>；<span class="comment">//结果依然为25</span></span><br></pre></td></tr></table></figure>
<p>一元减操作符主要用于表示负数，例如将1转换成-1.例如：</p>
<a id="more"></a>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span>=<span class="number">25</span>；<span class="built_in">num</span>=-<span class="built_in">num</span>；<span class="comment">//结果依然为-25</span></span><br></pre></td></tr></table></figure>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>位操作符就是把数字全部转换成二进制01表示，然后依次对每个位进行相关的操作。</p>
<ul>
<li>按位非（“~”）：按位非操作的本质：操作数的负值减1。对比减一操作和按位非操作来说，由于按位非是在数值表示的最底层执行操作，因此速度更快。</li>
<li>按位与（“&amp;”)</li>
<li>按位或(“|”）</li>
<li>按位异或（“^”）：相同为0，不同为1</li>
<li>左移（“&lt;&lt;”）：左移不会影响操作数的符号位。出现空位用0填充。</li>
<li>有符号的右移（“&gt;&gt;”）：会将数值向右移动，但保留其符号位。遇到空位，就用符号位填充</li>
<li>无符号右移：（“&gt;&gt;&gt;”）：会将数值的所有32位都向右移动。遇到空位，用0填充。</li>
</ul>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><ul>
<li>逻辑非（“!”）；首先会将它的操作数转换为一个布尔值，然后再对其求反。返回的一定是布尔值</li>
<li>逻辑与（“&amp;&amp;”）适用于任何类型的操作数，但是不一定返回布尔值。如果第一个操作数是对象，则返回第二个操作数；如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；如果两个操作数都是对象，则返回第二个操作数；如果第一个操作数是null，则返回null；如果第一个操作数是NaN,则返回NaN；如果第一个操作数是undefined，则返回undefined。逻辑与属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</li>
<li>逻辑或（“||”）如果第一个操作数是对象，则返回一个操作数；如果第一个操作数的求值结果为false，则返回第二个操作数；如果两个操作数都是对象，则返回第一个操作数；如果两个操作数是null，则返回null；如果两个操作数是NaN,则返回NaN；如果两个操作数是undefined，则返回undefined。逻辑与属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</li>
</ul>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><ul>
<li>乘法（<code>*</code>） 除法（<code>/</code>）</li>
<li>求模（<code>%</code>）</li>
</ul>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><ul>
<li>加法（<code>+</code>）数值算法同加法，字符串：如果两个都是字符串，就直接将两个操作符拼接起来，如果一个是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li>
<li>减法（<code>-</code>）数值算法同剑法，与加法不同的是，如果一个操作数是字符串或者非数值型，则先将其转换成数值然后再相减。</li>
</ul>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=）这几个操作符都返回一个布尔值<br>如果是一个字符跟一个数值比较，会把该字符转换为数值，然后再比较</p>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><ul>
<li>相等和不相等（==、！=）：先转换再比较。null和undefined值是相等的；如果两个操作符都是对象，则比较他们是不是指向同一个对象。</li>
<li>全等和不全等（===、！==）：仅比较不转换<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var result1=（“<span class="number">55</span>”==<span class="number">55</span>）；<span class="comment">//true，因为转换后相等，null和undefined值是不相等的，因为他们是不同类型的值</span></span><br><span class="line">var result1=（“<span class="number">55</span>”===<span class="number">55</span>）；<span class="comment">//false，因为不同的数据类型不相等</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">（=）、（*=）、（/=）、（+=）、（-=）、（%=）、（&lt;&lt;=）、（&gt;&gt;=）、（&gt;&gt;&gt;=）</span><br></pre></td></tr></table></figure>
<p>switch语句在比较值时用的是全等操作符，因此不会发生类型转换（例如“10”不等于10）<br>函数在定义时不必指定是否返回值，函数会在执行完return语句之后停止并立即退出，因此，位于return语句之后的任何代码都不会执行。return语句也可以不带有任何返回值。<br>严格模式对函数有一些限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">不能把函数命名为<span class="built_in">eval</span>或<span class="built_in">arguments</span></span><br><span class="line">不能把参数命名为<span class="built_in">eval</span>或<span class="built_in">arguments</span></span><br><span class="line">不能出现两个命名参数同名的情况</span><br></pre></td></tr></table></figure>
<h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><p>ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便我们定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，是因为ECMAScript中的参数在内部使用一个数组来表示的。函数接收到的始终都是这个数组，而不关系数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p>其实arguments对象只是与数组类似，因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments【0】，第二个元素是arguments【1】，以此类推），使用length属性来确定传递进来多少个参数。</p>
<p>ECMAScript函数的一个重要特点：<code>命名的参数只提供便利，但不是必须的。如果有参数，对应位置的参数可以和arguments对象元素参数互用。</code></p>
<p>关于arguments的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。</p>
<p>没有传递值的命名参数将自动赋予undefined值。</p>
<p>ECMAScript函数没有重载，因为ECMAScript函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p>
<p>ECMAScript如果定义了两个名字相同的函数，则该名字只属于后定义的函数</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>JS基础</tag>
        <tag>红宝书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JS01--基本概念</title>
    <url>/2019/03/05/js01/</url>
    <content><![CDATA[<h1 id="JavaScript基本概念"><a href="#JavaScript基本概念" class="headerlink" title="JavaScript基本概念"></a>JavaScript基本概念</h1><p>我会根据我在《JavaScript高级程序设计》中学到的一些比较重要和基础的知识点笔记记下来，这些只是属于基础性和理论性的知识，还需要我去实践，从实践里面学到更多的知识。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JavaScript有三个组成部分：<code>ESMAScript(关键部分)、DOM（文档对象模型）、BOM（浏览器对象模型）</code></p>
<a id="more"></a>
<p>DOCTYPE作用：告诉浏览器用何种文档规范解释该文档。<br>有两种模式：混杂模式和标准模式，如果没有前面的DOCTYPE声明就是用混杂模式。<br>区分大小写，标识符的写法：采用驼峰大小写格式，第一个单词小写，剩下的每个单词的首字母大写，例如：myCare。<br>变量：用操作符var定义的变量将成为定义该变量的作用域中的局部变量。没有用var声明变量就是全局变量！<br>数据类型：ECMAScript有五种简单数据类型：<code>Undefined、Null、Boolean、Number、String</code>，一种复杂数据类型：Object。<br>对未初始化和未声明的变量执行typeof操作符都返回了undefined值；typeof不是函数，只是一个操作符</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message</span><br><span class="line">alert（<span class="keyword">typeof</span> message）<span class="comment">//“undefined”</span></span><br><span class="line">alert（<span class="keyword">typeof</span> age）<span class="comment">//“undefined”</span></span><br></pre></td></tr></table></figure>
<p>如果定义的变量用来保存对象，最好将该变量初始化为null</p>
<h3 id="undefined类型"><a href="#undefined类型" class="headerlink" title="undefined类型"></a>undefined类型</h3><p>undefined类型只有一个值，即特殊的<code>undefined</code>。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。<br>一般而言，不存在需要显式设置一个变量为undefined。字面值undefined的主要目的是用于比较。<br>对未初始化和未声明的变量执行typeof操作符都返回了undefined值。</p>
<h3 id="null类型"><a href="#null类型" class="headerlink" title="null类型"></a>null类型</h3><p>null类型是第二个只有一个值的数据类型，这个特殊的值是<code>null</code>。<br>如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。<br>位于undefined和null之间的相等操作符（==）总是返回true。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>该类型只有两个字面值：<code>true和false</code>。这两个值与数字不一样，因此true不一定等于1，而false也不一定等于0。<br>所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以次调用转型函数<code>Boolean（）</code>。<br>下表给出了各种数据类型及其对应的转换规则：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">数据类型	转换为<span class="literal">true</span>的值	转换为<span class="literal">false</span>的值</span><br><span class="line">Boolean	<span class="literal">true</span>	<span class="literal">false</span></span><br><span class="line"><span class="built_in">String</span>	任何非空字符串	<span class="string">""</span>(空字符串)</span><br><span class="line"><span class="built_in">Number</span>	任何非零数字值（包括无穷大）	<span class="string">"0和NaN</span></span><br><span class="line"><span class="string">Object	任何对象	"</span><span class="literal">null</span></span><br><span class="line"><span class="built_in">String</span>	不适用	undefined</span><br></pre></td></tr></table></figure>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。</p>
<p><b>不要测试某个特定的浮点数值！0.1加0.2不等于0.3，而是0.300000000000004</b><br>NaN：任何涉及NaN的操作都会返回NaN NaN 与任何数值都不相等<br>数值转换：有三个函数可以把非数值转换为数值：<code>Number（）、parseInt（）、parseFloat（）</code>。第一个函数即转型函数可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。<br>Number（）函数的转换规则如下：</p>
<ul>
<li>如果是Boolean值，true和法拉瑟将分别转换为1和0；</li>
<li>如果是数字值，则只是简单的传入和返回</li>
</ul>
<p>如果是null值，返回0<br>如果是undefined值，返回NaN<br>如果是字符串： 1：只包含数字，则将其转换为十进制数值，“1”为1，“123”为123； 2：如果字符串包含有效的浮点格式，会转换成为相对应的浮点数值（前导的零被忽略）； 3：如果字符串中包含有效的十六进制格式，就转换为相同大小的十进制整数值； 4：如果字符串是空的（不包含任何字符），则转换为0；%：其余格式为NaN<br>parseInt：例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="built_in">parseInt</span>（“<span class="number">123</span>blue”）；<span class="comment">//转换为1234</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="built_in">parseInt</span>（“”）；<span class="comment">//NaN，Number转换为0；</span></span><br><span class="line"><span class="keyword">var</span> num3=<span class="built_in">parseInt</span>（“<span class="number">0xA</span>”）；<span class="comment">//10（十六进制数）</span></span><br><span class="line"><span class="keyword">var</span> num4=<span class="built_in">parseInt</span>（<span class="number">22.5</span>）；<span class="comment">//22（小数点不是有效的数字字符会被忽略掉）</span></span><br><span class="line"><span class="keyword">var</span> num5=<span class="built_in">parseInt</span>（“<span class="number">070</span>”）；<span class="comment">//56（八进制数）</span></span><br><span class="line"><span class="keyword">var</span> num6=<span class="built_in">parseInt</span>（“<span class="number">70</span>”）；<span class="comment">//70（十进制数）</span></span><br><span class="line">因为<span class="keyword">var</span> num5=<span class="built_in">parseInt</span>（“<span class="number">070</span>”）；<span class="comment">//56（八进制数）在是否忽略前面的0而变成十进制和八进制上有矛盾，所以为这个函数提供第二个参数：转换时使用的基数（即使用多少进制）</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="built_in">parseInt</span>（“AF”，<span class="number">16</span>）；<span class="comment">//175</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="built_in">parseInt</span>（“AF”）；<span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num3=<span class="built_in">parseInt</span>（“<span class="number">10</span>”，<span class="number">2</span>）；<span class="comment">//2(二进制)</span></span><br><span class="line"><span class="keyword">var</span> num4=<span class="built_in">parseInt</span>（“<span class="number">10</span>”，<span class="number">8</span>）；<span class="comment">//8八进制)</span></span><br><span class="line"><span class="built_in">parseFloat</span>（）与<span class="built_in">parseInt</span>类似，也是从第一个字符开始解析每个字符，而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，但第二个小数点就是</span><br><span class="line">无效的，因此它后面的字符串都将被忽略。除了第一个小数点有效以外，它们的第二个区别就是<span class="built_in">parseFloat</span>（）始终都会忽略前面的零。它识别十六进制格式的字符串始终会被转换成为零。它只能解析十进制值.</span><br></pre></td></tr></table></figure>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串可以有双引号或单引号表示。<br>任何字符串的长度都可以通过访问其lengh属性取得，例如：<code>alert（text.length）</code><br>特点:ECMAScript中的字符是不可变的，一旦创建，他们的值就不能改变，要改变某个变量保存的字符串就要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。<br>转换为字符串：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）toString（），例如：<span class="keyword">var</span> found=<span class="keyword">true</span>； <span class="keyword">var</span> foundAsString=found.<span class="built_in">String</span>（）；<span class="comment">//字符串“true”；数值、布尔值、对象和字符串值都有toString（）方法，但null和undefined值没有这个方法。</span></span><br></pre></td></tr></table></figure>
<p>多数情况下，该方法没有传递参数，但是在调用数值的该方法时，可以传递一个参数：输出数值的基数。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span>=<span class="number">10</span>；</span><br><span class="line">alert （<span class="built_in">num</span>.toString（））；<span class="comment">//“10”</span></span><br><span class="line">alert （<span class="built_in">num</span>.toString（<span class="number">2</span>））；<span class="comment">//二进制“1010”</span></span><br><span class="line">alert （<span class="built_in">num</span>.toString（<span class="number">8</span>））；<span class="comment">//八进制“12”</span></span><br><span class="line">alert （<span class="built_in">num</span>.toString（<span class="number">16</span>））；<span class="comment">//十六进制“a”</span></span><br></pre></td></tr></table></figure>
<p>（2）另一种转型函数是：String（），这个函数能够将任何类型的值转换为字符串。规则如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">如果有toString（）方法，则调用该方法（无参数）并返回相应的值；如果值是<span class="literal">null</span>，则返回“<span class="literal">null</span>”；如果只是<span class="literal">undefined</span>，则返回“<span class="literal">undefined</span>”。即该函数转换了<span class="literal">null</span>和<span class="literal">undefined</span>的字面量。</span><br></pre></td></tr></table></figure>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>ECMAScript中的对象就是一组数据和功能的集合。创建方法：<code>var o=new Object（）</code>；<br>Obeject（）的每个实例都有如下属性和方法：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span>：保存着用于创建当前对象的函数。构造函数。</span></span><br><span class="line"><span class="function"><span class="title">hasOwnProperty</span>（<span class="title">propertyName</span>）：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中最为参数的属性名（<span class="title">propertyName</span>）必须要以字符串形式指定（例如：<span class="title">o</span>.<span class="title">hasOwnproperty</span><span class="params">("<span class="keyword">name</span>")</span>）。</span></span><br><span class="line"><span class="function"><span class="title">isPrototypeOf</span><span class="params">(<span class="keyword">object</span>)</span>：用于检查传入的对象是否是当前对象的原型。</span></span><br><span class="line"><span class="function"><span class="title">propertyIsEnumerable</span>（<span class="title">propertyName</span>）：用于检查给定的属性是否能够使用<span class="title">for</span>-<span class="title">in</span>语句来枚举。与<span class="title">hasOwnProperty</span>方法一样，作为参数的属性名必须以字符串表示。</span></span><br><span class="line"><span class="function"><span class="title">toLocalString</span>（）：返回对象的字符串表示，该字符串与执行环境的地区对应。</span></span><br><span class="line"><span class="function"><span class="title">toString</span>（）：返回对象的字符串表示</span></span><br><span class="line"><span class="function"><span class="title">valueOf</span>：返回对象的字符串、数值或布尔值表示。通常与<span class="title">toString</span>（）方法返回值相同。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>JS基础</tag>
        <tag>红宝书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端11--布局小总结</title>
    <url>/2019/03/03/%E5%B7%A9%E5%9B%BA92/</url>
    <content><![CDATA[<h1 id="网页布局中的小总结"><a href="#网页布局中的小总结" class="headerlink" title="网页布局中的小总结"></a>网页布局中的小总结</h1><p>今天一天都是自己动手敲代码的一天，跟着网上的网页布局设计图，把它分为一块一块的部分，然后每块每块的自己手动来敲，这个过程和这个设计图包括了我前面所学的CSS和HTML中的基本全部内容，布局，样式，都用上了，也算是对自己的一种巩固吧。这是我的网页布局demo网页布局作业.在这个过程中也遇到很多难题，一个一个都解决了，但是最让我印象深刻的就是下面这三个问题。</p>
<h2 id="如何把块放在父元素的底部"><a href="#如何把块放在父元素的底部" class="headerlink" title="如何把块放在父元素的底部"></a>如何把块放在父元素的底部</h2><p>要想达到这个效果只需要把该块的父元素设置为相对定位，把该块设置为绝对定位，然后在该块css中添加bottom：0；就可以达到我们想要的效果。例如：</p>
<a id="more"></a>
<p>HTML中代码：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child"</span>&gt;</span><br><span class="line">      位于底部</span><br><span class="line">            &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>css中代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>:absolute;</span><br><span class="line">	<span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这两个样式设定就可以达到我们想要的结果。</p>
<h2 id="绝对定位块如何水平居中"><a href="#绝对定位块如何水平居中" class="headerlink" title="绝对定位块如何水平居中"></a>绝对定位块如何水平居中</h2><p>当我在做我自己的第一份网页设计demo的时候，用到了绝对定位，但是我想的是把绝对定位的块放在底部并且能够水平居中，放在底部的代码上面已经实现了，但是整个绝对定位的块是靠近父元素最左边的，没有达到水平居中，并且margin：0 auto； 代码已经不管用了，所以接下来就是怎么让绝对定位的子元素能够在父元素中能够水平居中。<br>HTML代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child"</span>&gt;</span><br><span class="line">            &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;<span class="comment">/*定义宽度*/</span></span><br><span class="line">	<span class="attribute">position</span>:absolute;</span><br><span class="line">	<span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">	<span class="attribute">left</span>:<span class="number">50%</span>;<span class="comment">/*绝对定位距离左侧50%处也就是到页面中间处*/</span></span><br><span class="line">	<span class="attribute">margin-left</span>:-<span class="number">50px</span>;<span class="comment">/*左移动本身宽度的1/2以保证绝对水平居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的基本思路就是先用left：50%；来让左对齐的绝对定位块先中间对齐，此时的绝对定位块的头部在正中间，然后在已知该块宽度的情况下，再利用margin-left的负边距特性，将该块往左移动半个该块长度的距离。从而就实现了绝对定位水平居中并且放在底部的效果。</p>
<h3 id="如何使文字在div中水平和垂直居中"><a href="#如何使文字在div中水平和垂直居中" class="headerlink" title="如何使文字在div中水平和垂直居中"></a>如何使文字在div中水平和垂直居中</h3><p>这个其实很早以前就已经学过，但是可能是由于当时并没有相关的实践练习，所以对其中的一些概念理解得也不是很深入，到了在应用的时候，就会有点不知所措。<br>我用的方法就是使用text-align和line-height属性来设置的。<br>HTML代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"a"</span>&gt;</span><br><span class="line">      水平垂直居中</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">	<span class="attribute">text-align</span>:center;</span><br><span class="line">	<span class="attribute">line-height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话就实现了在div块中的文字能够水平居中。line-height是指行高，如果文本的行高跟它的父容器一样高的话，那么该文字就会垂直居中。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>今天自己看着网页设计稿，然后跟着它的分块解析把一块一块写出来，最后拼接在一起。网页设计稿是很简单的一个布局，，但是实现起来却还是会有很多意想不到的难点，这些难点一点一点的去解决，去查阅资料。去上网搜寻，最后想出解决办法，并且通过解决办法让自己能更加理解其中的理论知识，这种知识的获得与巩固是来源于自己的亲手实验操作的。得到的和学会的知识点也是更加记忆深刻的，所以这应该就是“实践出真知”吧。而我自己也希望在以后的许多动手实践过程中能够从实践原理中去更为深刻的理解其工作原理。以后也要多多练练手，多多积累实战经验和实战中遇到的难点，让自己能够从实战中学到更多。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>css布局</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端10--居中总结</title>
    <url>/2019/03/02/%E5%B7%A9%E5%9B%BA91/</url>
    <content><![CDATA[<h1 id="居中方法总结"><a href="#居中方法总结" class="headerlink" title="居中方法总结"></a>居中方法总结</h1><p>今天是根据网上提供的JPG和psd设计稿来实现网页的设计，首先先切图，然再敲网页代码，切图过程是需要涉及到使用ps的，而我也在学习切图的过程中，学习了ps，熟悉了它的一些基本操作。在敲代码的过程中也是遇到很多问题，但是经过这些问题的解决，自己的实际水平得到了更深一步的提高。<br>这是我这次作业的demo：转换图片格式到网页</p>
<a id="more"></a>
<h2 id="flex使用的一些注意"><a href="#flex使用的一些注意" class="headerlink" title="flex使用的一些注意"></a>flex使用的一些注意</h2><ul>
<li><code>justify-content</code>属性可适用于所有的flex容器，它的作用是设置flex子项（<code>flex items</code>）在主轴上的对齐方式，为center时候，元素之间没有间距紧挨在一起。<code>align-items</code>属性可以应用于所有的flex容器，它的作用是设置flex子项在每个flex行的交叉轴上的默认对齐方式。<code>align-content</code>只适用于多行的flex容器（也就是说容器中的子项不止一行时该属性才有效果），它的作用是当flex容器在交叉轴上有多余的空间时，将子项作为一个整体进行对其。<br>当只有当行元素时候，只有<code>align-items</code>属性起作用，<code>align-content</code>属性不起作用。且当元素高度不一致的时候，以最高元素高度为基准，实现水平垂直居中。<br>更注意的是，<code>align-items</code>实现的是子元素的垂直居中，并且居中对齐的基准线是最高元素的中心线，也就是说其余元素的中心线要跟最高元素的中心线对齐；但是<code>align-content</code>居中也是垂直居中，不过是让所有子元素的顶部对齐，不是以中心线为基准。还有一个区别是，当子项为多行的时候，<code>align-items</code>属性的flex容器会将交叉轴上的多于空间按照行数平均分给每行，然后每行各自按照各自所在的行居中对齐（每行的效果跟单行是一样的），但是align-content属性的flex容器是将子项最为一个整体，然后整体在flex容器上的交叉轴上居中对齐，对齐方式没变。</li>
</ul>
<p>综上可知对于<code>align-items</code>和<code>align-content</code>的区别我们记住以下三点：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">1、<span class="attribute">align-items</span>属性是针对单独的每一个<span class="attribute">flex</span>子项起作用，它的基本单位是每一个子项，在所有情况下都有效果。</span><br><span class="line">2、<span class="attribute">align-content</span>属性是将<span class="attribute">flex</span>子项作为一个整体起作用，它的基本单位是子项构成的行，只在子项为多行的情况下有效果</span><br><span class="line">3、<span class="attribute">align-items</span>是以子项元素中心线为基准对齐，<span class="attribute">align-content</span>是以子项顶部基准线对齐。</span><br></pre></td></tr></table></figure>
<p>让p内的内容超出div或者p的宽度自动换行<br>HTML代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">a1</span>"&gt;</span><br><span class="line">     <span class="symbol">shdiosahdjkcbdsiucdshfbsadvkj</span> <span class="symbol">sdcisdu</span> //内容</span><br><span class="line">     &lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;<span class="symbol">p</span> <span class="symbol">class</span>="<span class="symbol">a2</span>"&gt;</span><br><span class="line">     <span class="symbol">hdusaifkhbdsifygvjbasdiyfhdsagfbdivhcdsb</span>//内容</span><br><span class="line">     &lt;/<span class="symbol">p</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对应的CSS样式为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a1</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>:auto;</span><br><span class="line">	<span class="attribute">word-wrap</span>:break-word;</span><br><span class="line">	<span class="attribute">word-break</span>:break-all;</span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a2</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>:auto;</span><br><span class="line">	<span class="attribute">word-wrap</span>:break-word;</span><br><span class="line">	<span class="attribute">word-break</span>:break-all;</span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS详解："><a href="#CSS详解：" class="headerlink" title="CSS详解："></a>CSS详解：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">word-wrap：<span class="keyword">normal</span>|<span class="keyword">break</span>-word</span><br><span class="line"><span class="keyword">normal</span>：只在允许的断字点换行（浏览器默认值）</span><br><span class="line"><span class="keyword">break</span>-world:在长单词或URL地址内部进行换行。</span><br><span class="line">word-<span class="keyword">break</span>：<span class="keyword">normal</span>|<span class="keyword">break</span>-<span class="keyword">all</span>|keep-<span class="keyword">all</span></span><br><span class="line">norma<span class="variable">l:</span>使用浏览器默认的换行规则；</span><br><span class="line"><span class="keyword">break</span>-<span class="keyword">all</span>：允许在单词内换行；</span><br><span class="line">keep-<span class="keyword">all</span>：只能在半角空格或连字符处换行。</span><br></pre></td></tr></table></figure>
<h2 id="水平居中的方法总结"><a href="#水平居中的方法总结" class="headerlink" title="水平居中的方法总结"></a>水平居中的方法总结</h2><p>最近布局用到非常多的水平居中方法，尽管我也用过许多种，但是今天想要详细的记录一下。<br>方法一、<code>margin：0 auto；text-align:center</code><br>这种方法是实现CSS水平居中最最常用的，我在前端开发中大概有60%的CSS水平居中就是通过<code>“margin: 0 auto; text-align: center”</code>实现的。<br>用这个方法可以实现一个div块相对于body或者父元素水平居中，但是有一个前提是<b>必须已知该块的宽度</b>，也就是说要设置该块的宽度，只有这样计算机才能计算出该块相对于父元素的左右边距值！！！这两个属性都是添加在子元素中的。</p>
<p>方法二、<code>display:flex</code><br>随着越来越多兼容flexbox，所以通过<code>“display:flex”</code>实现CSS水平居中的方案也越来越受青睐。<br>通过<code>display:flex</code>实现CSS水平居中的原理是，父元素<code>display:flex;flex-direction:column;</code>而子元素<code>align-self:center;</code><br>这个跟CSS垂直居中的原理是一样的，只是在flex-direction上有所差别，一个是row(默认值)，另外一个是column。</p>
<p>方法三、<code>display:table-cell和margin-left实现CSS水平居中</code><br>前提条件是<b>父元素和子元素的宽度都确定的情况下</b>，通过计算得到的，<code>margin-left=（父元素宽度-子元素宽度）/2；父元素设置display：table-cell；</code><br>方法四、<code>position:absolute实现CSS水平居中。</code><br>前提条件是<b>父元素和子元素的宽度都确定</b>的情况下，父元素设置<code>position：absolute；子元素margin-left=（父元素宽度-子元素宽度）/2；</code><br>方法五、<code>width:fit-content实现CSS水平居中</code><br>可以在子元素宽度不确定的情况下使用该方法，需要配合<code>“margin: 0 auto; text-align: center”</code>使用。这三个属性都是添加在子元素中的。<br>方法六、<code>display:inline-block和text-align:center实现CSS水平居中</code><br>display:inline-block能改父元素内的子元素的表达样式，同样需要配合“margin: 0 auto; text-align: center”使用。display:inline-block属性添加在父元素中，margin: 0 auto; text-align: center属性添加在子元素中。</p>
<p>方法七、<code>position:relative、float:left和margin-left实现CSS水平居中。</code><br>给父元素样式position:relative，给子元素float:left和margin-left就可以实现CSS水平居中。同时使用条件是子元素和父元素的宽度都已知的情况下，子元素margin-left=（父元素宽度-子元素宽度）/2；</p>
<h2 id="垂直居中方法总结"><a href="#垂直居中方法总结" class="headerlink" title="垂直居中方法总结"></a>垂直居中方法总结</h2><p>方法一、<code>verticle-align:middle实现CSS垂直居中。</code><br>通过vertical-align:middle实现CSS垂直居中是最常使用的方法，但是有一点需要格外注意，vertical生效的前提是元素的display：inline-block。且这两个属性都是添加在子元素中。</p>
<p>方法二、<code>display:flex实现CSS垂直居中。</code><br>通过display:flex实现CSS垂直居中的方法是给父元素display:flex;而子元素align-self:center;这个跟CSS水平居中的原理是一样的，只是在flex-direction上有所差别，垂直居中是row(默认值)，水平居中是column。</p>
<p>方法三、<code>display:table-cell实现CSS垂直居中。</code><br>给父元素display:table，子元素添加display：table-cell和vertical-align：middle；的方式实现CSS垂直居中。注意对比和方法一的差别。</p>
<p>方法四、<code>line-height实现CSS垂直居中。</code><br>设置子元素的line-height值等于父元素的height，这种方法适用于子元素为单行文本的情况。</p>
<h2 id="水平垂直居中方法总结"><a href="#水平垂直居中方法总结" class="headerlink" title="水平垂直居中方法总结"></a>水平垂直居中方法总结</h2><h3 id="定宽高元素使用"><a href="#定宽高元素使用" class="headerlink" title="定宽高元素使用"></a>定宽高元素使用</h3><p>方法一、<code>position ，子元素已知宽度和高度</code></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">父元素设置为：<span class="attribute">position</span>: relative;</span><br><span class="line">子元素设置为：<span class="attribute">position</span>: absolute;</span><br></pre></td></tr></table></figure>
<p>距上50%，据左50%，然后利用margin的负边距特性减去元素自身宽度和自身高度的一半就可以实现<br>为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">wp</span>"&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">box</span> <span class="symbol">size</span>"&gt;<span class="symbol">123123</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"></span><br><span class="line">	 <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二、<code>absolute + margin auto</code><br>这种方式也要求居中元素的宽高必须固定，HTML代码如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">wp</span>"&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">box</span> <span class="symbol">size</span>"&gt;<span class="symbol">123123</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三、<code>absolute + calc</code><br>这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">wp</span>"&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">box</span> <span class="symbol">size</span>"&gt;<span class="symbol">123123</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;;</span><br><span class="line">    <span class="attribute">top</span>: calc(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">    <span class="attribute">left</span>: calc(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要知道宽度和高度的元素<br>方法四、<code>absolute + transform</code><br>还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">wp</span>"&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">box</span>"&gt;<span class="symbol">123123</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲translate设置为-50%，就可以做到居中了，代码如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法五、<code>lineheight</code><br>利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">wp</span>"&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">box</span>"&gt;<span class="symbol">123123</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>把box设置为行内元素，通过text-align就可以做到水平居中，通过vertical-align也可以在垂直方向做到居中，代码如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">line-height</span>: initial;</span><br><span class="line">    <span class="attribute">text-align</span>: left; <span class="comment">/* 修正文字 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法六、<code>flex布局</code><br>在父元素中添加代码</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;<span class="comment">//flex布局</span></span><br><span class="line"><span class="attribute">justify-content</span>: center;<span class="comment">//使子项目水平居中</span></span><br><span class="line"><span class="attribute">align-items</span>: center;<span class="comment">//使子项目垂直居中</span></span><br></pre></td></tr></table></figure>
<p>HTML代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"wp"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;<span class="number">123123</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">.wp &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>css布局</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端09--圣杯布局</title>
    <url>/2019/03/02/%E5%B7%A9%E5%9B%BA9/</url>
    <content><![CDATA[<h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><h2 id="圣杯模型"><a href="#圣杯模型" class="headerlink" title="圣杯模型"></a>圣杯模型</h2><p>圣杯模型就是分为三栏，中间一栏用来渲染自适应，左右两侧两栏是固定宽度。有三种办法可以实现三栏左右两栏宽度固定，中间自适应。</p>
<h3 id="绝对定位法"><a href="#绝对定位法" class="headerlink" title="绝对定位法"></a>绝对定位法</h3><p>左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。于是实现了三栏自适应布局。</p>
<a id="more"></a>
<p>HTML代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">left</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">main</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">right</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">body</span>&gt;</span><br></pre></td></tr></table></figure>
<p>CSS代码为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">top</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">left</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">right</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 210<span class="selector-tag">px</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTML代码中的三个div顺序是可以调换的，这与其他两种方法就不同了。<br>此方法的优点是，理解容易，上手简单，受内部元素影响而破坏布局的概率低，就是比较经得起折腾。<br>缺点在于：如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</p>
<h3 id="margin负值法"><a href="#margin负值法" class="headerlink" title="margin负值法"></a>margin负值法</h3><p>这种方法是在实际的网站中应用的最多的。<br>步骤一：给出HTML结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>中间弹性区<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>左边栏<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>右边栏<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>写结构的时候要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染。并且设置其自适应，也就是width:100%。<br>步骤二：给出每个盒子的样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span>，<span class="selector-tag">footer</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>；</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>; </span><br><span class="line">	<span class="attribute">background-color</span>: deeppink;</span><br><span class="line">	<span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>&#123; </span><br><span class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: blue;</span><br><span class="line">	<span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: darkorchid;</span><br><span class="line">	<span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的效果是三栏并没有在父元素的一行显示，左右两个盒子才会被挤下来，就是因为中间盒子我们给了百分之百的宽度。<br>那么如何让它们呈现出一行三列的效果呢？那就要让左边的盒子要到中间盒子的最左边，右边的盒子到中间盒子的最右边。换个想法，如果中间盒子不是100%的宽度，那么按照文档流，左边的盒子一定会在中间盒子的后面显示，接着显示右边的盒子。但是现在中间盒子是满屏了的，所以左右两个盒子被挤到下一行显示。我们要做到的是让左右两个盒子都上去。此时，CSS的负边距(negative margin)该上阵了。</p>
<p>步骤四：利用负边距布局<br>1、让左边的盒子上去<br>需要设置其左边距为负的中间盒子的宽度，也就是<code>.left {margin-left:-100%;}</code>。这样左盒子才可以往最左边移动。<br>2、让右边的盒子上去<br>需要设置其左边距为负的自己的宽度，也就是<code>.right {margin-left：-200px;}</code>。这样右盒子才可以在一行的最右边显示出自己。</p>
<p>步骤五：让中间一栏自适应调整<br>我们现在的确是硬性的实现了固比固布局。但是要记住，中间盒子是自适应的宽度，所以中间盒子里的内容会被左右盒子给压住一部分。这样的后果就是当我们在中间一栏写的内容非常多的时候，可能会有一部分内容被压在了左右两边两栏下面不能显示出来。所有我们现在要设置让中间一栏自适应调整。<br>首先，利用父级元素设置左右内边距的值，把父级的三个子盒子往中间挤。代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123; </span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的200px是左右盒子的宽度。这样的话，在页面的左右两边就留出来了左右两栏宽度的空白，用来存放两栏内容。<br>左右两边的内边距是有了，但是中间盒子上的内容还是被压着。<br>其次，给左右两个盒子加一个定位，加了定位之后左右两个盒子就可以设置left和right值。<br>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123; </span><br><span class="line">	<span class="attribute">position</span>: relative; </span><br><span class="line">	<span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">right</span>: -<span class="number">210px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，圣杯布局终于搞定了，也实现了我们要的效果，左右侧的盒子固定，中间盒子自适应，而且中间盒子的内容完全不受影响。<br>此方法的优点：三栏相互关联，可谓真正意义上的自适应，有一定的抗性——布局不易受内部影响。<br>缺点在于：相对比较难理解些，上手不容易，代码相对复杂。出现百分比宽度，过多的负值定位，如果出现布局的bug，排查不易。</p>
<h3 id="自身浮动法"><a href="#自身浮动法" class="headerlink" title="自身浮动法"></a>自身浮动法</h3><p>此方法代码最简单。应用了标签浮动跟随的特性。左栏左浮动，右栏右浮动，主体直接放后面，就实现了自适应。</p>
<p>HTML代码结构如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">left</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">right</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">main</span>"&gt;&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">body</span>&gt;</span><br></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 210<span class="selector-tag">px</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里三个div标签的顺序的关键是要把主体div放在最后，左右两栏div顺序任意。<br>此方法的优点是：代码足够简洁与高效<br>不足在于：中间主体存在克星，clear:both属性。如果要使用此方法，需避免明显的clear样式。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>css布局</tag>
        <tag>圣杯布局</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端08--css布局</title>
    <url>/2019/03/01/%E5%B7%A9%E5%9B%BA8/</url>
    <content><![CDATA[<h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是<code>block</code>或<code>inline</code>。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。</p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素：<code>header 、 footer 、 section</code>等等。</p>
<a id="more"></a>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>span 是一个标准的行内元素。一个行内元素可以在段落中 &lt; span&gt; 像这样 &lt;/ span&gt; 包裹一些文字而不会打乱段落的布局。 a 元素是最常用的行内元素，它可以被用作链接。</p>
<h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>另一个常用的display值是 none 。一些特殊元素的默认 display 值是它，例如<code>script</code>。<code>display:none</code>通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">它和 <span class="attribute">visibility</span> 属性不一样。把 <span class="attribute">display</span> 设置成 <span class="attribute">none</span> 元素不会占据它本来应该显示的空间，但是设置成 <span class="attribute">visibility</span>: hidden; 还会占据空间。</span><br></pre></td></tr></table></figure>
<h3 id="其他-display-值"><a href="#其他-display-值" class="headerlink" title="其他 display 值"></a>其他 display 值</h3><p>还有很多的更有意思的 display 值，例如<code>list-item</code>和<code>table</code><br>就像之前讨论过的，每个元素都有一个默认的 display 类型。不过你可以随时随地的重写它！虽然“人为制造”一个行内元素可能看起来很难以理解，不过我们可以把有特定语义的元素改成行内元素。常见的例子是：把 li 元素修改成 inline，制作成水平菜单。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>：<span class="selector-tag">auto</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置块级元素的<code>width</code>可以防止它从左到右撑满整个容器。然后就可以设置左右外边距为<code>auto</code> 来使其水平居中。元素会占据我们所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。</p>
<p>唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进下这个方案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">max-width</span></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下使用<code>max-width</code>替代<code>width</code> 可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要，调整下浏览器窗口大小检查下吧！<br>顺便提下， 所有的主流浏览器包括IE7+在内都支持 max-width ，所以放心大胆的用吧。</p>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>我们都知道css中是以盒模型来进行设计的，那么如果我们要设计网页应该怎么确定那些尺寸呢？以前的一些老办法是通过计算每一个边距的像素值，再把它们相加起来就是我们最后所得到的尺寸，现在有了新的办法可以更好的解决这个问题。<br>们慢慢的意识到传统的盒子模型不直接，所以他们新增了一个叫做 box-sizing 的CSS属性。当你设置一个元素为 <code>box-sizing: border-box;</code> 时，此元素的内边距和边框不再会增加它的宽度。这里有一个例子，两个元素都设置了 <code>box-sizing: border-box;</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.simple</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">     <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">          <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fancy</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid blue <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">     <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">          <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然没有比这更好的方法，一些CSS开发者想要页面上所有的元素都有如此表现。所以开发者们把以下CSS代码放在他们页面上</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">     <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">          <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以确保所有的元素都会用这种更直观的方式排版。</p>
<p>不过<code>box-sizing</code>是个很新的属性，目前还应该像上面例子中那样使用 <code>-webkit-</code>和<code>-moz-</code>前缀。</p>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position的属性值以及他们的含义我在第六天的博客里面有写到，如果想要继续了解<a href="../../../../../2019/02/27/巩固6/#more">可以点击这里</a></p>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>一个布局中常用的CSS属性是 float 。Float 可用于实现文字环绕图片，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的属性介绍在<a href="../../../../2019/02/26/巩固5/#more">我的这篇博文里面</a>。</p>
<h2 id="百分比宽度"><a href="#百分比宽度" class="headerlink" title="百分比宽度"></a>百分比宽度</h2><p>百分比是一种相对于包含块的计量单位。它对图片很有用：如下我们实现了图片宽度始终是容器宽度的50%。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至还能同时使用<code>min-width</code>和<code>max-width</code>来限制图片的最大或最小宽度！</p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight plain"><figcaption><span>Design” ```是一种让网站针对不同的浏览器和设备“呈现”不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！</span></figcaption><table><tr><td class="code"><pre><span class="line">媒体查询是做此事所需的最强大的工具。让我们使用百分比宽度来布局，然后在浏览器变窄到无法容纳侧边栏中的菜单时，把布局显示成一列：</span><br><span class="line">~~~</span><br><span class="line">@media screen and (min-width:600px) &#123;</span><br><span class="line">  nav &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">  section &#123;</span><br><span class="line">    margin-left: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:599px) &#123;</span><br><span class="line">  nav li &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line">使用 &#96;&#96;&#96;meta viewport&#96;&#96;&#96;之后可以让布局在移动浏览器上显示的更好。</span><br><span class="line"></span><br><span class="line">## inline-block</span><br><span class="line">以创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子：</span><br><span class="line">比较困难的方式，使用浮动：</span><br><span class="line">~~~</span><br><span class="line">.box &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  margin: 1em;</span><br><span class="line">&#125;</span><br><span class="line">.after-box &#123;</span><br><span class="line">  clear: left;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line">用容易的方式（使用 inline-block）来达到跟上述代码相同的效果：</span><br><span class="line">~~~</span><br><span class="line">.box2 &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  margin: 1em;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line">有一些事情需要牢记：</span><br><span class="line">&lt;b&gt;vertical-align 属性会影响到 inline-block 元素，可能会把它的值设置为 top 。</span><br><span class="line">需要设置每一列的宽度&lt;&#x2F;b&gt;</span><br><span class="line">如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙</span><br><span class="line">~~~</span><br><span class="line">nav &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">  width: 25%;</span><br><span class="line">&#125;</span><br><span class="line">.column &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">  width: 75%;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line">## flexbox</span><br><span class="line">弹性盒子[在我的这边博文里有详细介绍](..&#x2F;..&#x2F;..&#x2F;..&#x2F;2019&#x2F;02&#x2F;28&#x2F;巩固7&#x2F;#more)如果想要了解，点击即可。</span><br><span class="line"></span><br><span class="line">## 对齐方式</span><br><span class="line">### 水平居中：</span><br><span class="line">#### 行内元素的水平居中</span><br><span class="line">如果被设置元素为文本、图片等行内元素时，在父元素中设置text-align:center实现行内元素水平居中，将子元素的display设置为inline-block，使子元素变成行内元素</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot; style&#x3D;&quot;background-color: gray;&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot; style&#x3D;&quot;background-color: lightblue;&quot;&gt;DEMO&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.parent&#123;text-align: center;&#125;    </span><br><span class="line">.child&#123;display: inline-block;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">~~~</span><br><span class="line">#### 块状元素的水平居中（定宽）</span><br><span class="line">当被设置元素为定宽块级元素时用 text-align：center 就不起作用了。可以通过设置“左右margin”值为“auto”来实现居中的</span><br><span class="line">~~~</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot; style&#x3D;&quot;background-color: gray;&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot; style&#x3D;&quot;background-color: lightblue;&quot;&gt;DEMO&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.child&#123;</span><br><span class="line">           width: 200px;</span><br><span class="line">           margin: 0 auto;</span><br><span class="line">       &#125;</span><br><span class="line">~~~</span><br><span class="line">#### 块状元素的水平居中（不定定宽）</span><br><span class="line">在实际工作中我们会遇到需要为“不定宽度的块级元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。</span><br><span class="line"></span><br><span class="line">可以直接给不定宽的块级元素设置&#96;&#96;&#96;text-align：center&#96;&#96;&#96;来实现，也可以给父元素加&#96;&#96;&#96;text-align:center&#96;&#96;&#96;来实现居中效果。</span><br><span class="line"></span><br><span class="line">当不定宽块级元素的宽度不要占一行时，可以设置display 为&#96;&#96;&#96;inline&#96;&#96;&#96;类型或&#96;&#96;&#96;inline-block&#96;&#96;&#96;（设置为 行内元素 显示或行内块元素）</span><br><span class="line">~~~</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.container&#123;text-align:center;background: beige&#125;</span><br><span class="line">.container ul&#123;list-style:none;margin:0;padding:0;display:inline-block;&#125;</span><br><span class="line">.container li&#123;margin-right:8px;display:inline-block;&#125;</span><br><span class="line">~~~</span><br><span class="line">### 垂直居中：</span><br><span class="line">和水平居中一样，这里要讲垂直居中，首先设定两个条件即父元素是盒子容器且高度已经设定</span><br><span class="line"></span><br><span class="line">#### 子元素是行内元素，高度是由其内容撑开的</span><br><span class="line">这种情况下，需要通过设定父元素的line-height为其高度来使得子元素垂直居中</span><br><span class="line">~~~</span><br><span class="line">&lt;div class&#x3D;&quot;wrap line-height&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;span&quot;&gt;111111&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.wrap&#123;</span><br><span class="line">            width:200px ;</span><br><span class="line">            height: 300px;</span><br><span class="line">            line-height: 300px;</span><br><span class="line">            border: 2px solid #ccc;</span><br><span class="line">        &#125;</span><br><span class="line">.span&#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">~~~</span><br><span class="line">#### 子元素是块级元素但是子元素高度没有设定</span><br><span class="line">在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整，但是还是存在一些解法。</span><br><span class="line">通过给父元素设定&#96;&#96;&#96;display:table-cell;vertical-align:middle&#96;&#96;&#96;来解决</span><br><span class="line">~~~</span><br><span class="line">&lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;non-height &quot;&gt;11111&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.wrap&#123;</span><br><span class="line">       width:200px ;</span><br><span class="line">       height: 300px;</span><br><span class="line">       border: 2px solid #ccc;</span><br><span class="line">　　　　display: table-cell;</span><br><span class="line">　　　　vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"> .non-height&#123;</span><br><span class="line">       background: green;</span><br><span class="line">        &#125;</span><br><span class="line">~~~</span><br><span class="line">子元素是块级元素且高度已经设定</span><br><span class="line">计算子元素的margin-top或margin-bottom，计算方法为父(元素高度-子元素高度)&#x2F;2</span><br><span class="line">~~~</span><br><span class="line"> &lt;div class&#x3D;&quot;wrap &quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;div1&quot;&gt;111111&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.wrap&#123;</span><br><span class="line">            width:200px ;</span><br><span class="line">            height: 300px;</span><br><span class="line">            border: 2px solid #ccc;</span><br><span class="line">        &#125;</span><br><span class="line">.div1&#123;</span><br><span class="line">            width:100px ;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 100px;</span><br><span class="line">            background: darkblue;</span><br><span class="line">        &#125;</span><br><span class="line"> ~~~</span><br><span class="line">### 水平垂直居中：</span><br><span class="line">#### 水平对齐+行高</span><br><span class="line">+&#96;&#96;&#96;text-align + line-height&#96;&#96;&#96;实现单行文本水平垂直居中</span><br><span class="line">#### 水平+垂直对齐</span><br><span class="line">1、&#96;&#96;&#96;text-align + vertical-align&#96;&#96;&#96;在父元素设置&#96;&#96;&#96;text-align&#96;&#96;&#96;和&#96;&#96;&#96;vertical-align&#96;&#96;&#96;，并将父元素设置为&#96;&#96;&#96;table-cell&#96;&#96;&#96;元素，子元素设置为&#96;&#96;&#96;inline-block&#96;&#96;&#96;元素</span><br><span class="line">2、若子元素是图像，可不使用&#96;&#96;&#96;table-cell&#96;&#96;&#96;，而是其父元素用行高替代高度，且字体大小设为0。子元素本身设置&#96;&#96;&#96;vertical-align:middle</span><br></pre></td></tr></table></figure>
<p>3.3相对+绝对定位<br>用<code>absolute</code>，利用绝对定位元素的盒模型特性，在偏移属性为确定值的基础上，设置<code>margin:auto</code>.</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>css布局</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端07--弹性盒子</title>
    <url>/2019/02/28/%E5%B7%A9%E5%9B%BA7/</url>
    <content><![CDATA[<h1 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h1><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>弹性盒子是一种新技术，但在如今各个浏览器都广泛支持的情况下，它已经开始准备广泛应用了。 弹性盒子提供了工具，允许快速创建曾经被证明用CSS很难实现的一些复杂，灵活的布局和功能。<br>长久以来，唯一可用的且有稳定的跨浏览器兼容性的能用来构建 CSS 布局的工具只有 floats 和 positioning。这些都很好而且有效，但是在某些布局方面它们就有限制，并且难以实现。<br>以下简单的布局要求是难以或不可能用这样的工具（ floats 和 positioning）方便且灵活的实现的：</p>
<a id="more"></a>
<ul>
<li>在父内容里面垂直居中一个块内容。</li>
<li>使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。</li>
<li>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</li>
</ul>
<p>首先，我们需要选择将哪些元素将设置为柔性的盒子。我们需要给这些 flexible 元素的父元素 display 设置一个特定值。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex 模型说明<code>当元素表现为 flex 框时，它们沿着两个轴来布局：</code></p>
<p><code>主轴（main axis）</code>是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <code>main start</code>和<code>main end</code>。<br><code>交叉轴（cross axis）</code>是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为<code>cross start</code>和<code>cross end</code>。<br>设置了<code>display: flex</code>的父元素（如是&lt; section&gt;）被称之为 flex 容器（flex container）。<br>在 flex 容器中表现为柔性的盒子的元素被称之为 flex 项（flex item）。</p>
<h3 id="列还是行"><a href="#列还是行" class="headerlink" title="列还是行"></a>列还是行</h3><p>弹性盒子提供了<code>flex-direction</code>这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）— 它默认值是 row，这使得它们在按我们浏览器的默认语言方向排成一排（在英语/中文浏览器中是从左到右）。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: column;</span><br></pre></td></tr></table></figure>
<p>添加该代码到css代码里面去会看到，这会将那些元素设置为列布局。<br>注意：还可以使用<code>row-reverse</code>和<code>column-reverse</code>值反向排列 flex 项目。</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>当我们在布局中使用定宽或者定高的时候，可能会有一个问题出来即处于容器中的 弹性盒子子元素会溢出，破坏了布局。解决此问题的一种方法是将以下声明添加到父元素css 规则中：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">flex-<span class="keyword">wrap</span>: <span class="keyword">wrap</span></span><br></pre></td></tr></table></figure>
<p>同时把以下规则也添加到子元素中：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">200px</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们有了多行 弹性盒子— 任何溢出的元素将被移到下一行。但是这里我们可以做得更多。首先，改变<code>flex-direction</code> 属性值为<code>row-reverse</code>— 会看到仍然有多行布局，但是每一行元素排列的方向和原来是相反的了。</p>
<h3 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a>flex-flow 缩写</h3><p>到这里，应当注意到存在着<code>flex-direction</code>和<code>flex-wrap</code> 的缩写<code>flex-flow</code>。比如可以将</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: row wrap;</span><br></pre></td></tr></table></figure>
<p>flex 项的动态尺寸</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。<br>本例中，我们设置 &lt; article&gt; 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。</p>
<p>现在在上一个规则下添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在刷新，会看到第三个 &lt; article&gt; 元素占用了两倍的可用宽度和剩下的一样 — 现在总共有四个比例单位可用。 前两个 flex 项各有一个，因此它们占用每个可用空间的1/4。 第三个有两个单位，所以它占用2/4或这说是1/2的可用空间。<br>还可以指定 flex 的最小值。 尝试修改现有的 article 规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表示“每个flex 项将首先给出200px的可用空间，然后，剩余的可用空间将根据分配的比例共享“。 尝试刷新，会看到分配空间的差别。</p>
<p>弹性盒子的真正价值可以体现在它的<b>灵活性/响应性</b>，如果调整浏览器窗口的大小，或者增加一个 &lt; article&gt; 元素，这时的布局仍旧是好的。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">flex</span>: <span class="string">缩写与全写</span></span><br><span class="line"><span class="attr">flex</span> <span class="string">是一个可以指定最多三个不同值的缩写属性：</span></span><br></pre></td></tr></table></figure>
<p>第一个就是上面所讨论过的无单位比例。可以单独指定全写 flex-grow 属性的值。<br>第二个无单位比例 — flex-shrink — 一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。<br>第三个是上面讨论的最小值。可以单独指定全写 flex-basis 属性的值。<br>我们建议不要使用全写属性，除非你真的需要（比如要去覆盖之前写的）。使用全写会多写很多的代码，它们也可能有点让人困惑。</p>
<h3 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h3><p>还可以使用 弹性盒子的功能让 flex 项沿主轴或交叉轴对齐。<br>在css中添加代码规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新一下页面，就会看到相关内容垂直水平居中了</p>
<p><code>align-items</code>控制 flex 项在交叉轴上的位置。<br>默认的值是<code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。我们的第一个例子在默认情况下得到相等的高度的列的原因。<br>在上面规则中我们使用的 center 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。<br>也可以设置诸如<code>flex-start</code>或<code>flex-end</code>这样使<code>flex</code>项在交叉轴的开始或结束处对齐所有的值。<br>可以用<code>align-self</code>属性覆盖<code>align-items</code>的行为。比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">justify-content</span>控制 <span class="selector-tag">flex</span> 项在主轴上的位置。</span><br></pre></td></tr></table></figure>
<p>默认值是<code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。<br>也可以用 flex-end 来让 flex 项到结尾处。<br>center 在 justify-content 里也是可用的，可以让 flex 项在主轴居中。<br>值 space-around 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。<br>还有一个值是 space-between，它和 space-around 非常相似，只是它不会在两端留下任何空间。<br>CSS里的一种简单的垂直居中布局的方法了，例如代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.vertical-container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>:         flex;</span><br><span class="line">  <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">          <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h3><p>弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。<br>代码也很简单，将下面的 CSS 添加到示例代码下面。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 flex 项默认的 order 值是 0。<br>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。<br>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是2，1，1和0，那么它们的显示顺序就分别是第四，第二，第三，和第一。<br>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。<br>flex 嵌套<br>弹性盒子也能创建一些颇为复杂的布局。设置一个元素为flex项目，那么他同样成为一个 flex 容器，它的孩子(直接子节点)也表现为 flexible box 。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>弹性盒子</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端06--定位</title>
    <url>/2019/02/27/%E5%B7%A9%E5%9B%BA6/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h2><p>定位的整个想法是允许我们覆盖基本文档流行为，以产生有趣的效果。如果想稍微改变布局中一些盒子的位置，使它们的默认布局流程位置稍微有点古怪，不舒服的感觉呢？定位是我们的工具。或者，如果想要创建一个浮动在页面其他部分顶部的UI元素，并且/或者始终停留在浏览器窗口内的相同位置，无论页面滚动多少？定位使这种布局工作成为可能。<br>有许多不同类型的定位，可以对HTML元素生效。要使某个元素上的特定类型的定位，我们使用position属性。</p>
<a id="more"></a>
<h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><p>静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置 ——这里没有什么特别的。<br>静态定位是默认行为！</p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对定位是我们将要看的第一个位置类型。<br>相对于以前的位置移动，偏移前的位置保留不动。在使用相对定位时，就算元素被偏移了，但是他仍然占据着它没偏移前的空间。它与静态定位非常相似，占据在正常的文档流中，除了你仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠。 让我们继续并更新代码中的<code>position</code>属性：<code>position: relative;</code><br>如果在此阶段保存并刷新，则结果根本不会发生变化。那么如何修改元素的位置呢？ 需要使用<code>top，bottom，left和right</code>属性。<br>top, bottom, left, 和 right 来精确指定要将定位元素移动到的位置，注意：这些属性的值可以采用逻辑上期望的任何单位<code>——px，mm，rems，％</code>等。<br>例如添加代码：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">30px</span>;</span><br></pre></td></tr></table></figure>
<p>得到的结果是它移动到了底部和右边，但是我们指定的确实顶部和左边，听起来不合逻辑，但是这是相对定位的工作方式，我们需要考虑一个看不见的力，推动定位的盒子的一侧，移动它的相反方向。所以例如top：30px；是指定一个力推动框的顶部，使其向下移动30px；</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位带来了非常不同的结果。绝对定位代码中的位置声明如：<code>position: absolute;</code><br>首先，请注意，定位的元素应该在文档流中的间隙不再存在，绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能……<br>第二，注意元素的位置已经改变——这是因为top，bottom，left和right以不同的方式在绝对定位。它们指定元素应距离每个包含元素的边的距离，而不是指定元素应该移入的方向。 所以在这种情况下，我们说的绝对定位元素应该位于从“包含元素”的顶部30px，从左边30px。</p>
<p>absolute 是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。<br>如果元素是绝对定位的，则它相对于它的父元素定位。</p>
<h4 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h4><p>如果所有的父元素都没有显式地定义<code>position</code>属性，那么所有的父元素默认情况下<code>position</code>属性都是<code>static</code>。结果，绝对定位元素会被包含在初始块容器中。这个初始块容器有着和浏览器视口一样的尺寸，并且&lt; html&gt;元素也被包含在这个容器里面。简单来说，绝对定位元素会被放在 &lt; html&gt;元素的外面，并且根据浏览器视口来定位。<br>绝对定位元素在HTML源代码中，是被放在&lt; body&gt;中的，但是在最终的布局里面，它离页面(而不是&lt; body&gt;)的左边界、上边界有30px的距离。我们可以改变定位上下文 —— 绝对定位的元素的相对位置元素。通过设置其中一个父元素的定位属性 —— 也就是包含绝对定位元素的那个元素（如果要设置绝对定位元素的相对元素，那么这个元素一定要包含绝对定位元素）。</p>
<h4 id="介绍z-index"><a href="#介绍z-index" class="headerlink" title="介绍z-index"></a>介绍z-index</h4><p>所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。 当我们有不止一个的时候呢？<br>尝试添加以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: lime;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“z-index”是对z轴的参考。可以从源代码中的上一点回想一下，我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 （0,0）位于页面（或元素）的左上角，x和y轴跨页面向右和向下（适合从左到右的语言，无论如何）。<br>网页也有一个z轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有z-index为auto，实际上为0。<br>要更改堆叠顺序，可以将以下声明添加到CSS规则中：<code>z-index: 1;</code><br>请注意，<code>z-index</code>只接受无单位索引值；我们不能指定我们想要一个元素是Z轴上23像素—— 它不这样工作。 较高的值将高于较低的值，这取决于我们使用的值。 使用2和3将产生与300和40000相同的效果。</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样<code>top 、 right 、 bottom 和 left</code>属性都可用。<br>还有一种类型的定位覆盖——fixed。 这与绝对定位的工作方式完全相同，只有一个主要区别：绝对定位固定元素是相对于 &lt; html&gt; 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。 这意味我们可以创建固定的有用的UI项目，如持久导航菜单。<br>body规则如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1400px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们要给&lt; h1&gt;元素 position: fixed;，并让它坐在视口的顶部中心。将以下规则添加到CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>0```;是要使它贴在屏幕的顶部；我们然后给出标题与内容列相同的宽度，并使用可靠的老技巧```margin: 0 auto;``` 使它居中。 然后我们给它一个白色背景和一些内边距，所以内容将不会在它下面可见。</span></figcaption><table><tr><td class="code"><pre><span class="line">如果现在保存并刷新，会看到一个有趣的小效果，标题保持固定，内容显示向上滚动并消失在其下。 但是我们可以改进这一点——目前标题下面挡住一些内容的开头。这是因为定位的标题不再出现在文档流中，所以其他内容向上移动到顶部。</span><br><span class="line">个固定定位元素不会保留它原本在页面应有的空隙（脱离文档流）。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;令人惊讶地是移动浏览器对 fixed 的支持很差。</span><br></pre></td></tr></table></figure>
<h3 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position: sticky"></a>position: sticky</h3><p>还有一个定位值可用，叫做<code>position: sticky</code>，是一个比其他属性要新一些的属性。这基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从视口顶部10像素），之后它变得固定。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>定位</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端05--框模型</title>
    <url>/2019/02/26/%E5%B7%A9%E5%9B%BA5/</url>
    <content><![CDATA[<h1 id="巩固框模型"><a href="#巩固框模型" class="headerlink" title="巩固框模型"></a>巩固框模型</h1><p>今天继续巩固一些CSS知识点，我所记的都是我平时容易忽略或者记得不是非常熟悉的知识点，要想看全面的知识点的话可以去看我前面的CSS笔记博文，上面就是一系列比较详细的知识点，第二次所学的系列里面都是比较零散的知识点。</p>
<h2 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h2><p>文档的每个元素被构造成文档布局内的一个矩形框，框每层的大小都可以使用一些特定的CSS属性调整。相关属性如下:</p>
<h3 id="width-和-height"><a href="#width-和-height" class="headerlink" title="width 和 height"></a>width 和 height</h3><p>width和height设置内容框（content box）的宽度和高度。内容框是框内容显示的区域——包括框内的文本内容，以及表示嵌套子元素的其它框。</p>
<a id="more"></a>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>padding表示一个 CSS 框的内边距 ——这一层位于内容框的外边缘与边界的内边缘之间。该层的大小可以通过简写属性padding 一次设置所有四个边，或用 <code>padding-top、padding-right、padding-bottom 和 padding-left</code> 属性一次设置一个边。</p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>CSS 框的边界（border）是一个分隔层，位于内边距的外边缘以及外边距的内边缘之间。边界的默认大小为0——从而让它不可见——不过我们可以设置边界的厚度、风格和颜色让它出现。 border 简写属性可以让我们一次设置所有四个边，例如<code>border: 1px solid black;</code> 但这个简写可以被各种普通书写的更详细的属性所覆盖：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-top, <span class="built_in">border</span>-right, <span class="built_in">border</span>-bottom, <span class="built_in">border</span>-left: 分别设置某一边的边界厚度／风格／颜色。</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">width</span>, <span class="built_in">border</span>-<span class="built_in">style</span>, <span class="built_in">border</span>-<span class="built_in">color</span>: 分别仅设置边界的厚度／风格／颜色，并应用到全部四边边界。</span><br></pre></td></tr></table></figure>
<p>也可以单独设置某一个边的三个不同属性，如<code>border-top-width, border-top-style, border-top-color</code>等。</p>
<h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>外边距（margin）代表 CSS 框周围的外部区域，称为外边距，它在布局中推开其它 CSS 框。其表现与 padding 很相似；简写属性为 margin，单个属性分别为 <code>margin-top、margin-right、margin-bottom 和 margin-left。</code><br><b>注意:</b> 外边距有一个特别的行为被称作外边距塌陷（<code>margin collapsing</code>）：当两个框彼此接触时，它们的间距将取两个相邻外边界的最大值，而非两者的总和。</p>
<h3 id="完全改变盒模型"><a href="#完全改变盒模型" class="headerlink" title="完全改变盒模型"></a>完全改变盒模型</h3><p>一个盒子的总宽度是指它的<code>内容宽度（width）、边内距（padding）、边界（border</code>值之和，如果想要一个盒子的总宽度为某个值，并且包括所有的边距和边界值之和，那我们就可以用属性<code>box-sizing</code>调整盒模型。 用值<code>border-box</code>，它将盒模型更改为这样新的模型。该模型的特点是总宽度等于上面一种情况的内容宽度，这里的总宽度也是包括内容、内边距和边界值，不过是宽度值一定，把属于内容以外的其他值都加在了宽度里面，即这里的width不仅仅指内容，还指padding和border的值。</p>
<h3 id="盒子的显示模型"><a href="#盒子的显示模型" class="headerlink" title="盒子的显示模型"></a>盒子的显示模型</h3><p><code>display</code>可以有很多种不同的值, 其中三种常见的值为<code>block, inline, 和 inline-block</code>。</p>
<ul>
    <li>
块盒(block box)是被定义为堆放在其它盒子之上的盒子（即盒子之前以及之后的内容出现在不同的行上），并且可以给它设置高度和宽度。上面所述的整个盒模型都适用于块盒。</li>
<li>行内盒（inline box）与块盒相反：它跟随文档的文本流堆放（即，它会与周围的文本和其它行内元素出现在同一行，并且其内容会像段落中的文本行一样，随着文本流换行）。宽度和高度设置对行内盒无效；在行内盒上的所有内边距、外边距和边界设置会改变周围文本的位置，但是不会影响周围块盒的位置。</li>
<li>行内块盒（inline-block box）介于前两者之间： 它会像行内盒一样，跟随周围的文本流堆放，不会在其前后创建换行；不过，它可以像块盒一样，使用宽度和高度设置大小，并且维护其块完整性 — 它不会跨段落行换行（对于一行文本容纳不下的行内盒，会落到第二行上，因为第一行上没有足够的空间容纳它，并且不会跨两行换行）。
块级元素默认设置为display: block; ，行内元素默认设置为 display: inline; 。
</li>
</ul>

<p>不常见的值：<br>同时， display 属性也有一些不常用的值，在以后你将会遇到。其中一些已经出现了有一段时间，并且可以很好的被支持, 而另一些则比较新，不能够被很好的支持。这些值通常是为了使创建网页/网页应用更简单而被创造出来。最被关注的有这些:</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">display</span>: <span class="meta">table</span> — 允许你像处理<span class="meta">table</span>布局那样处理非<span class="meta">table</span>元素，而不是滥用HTML的&lt; <span class="meta">table</span>&gt;标签来达到同样的目的。了解更多相关信息请查看。</span><br><span class="line"><span class="meta">display</span>: flex — 允许你处理一些困扰CSS已久的一些传统布局问题，例如布置一系列弹性等宽容器或者垂直居中内容。</span><br><span class="line"><span class="meta">display</span>: grid — 给出一种简单实现CSS网格系统的方式，而在传统上它依赖于一些棘手难以处理的CSS网格框架。</span><br></pre></td></tr></table></figure>
<h4 id="溢流"><a href="#溢流" class="headerlink" title="溢流"></a>溢流</h4><p>当使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。我们使用overflow属性来控制这种情况的发生。它有一些可能的值，但是最常用的是：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">auto:</span> 当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。</span><br><span class="line"><span class="symbol">hidden:</span> 当内容过多，溢流的内容被隐藏。</span><br><span class="line"><span class="symbol">visible:</span> 当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为）</span><br></pre></td></tr></table></figure>
<h3 id="背景裁剪（Background-clip）"><a href="#背景裁剪（Background-clip）" class="headerlink" title="背景裁剪（Background clip）"></a>背景裁剪（Background clip）</h3><p>框的背景是由颜色和图片组成的，它们堆叠在一起（<code>background-color</code>, <code>background-image</code>）。 它们被应用到一个盒子里，然后被画在盒子的下面。默认情况下，背景延伸到了边界外沿。这通常是OK的，但是在一些情况下比较讨厌（假使你有一个平铺的背景图，你只想要它延伸到内容的边沿会怎么做？），该行为可以通过设置盒子的background-clip属性来调整。</p>
<h3 id="轮廓-Outline"><a href="#轮廓-Outline" class="headerlink" title="轮廓(Outline)"></a>轮廓(Outline)</h3><p>最后，还有重要的一点， 一个框的 outline 是一个看起来像是边界但又不属于框模型的东西。它的行为和边界差不多，但是并不改变框的尺寸（更准确的说，轮廓被勾画于在框边界之外，外边距区域之内）</p>
<h2 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h2><p>float具有包裹性，如果定义一个普通的div块，它的宽度会随着页面布满，即它的宽度等于页面的宽度，但是在div块里面添加float属性以后，该块里面宽度会随着该块里面的内容而决定。所以float属性具有包裹性。同时float属性还具有清空格的特点，如</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  width：50px；</span><br><span class="line">  border：1px solid white：</span><br><span class="line">&#125;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br></pre></td></tr></table></figure>
<p>该代码中的三张图片排列的时候中间会有空格，但是如果加了float属性以后，图片排列之间没有空格，紧致排列：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  width：50px；</span><br><span class="line">  border：1px solid white；</span><br><span class="line">  float：left；</span><br><span class="line">&#125;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br><span class="line">img&lt;<span class="attribute">src</span>=<span class="string">"..."</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>“清空格”</code>这一特性的根本原因是由于float会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系的，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>现在我们已经知道了关于 float 属性的一些有趣事实，不过很快就能够碰到一个问题——所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕。有一种简单的方法可以解决这个问题—— clear 属性。当我们把这个应用到一个元素上时，它主要意味着”此处停止浮动”——这个元素和源码中后面的元素将不浮动，除非稍后将一个新的float声明应用到此后的另一个元素。<br>clear 可以取三个值：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="literal">left</span>：停止任何活动的左浮动</span><br><span class="line"><span class="literal">right</span>：停止任何活动的右浮动</span><br><span class="line"><span class="literal">both</span>：停止任何活动的左右浮动</span><br></pre></td></tr></table></figure>
<p>clear 属性被用于<code>控制浮动</code>。比较下面两个例子：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;div class="box"&gt;</span>...<span class="params">&lt;/div&gt;</span></span><br><span class="line"><span class="params">&lt;section&gt;</span>...<span class="params">&lt;/section&gt;</span></span><br><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  float:</span> left;</span><br><span class="line"><span class="symbol">  width:</span> <span class="number">200</span>px;</span><br><span class="line"><span class="symbol">  height:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">  margin:</span> <span class="number">1</span>em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中， <code>section</code> 元素实际上是在 div 之后的（译注：DOM结构上）。然而 div 元素是浮动到左边的，于是 section 中的文字就围绕了 div ，并且 section 元素包围了整个元素。如果我们想让 section 显示在浮动元素之后呢？</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  float:</span> left;</span><br><span class="line"><span class="symbol">  width:</span> <span class="number">200</span>px;</span><br><span class="line"><span class="symbol">  height:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">  margin:</span> <span class="number">1</span>em;</span><br><span class="line">&#125;</span><br><span class="line">.after-<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  clear:</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">&lt;div class="box"&gt;</span>...<span class="params">&lt;/div&gt;</span></span><br><span class="line"><span class="params">&lt;section class=“.after-box”&gt;</span>...<span class="params">&lt;/section&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 clear 我们就可以将这个段落移动到浮动元素 div 下面。</p>
<p>对于清除浮动（<code>clearfix hack</code>），当图片比包含它的元素还高，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且它是浮动的，于是它就会溢出到容器外面！有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）.<br>让我们加入一些新的CSS样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮动问题"><a href="#浮动问题" class="headerlink" title="浮动问题"></a>浮动问题</h2><h3 id="1、整个宽度可能难以计算"><a href="#1、整个宽度可能难以计算" class="headerlink" title="1、整个宽度可能难以计算"></a>1、整个宽度可能难以计算</h3><p>如果给我们的这些浮动框加上样式时，比如添加背景、外边距、内边距等等，问题就来了。我们原来的布局已经损坏，由于内边距和边界引入的额外宽度，可能会使我们原有的布局损坏掉。<br>有两个方法可以解决问题，最好的方法是给html加上下面的css：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">box</span>-sizing: <span class="built_in">border</span>-<span class="built_in">box</span>;</span><br><span class="line">&#125; <span class="built_in">box</span>-sizing 通过更改盒模型来拯救我们，盒子的宽度取值为 <span class="built_in">content</span> + padding + <span class="built_in">border</span>，</span><br><span class="line">而不仅是之前的<span class="built_in">content</span>——所以当增加内边距或边界的宽度时，不会使盒子更宽——而是会使内容调整得更窄。</span><br></pre></td></tr></table></figure>
<h3 id="2、浮动项目的背景高度"><a href="#2、浮动项目的背景高度" class="headerlink" title="2、浮动项目的背景高度"></a>2、浮动项目的背景高度</h3><p>如果我们给每一个浮动框都加一个固定的高度，我们可以通过给所有的框的列定义一个固定高度来实现。<br>然而在许多情况下这并不理想——它使设计呆板。如果能保证列中总是有相同数量的内容，这是可以的，但这并不总是如此——在很多类型的网站上，内容也会定期更改。</p>
<p>这正是像flexbox这样的新布局技术所解决的问题。Flexbox可以自动地延长列，这样他们就会像最长的一列一样。</p>
<p>也可以考虑：</p>
<p>将这些列的背景颜色设置为父元素的背景颜色，这样您就不会看到高度是不同的。这是目前最好的选择。<br>将它们设置为固定的高度，并使内容滚动overflow (参见我们溢流部分的示例。)<br>使用一种叫做伪列（faux columns）的技术——这包括将背景(和边界)从实际的列中提取出来，并在列的父元素上画一个伪造的背景，看起来像列的背景一样。不幸的是，这将无法处理列边界。</p>
<h3 id="3、清除浮动会很复杂"><a href="#3、清除浮动会很复杂" class="headerlink" title="3、清除浮动会很复杂"></a>3、清除浮动会很复杂</h3><p>布局变得更加复杂清理（clearing）也会变得更加复杂。需要确保所有的浮动都能尽快清除，以避免它们给下方的内容制造麻烦。如果没有一个方便的容器来进行清理，那么在必要的时候使用clearfix块。</p>
<h3 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h3><p>如果是要调整两个浮动块的相对位置的话，不能用margin，只能用width：x%，且用百分数来表示的话更直观，因为每个屏幕的尺寸不一样，但是百分数都是表示在屏幕长度的百分之几，这样也比较直观。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>今天按照网页上面给布置的作业题，写了三个非常简单的简历，主要是运用今天和前几天所学的浮动和表格的相关内容，整个给我最大的感触就是，虽然看着一个简历可能很简单，就是由几个行列组成而已，但是真正实施起来还是有一定的繁琐度的，比如尺寸的选择，颜色的确定，边界线的显示与否，等等等。第一个做的简历是非常基本的，什么也没用到，主要运用的是排版结构，第二个就是稍微复杂一点，用到了今天所复习的浮动，最后一个是最复杂的，看起来很简单，它只是一个表格，但是写起来却是最复杂的，需要考虑空元素，行列元素，还要考虑在表格元素里面再添加表格等等问题，但是通过自己亲手一点一点的写代码最后组建了一个跟网页上相似的简历的时候，成就感还是非常大的，今天学到了很多东西，对类选择器和id选择器的运用更加熟练了，对浮动的定义和运用也更加深入了，总之今天收获满满！</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>框模型</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端04--背景+边框+列表+表格</title>
    <url>/2019/02/26/%E5%B7%A9%E5%9B%BA4/</url>
    <content><![CDATA[<h1 id="背景-边框-列表-表格"><a href="#背景-边框-列表-表格" class="headerlink" title="背景+边框+列表+表格"></a>背景+边框+列表+表格</h1><p>继续巩固CSS样式<br>今天继续巩固学习CSS样式中的背景、边框和列表属性。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>元素的背景是指，在元素内容、内边距和边界下层的区域。默认情况下就是这样——在新的浏览器中，你可以使用 <code>background-clip</code>属性改变背景所占用的区域。<br>背景并不在外边距下层——外边距不是元素区域的一部分，而是元素外面的区域。</p>
<a id="more"></a>
<p>还有很多其他的属性可以用来操作元素的背景：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-color: 为背景设置一个纯色。</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">image</span>: 指定在元素的背景中出现的背景图像。</span><br><span class="line">这可以是静态文件，也可以是生成的渐变。</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">position</span>:指定背景应该出现在元素背景中的位置。</span><br><span class="line"><span class="built_in">background</span>-repeat: 指定背景是否应该被重复(平铺)。</span><br><span class="line"><span class="built_in">background</span>-attachment: 当内容滚动时，指定元素背景的行为，例如，它是滚动的内容，还是固定的?</span><br><span class="line"><span class="built_in">background</span>: 在一行中指定以上五个属性的缩写。</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>: 允许动态调整背景图像的大小。</span><br></pre></td></tr></table></figure>
<p>着重讲解<b>color、repeat、image、position</b>这四个属性</p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>1、color：首先，大多数元素的默认背景颜色不是white，而是transparent。<br>此外，设置背景颜色作为后备也是很重要的。背景颜色在各处都得到了支持，而背景梯度等更奇异的特性只在较新的浏览器中得到支持，加上背景图像可能由于某种原因无法加载。因此，设置基本的背景颜色和指定这些特性是一个好主意，因此无论如何，元素的内容都是可读的。<br>用法：<code>background-color：#ffff（或者yellow等颜色单词）</code></p>
<h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><p>2、background-image 属性指定了在元素背景中显示的背景图像。该属性最简单的用法是使用 url() 函数——–它以一个参数的路径作为参数——获取一个静态图像文件来插入，例如：<code>background-image: url( https: //mdn.mozillademos.org/files/13026/fire-ball-icon.png );</code><br>在默认情况下，图像在水平和垂直方向上都是重复的，这看起来不太好。我们可以使用background-repeat来修复这个问题。</p>
<h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h3><p>3、background-repeat允许指定背景图像是如何重复的。默认值是repeat，它使图像一直重复，直到整个元素的背景被填充。在这种情况下，这不是我们想要的(虽然可能在某些情况下是，例如，repeating-background.html)。其他常见的和广泛支持的值是：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">no-<span class="keyword">repeat</span>: 图像将不会重复:它只会显示一次。</span><br><span class="line"><span class="keyword">repeat</span>-<span class="symbol">x</span>: 图像将在整个背景中水平地重复。</span><br><span class="line"><span class="keyword">repeat</span>-<span class="symbol">y</span>: 图像会在背景下垂直地重复。</span><br><span class="line"><span class="keyword">repeat</span>: 图像将在整个背景中水平和竖直地重复。</span><br></pre></td></tr></table></figure>
<h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><p>4、background-position 允许我们在背景中任意位置放置背景图像。通常，该属性将使用两个通过空格分隔的值，该空间指定了图像的水平(x)和垂直(y)坐标。图像的左上角是原点(0,0)。把背景想象成一个图形，x坐标从左到右，y坐标从上到下<br>该属性可以接受许多不同的值类型，最常用的是：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">像px这样的绝对值——比如 <span class="built_in">background</span>-<span class="built_in">position</span>: 200px 25px.</span><br><span class="line">像rems 这样的相对值——比如 <span class="built_in">background</span>-<span class="built_in">position</span>: 20<span class="built_in">rem</span> <span class="number">2.</span>5<span class="built_in">rem</span>.</span><br><span class="line">百分比 ——比如 <span class="built_in">background</span>-<span class="built_in">position</span>: <span class="number">90</span><span class="symbol">%</span> <span class="number">25</span><span class="symbol">%</span>.</span><br><span class="line">关键字——比如 <span class="built_in">background</span>-<span class="built_in">position</span>: right <span class="built_in">center</span>. 这两个值是直观的，可以分别取值比如 left，<span class="built_in">center</span>， right和 top，<span class="built_in">center</span>， bottom。</span><br><span class="line">应该注意，我们可以混合并匹配这些值，比如 <span class="built_in">background</span>-<span class="built_in">position</span>: <span class="number">99</span><span class="symbol">%</span> <span class="built_in">center</span>。还要注意，如果只指定一个值，那么该值将被假定为水平值，而垂直值将默认为<span class="built_in">center</span>。</span><br></pre></td></tr></table></figure>
<h3 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h3><p>5、 background-image还有另一组可用的值——颜色渐变，渐变就是在背景中平滑的颜色过渡。动态生成的渐变是在不久之前引入的，这是因为在web设计中使用渐变是非常受欢迎的，但是使用背景图像来实现渐变是相当不灵活的。目前有两种类型的渐变——线性渐变(从一条直线到另一条直线)和径向渐变(从一个点发散出来)。</p>
<h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear gradient"></a>linear gradient</h2><p>线性渐变是通过<code>linear-gradient()</code>函数传入的，它是一个<code>background-image</code>属性的值。函数至少需要用逗号分隔的三个参数——背景中渐变的方向，开始的颜色和结尾的颜色。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, orange, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个渐变将从上到下，从顶部的橙色开始，然后平稳过渡到底部的黄色。可以使用关键字来指定方向 （to bottom，to right， to bottom right等）， 或角度值 (0deg相当于 to top，90deg 相当于 to right，直到 360deg，它再次相当于 to top ）。<br>也可以在颜色定义的渐变中指定其他的点——这些被称为颜色站点(color stops)，浏览器会计算出每一组颜色站点之间的颜色渐变。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, yellow, orange <span class="number">40%</span>, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个渐变从上往下，从顶部（高度为0%处）到橙色指定位置（高度为40%处），由黄色向橙色渐变，然后再由该位置到底部（高度为100%处），由橙色向黄色渐变。我们可以指定任意多个颜色站点，也可以使用其他的单位来指定这些颜色站点的位置，例如rem，px等。</p>
<p>注意，还可以使用<code>repeating-linear-gradient()</code>函数来设置一个重复的线性渐变。它的工作方式完全相同，只不过你设置的模式会不断重复，直到背景的边沿。例如：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">image</span>: repeating-<span class="built_in">linear</span>-gradient(to right, yellow, orange 25px, yellow 50px);</span><br></pre></td></tr></table></figure>
<p>这将会产生一个渐变，从黄色到橙色，再沿着渐变的每50个像素再回来。<br>用度数来表示的时候：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">background-image:linear-gradient(</span><br><span class="line"><span class="number">0</span>deg,</span><br><span class="line"><span class="built_in">rgb</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line"><span class="built_in">rgb</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"><span class="number">0</span>deg <span class="keyword">is</span> equivalent <span class="keyword">to</span> <span class="keyword">to</span> top.</span><br><span class="line"><span class="number">90</span>deg <span class="keyword">is</span> equivalent <span class="keyword">to</span> <span class="keyword">to</span> <span class="built_in">right</span>.</span><br><span class="line"><span class="number">180</span>deg <span class="keyword">is</span> equivalent <span class="keyword">to</span> <span class="keyword">to</span> bottom.</span><br><span class="line"><span class="number">270</span>deg <span class="keyword">is</span> equivalent <span class="keyword">to</span> <span class="keyword">to</span> <span class="built_in">left</span>.</span><br><span class="line"><span class="number">360</span>deg brings you back <span class="keyword">to</span> <span class="keyword">to</span> top again.</span><br></pre></td></tr></table></figure>
<p>透明渐变：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">background-image:linear-gradient(</span><br><span class="line">to right,</span><br><span class="line">rgba(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1</span>),</span><br><span class="line">rgba(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0.5</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>最后一个属性表示透明度，1表示不透明，0表示完全透明。</p>
<h2 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial gradient"></a>radial gradient</h2><p>语句：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">radial-gradient(</span><br><span class="line"><span class="keyword">position</span>,</span><br><span class="line"><span class="built_in">size</span> and <span class="built_in">shape</span>,</span><br><span class="line">colour stops</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>由于浏览器的不同版本，可能会有浏览器的兼容问题。所以完整的写法为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-webkit-radial-gradient(<span class="number">50</span>% <span class="number">50</span>%, circle, rgb(<span class="number">75</span>, <span class="number">75</span>, <span class="number">200</span>), rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>));</span><br><span class="line">-moz-radial-gradient(<span class="number">50</span>% <span class="number">50</span>%, circle, rgb(<span class="number">75</span>, <span class="number">75</span>, <span class="number">200</span>), rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>));</span><br><span class="line">-ms-radial-gradient(<span class="number">50</span>% <span class="number">50</span>%, circle, rgb(<span class="number">75</span>, <span class="number">75</span>, <span class="number">200</span>), rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>));</span><br><span class="line">-o-radial-gradient(<span class="number">50</span>% <span class="number">50</span>%, circle, rgb(<span class="number">75</span>, <span class="number">75</span>, <span class="number">200</span>), rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>));</span><br><span class="line">radial-gradient(circle at <span class="number">50</span>% <span class="number">50</span>%, rgb(<span class="number">75</span>, <span class="number">75</span>, <span class="number">200</span>), rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>));</span><br><span class="line">position：第一个<span class="number">20</span>%是指直径水平方向从左边开始的<span class="number">20</span>%处，第二个<span class="number">20</span>%是指直径纵向从上顶点开始的长度的<span class="number">20</span>%处。<span class="number">50</span>% <span class="number">50</span>%就是原点处。</span><br></pre></td></tr></table></figure>
<h2 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h2><p>另一个可供选择的选项是指定当内容滚动时它们是如何滚动的。这是使用<code>background-attachment</code>属性来控制的，该属性可以使用以下值：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scroll</span>: 会使元素的背景在页面滚动时滚动。如果元素内容滚动了，背景并不会滚动。实际上，背景固定在了页面上相同的位置，所以当页面滚动时它才滚动。</span><br><span class="line">fixed: 会使元素的背景相对于视口固定。因此不管当页面还是元素内容滚动时，它都不会滚动，它会始终保持在屏幕上相同的位置。</span><br><span class="line"><span class="keyword">local</span>:这个值后来被添加了(它只在Internet Explorer <span class="number">9</span>+中得到支持，而其他的则在IE4+中得到支持)，因为<span class="keyword">scroll</span>值相当混乱，并且在许多情况下并没有真正做您想要的事情。 <span class="keyword">local</span> 值将背景设置为它所设置的元素的背景，因此当您滚动元素时，背景会随之滚动。</span><br></pre></td></tr></table></figure>
<h3 id="多个背景"><a href="#多个背景" class="headerlink" title="多个背景"></a>多个背景</h3><p>最近(自从Internet Explorer 9)，我们已经具备了将多个背景连接到单个元素的能力。这是一件好事，因为多重背景非常有用。用逗号分隔不同的背景定义：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(image.png) no-repeat <span class="number">99%</span> center,</span><br><span class="line"><span class="built_in">url</span>(background-tile.png),</span><br><span class="line"><span class="built_in">linear-gradient</span>(to bottom, yellow, #dddd00 <span class="number">50%</span>, orange);</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些背景都是堆叠在一起的，第一个出现在顶部，第二个在下面，第三个，等等。这可能不是我们所期待的，所以要小心。还要注意的是，我们已经将后备背景颜色放入一个单独的属性声明中，因为尝试将其包含在多个背景中似乎会破坏一些东西。<br>我们也可以将多个值放入到普通写法的 background- 属性中，比如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: url(<span class="string">image.png</span>), url(<span class="string">background-tile.png</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat, repeat;</span><br></pre></td></tr></table></figure>
<h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><p>正如我们之前提到的，有一个可用的属性——background-size ——它允许你动态地改变背景图像的大小，使它更适合你的设计。这在很多方面都很有用，例如自动纠正没有正确上传的图标的大小。请记住，这并不支持Internet Explorer低于9的版本，所以如果您需要支持旧的浏览器，那么您就不能依赖它。对于每个背景图像，您需要包含两个背景大小值，一个用于水平维度，另一个用于垂直方向：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">image</span>: url(myimage.png);</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>: <span class="number">16</span>px <span class="number">16</span>px;</span><br></pre></td></tr></table></figure>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>元素有一个边界，它位于元素的内边距(padding)和外边距(margin)之间。默认情况下，边界的大小为0，使其不可见，但可以设置边界的粗细、样式和颜色以使其显示出来。</p>
<h3 id="边界回顾"><a href="#边界回顾" class="headerlink" title="边界回顾"></a>边界回顾</h3><p>border简写属性允许一次将所有的这些都设置在四个边，例如：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">padding: 10px;</span><br><span class="line"><span class="built_in">background</span>: yellow;</span><br><span class="line"><span class="built_in">border</span>: 2px solid red;</span><br><span class="line">&#125; <span class="built_in">border</span>可以分解成许多不同的属性，以获得更具体的样式需求：</span><br><span class="line"></span><br><span class="line"><span class="built_in">border</span>-top, <span class="built_in">border</span>-right, <span class="built_in">border</span>-bottom, <span class="built_in">border</span>-left: 设置边界一侧的宽度，样式和颜色。</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">width</span>, <span class="built_in">border</span>-<span class="built_in">style</span>, <span class="built_in">border</span>-<span class="built_in">color</span>: 设置边界宽度、样式或颜色，但是会设置边界的四个边。</span><br><span class="line">还可以单独三个属性中的一个并且设置其中一侧边界生效。</span><br><span class="line"><span class="built_in">border</span>-top-<span class="built_in">width</span>, <span class="built_in">border</span>-top-<span class="built_in">style</span>, <span class="built_in">border</span>-top-<span class="built_in">color</span>等。</span><br></pre></td></tr></table></figure>
<h3 id="边界半径"><a href="#边界半径" class="headerlink" title="边界半径"></a>边界半径</h3><p>盒子上的圆角是网站上另一个非常受欢迎的功能——如此流行以至于浏览器实现了专门用于实现圆角的属性 :<code>border-radius</code>。<br><code>border-radius</code> 只支持Internet Explorer 9以上。但是缺少圆角不能阻止用户阅读你的内容，所以老浏览器的用户可以不用它们。<br>在不同的角落放置不同大小的边界半径, 您可以指定两个，三个或四个值, 如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">border-radius: <span class="number">20</span>px <span class="number">10</span>px;</span><br><span class="line"><span class="comment">// 1st value is top left corner, 2nd value is top right</span></span><br><span class="line"><span class="keyword">and</span> bottom left, <span class="number">3</span>rd value <span class="keyword">is</span> bottom right <span class="comment">//</span></span><br><span class="line">border-radius: <span class="number">20</span>px <span class="number">10</span>px <span class="number">50</span>px;</span><br><span class="line"><span class="comment">// top left, top right, bottom right, bottom left //</span></span><br><span class="line">border-radius: <span class="number">20</span>px <span class="number">10</span>px <span class="number">50</span>px <span class="number">0</span>;</span><br><span class="line">还可以创建椭圆形角（x半径与y半径不同）。两个不同的半径用正斜杠（/）分隔，您可以将其与值的任意组合组合。例如:</span><br><span class="line">border-radius: <span class="number">10</span>px / <span class="number">20</span>px;</span><br><span class="line">border-radius: <span class="number">10</span>px <span class="number">30</span>px / <span class="number">20</span>px <span class="number">40</span>px;</span><br></pre></td></tr></table></figure>
<h3 id="边界图像"><a href="#边界图像" class="headerlink" title="边界图像"></a>边界图像</h3><p>CSS中最新的(和复杂的)操作，用于操作边界—— <code>border-image</code>。这里的想法是，有时创建复杂的用户界面特性需要一个复杂的界面设计，而不仅仅是一个纯色。这可能是通过在另一个较大的元素的顶部覆盖一个元素，然后将背景图像应用到底部元素，伪造一个复杂的边界来创建的。或者在极端情况下，甚至可能需要创建一个包含9个元素的3 x 3网格，其中的中心元素作为您的内容，以及周围的8个元素，将边界元素应用于它们。</p>
<p>border-image图像使实现复杂的图形边界变得容易得多，即使必须在现代浏览器中才能实现(Internet Explorer 11+支持它，以及其他现代浏览器)。</p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>两个不常用的边界图像属性如下：</p>
<p><code>border-image-width</code>：只调整边界图像，而不是边界——如果这个设置小于border-width，它会贴着边界外侧，而不是填满边界。如果是它更大，那么它就会越过边界内侧，并开始重叠在内边距/内容上。<br><code>border-image-outset</code>：定义边界内部和内边距之间的额外空间的大小——有点像“边界填充”。如果需要的话，这是一种简单的方法，可以将边界图像移出一点。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>给<code>table-layout</code>属性设置一个为fixed的值通常是一个好主意，因为它使表的行为在默认情况下更可预测。通常情况下，表列的尺寸会根据所包含的内容大小而变化，这会产生一些奇怪的结果。通过 table-layout: fixed，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。这就是为什么我们使用了thead th:nth-child(n) 选择了四个不同的标题(:nth-child)选择器（“选择第n个子元素，它是一个顺序排列的&lt; th&gt;元素，且其父元素是&lt; thead&gt;元素”）并给定了它们的百分比宽度。整个列宽度与列标题的宽度是一样的，这是一种很好的设定表列尺寸的方式。</p>
<p>使您的表格标记尽可能简单，并且保持灵活性，例如使用百分比，这样设计就更有响应性。<br>使用 table-layout: fixed 创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。<br>使用 border-collapse: collapse 使表元素边框合并，生成一个更整洁、更易于控制的外观。<br>使用&lt; thead&gt;, &lt; tbody&gt;和&lt; tfoot&gt; 将表格分割成逻辑块，并提供额外的应用CSS的地方，因此如果需要的话，可以更容易地将样式层叠在一起。<br>使用斑马线来让其他行更容易阅读。<br>使用 text-align直线对齐您的&lt; th&gt;和&lt; td&gt;文本，使内容更整洁、更易于跟随。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>若干个默认的样式预设值：</p>
<p>&lt; ul&gt; 和元素设置margin的顶部和底部: 16px(1em) 0;和 padding-left: 40px(2.5em); （在这里注意的是浏览器默认字体大小为16px）。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt; li&gt; 默认是没有设置间距的。</span><br><span class="line">&lt; dl&gt; 元素设置 margin的顶部和底部: <span class="number">16</span>px(<span class="number">1</span>em) ，无内边距设定。</span><br><span class="line">&lt; dd&gt; 元素设置为： margin-left <span class="number">40</span>px (<span class="number">2.5</span>em)。</span><br></pre></td></tr></table></figure>
<p>在参考中提到的 &lt; p&gt; 元素设置 margin的顶部和底部: 16px(1em)，和其他的列表类型相同。<br>处理列表间距<br>创建样式列表时，您需要调整样式，使其保持与周围元素相同的垂直间距（例如段落和图片，有时称为垂直节奏））和相互间的水平间距。</p>
<h3 id="列表特定样式"><a href="#列表特定样式" class="headerlink" title="列表特定样式"></a>列表特定样式</h3><p><code>list-style-type</code> ：<br>设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-style-position</span> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</span><br><span class="line"><span class="built_in">list-style-image</span> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。</span><br></pre></td></tr></table></figure>
<h3 id="管理列表计数"><a href="#管理列表计数" class="headerlink" title="管理列表计数"></a>管理列表计数</h3><p>有时，我们可能想在有序列表上进行不同的计数方式。例如： 从1以外的数字开始，或向后倒数，或者按步或多于1计数。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">start 属性允许从1 以外的数字开始计数，例如：<span class="tag">&lt; <span class="attr">ol</span> <span class="attr">start</span>=<span class="string">”4”</span>&gt;</span></span><br><span class="line">reversed 属性将启动列表倒计数，例如：<span class="tag">&lt; <span class="attr">ol</span> <span class="attr">start</span>=<span class="string">”4”</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">value 属性允许设置列表项指定数值， 例如： <span class="tag">&lt; <span class="attr">li</span> <span class="attr">value</span>=<span class="string">”2”</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>背景+边框+列表+表格</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端03--盒模型</title>
    <url>/2019/02/25/%E5%B7%A9%E5%9B%BA3/</url>
    <content><![CDATA[<h2 id="CSS样式巩固"><a href="#CSS样式巩固" class="headerlink" title="CSS样式巩固"></a>CSS样式巩固</h2><p>今天又重新接触到了CSS，在第三天的课程里面也学到了，所以不仅重温了CSS理论知识，也让我更系统性的记住了这些样式属性的使用方法。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>CSS盒模型是网络布局的基础——每个元素表示为一个矩形盒子，矩形盒子的<code>content、padding、border 和 margin</code>像是洋葱一样嵌套。当浏览器渲染一个页面的时候，它会分析哪些样式渲染到每个盒子的内容 (content) 当中，盒子周围的 “洋葱层” （padding、border、margin）有多大，以及盒子间的位置关系。在学习如何使用CSS布局之前，你需要理解盒子模型。</p>
<a id="more"></a>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="1、类选择器"><a href="#1、类选择器" class="headerlink" title="1、类选择器"></a>1、类选择器</h3><p>类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">HTML代码：</span><br><span class="line">&lt; ul&gt;</span><br><span class="line">&lt; li <span class="keyword">class</span>=”<span class="symbol">first</span> <span class="symbol">done</span>”&gt;<span class="symbol">Create</span> <span class="symbol">an</span> <span class="symbol">HTML</span> <span class="symbol">document</span>&lt;/ <span class="symbol">li</span>&gt;</span><br><span class="line">&lt; /<span class="symbol">ul</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="symbol">CSS</span>代码：</span><br><span class="line"><span class="symbol">first</span> &#123;</span><br><span class="line">font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.done &#123;</span><br><span class="line">text-decoration: line-through;</span><br><span class="line">&#125; 即一个类选择了两个属性。</span><br></pre></td></tr></table></figure>
<h3 id="2、ID-选择器"><a href="#2、ID-选择器" class="headerlink" title="2、ID 选择器"></a>2、ID 选择器</h3><p>ID选择器是由一个哈希/磅符号 (#)，后面跟着给定元素的ID名称组成的。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己决定选择一个ID名称是什么。 这是选择单个元素的最有效的方式。<br>注意：一个ID名称必须在文档中是唯一的。关于重复ID的行为是不可预测的，比如一些浏览器只是计入第一个实例，其余的将被忽略。<br>例如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">HTML代码：</span><br><span class="line">&lt; <span class="selector-tag">p</span> id=”polite”&gt; — “Good morning.”&lt; /p&gt;</span><br><span class="line">&lt; <span class="selector-tag">p</span> id=”rude”&gt; — “Go away!”&lt; /p&gt;</span><br><span class="line"></span><br><span class="line">CSS代码：</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#polite</span> &#123;</span><br><span class="line"><span class="attribute">font-family</span>: cursive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#rude</span> &#123;</span><br><span class="line"><span class="attribute">font-family</span>: monospace;</span><br><span class="line"><span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、组合选择器"><a href="#3、组合选择器" class="headerlink" title="3、组合选择器"></a>3、组合选择器</h3><p>选择器组 A,B 匹配满足A（和/或）B的任意元素（参见下方 同一规则集上的多个选择器）.<br>后代选择器 A B 匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）<br>子选择器 A &gt; B 匹配B元素，满足条件：B是A的直接子节点<br>相邻兄弟选择器 A + B 匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）<br>通用兄弟选择器 A ~ B 匹配B元素，满足条件：B是A之后的任意一个兄弟节点（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</p>
<h2 id="CSS字体样式"><a href="#CSS字体样式" class="headerlink" title="CSS字体样式"></a>CSS字体样式</h2><p>字体包括：颜色、大小、种类、装饰、样式、粗细、转换和阴影。它们各自的标签属性为：color：颜色值、font-size：xxpx、font-family：Arial（默认）、<br>text-decoration：none（默认）、font-style：normal（默认）、font-weight：normal（默认）、text-transform：none（默认）、text-shadow：none（默认）。其中font-size的单位可以试px、em、rem三种，font-family一般在网页中加入网页安全字体（指的是在任何浏览器都能显示出来的字体），当然我们也可以加入一个字体栈，这样浏览器就可以有多种选择了，text-decoration的属性值有none、underline（下划线）、overline（上划线）、line-through（文本中划线），text-decoration可以接收多个属性值，比如同时加入上划线和下划线，text-decoration：overline underline；同时注意 text-decoration 是一个缩写形式，它由 text-decoration-line, text-decoration-style 和 text-decoration-color 构成；font-style的属性值有normal、italic、oblique三种，font-weight的属性值有normal、bold、lighter三种，text-transform的属性值有none（无）、uppercase（转换为大写）、lowercase（转换为小写）、capitalize（首字母大写）、full-width（规定字符长度宽度相等）四种属性；可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">text-shadow: <span class="number">-1</span>px <span class="number">-1</span>px <span class="number">1</span>px #aaa,</span><br><span class="line"><span class="number">0</span>px <span class="number">4</span>px <span class="number">1</span>px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>),</span><br><span class="line"><span class="number">4</span>px <span class="number">4</span>px <span class="number">5</span>px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.7</span>),</span><br><span class="line"><span class="number">0</span>px <span class="number">0</span>px <span class="number">7</span>px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="CSS布局风格"><a href="#CSS布局风格" class="headerlink" title="CSS布局风格"></a>CSS布局风格</h2><h3 id="1、文本对齐"><a href="#1、文本对齐" class="headerlink" title="1、文本对齐"></a>1、文本对齐</h3><p><code>text-align</code> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">left:</span> 左对齐文本。</span><br><span class="line"><span class="symbol">right:</span> 右对齐文本。</span><br><span class="line"><span class="symbol">center:</span> 居中文字</span><br><span class="line"><span class="symbol">justify:</span> 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 hyphens，打破一些更长的词语。</span><br></pre></td></tr></table></figure>
<h3 id="2、行高"><a href="#2、行高" class="headerlink" title="2、行高"></a>2、行高</h3><p><code>line-height</code> 属性设置文本每行之间的高，可以接受大多数单位 length and size units，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 font-size 来获得 line-height。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的1.5倍，你可以使用这个:<br>line-height: 1.5;</p>
<h3 id="3、字母和单词间距"><a href="#3、字母和单词间距" class="headerlink" title="3、字母和单词间距"></a>3、字母和单词间距</h3><p><code>letter-spacing</code> 和<code>word-spacing</code> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 length and size units.</p>
<p>其他一些值得看一下的属性</p>
<h2 id="Font-样式"><a href="#Font-样式" class="headerlink" title="Font 样式:"></a>Font 样式:</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">font</span>-<span class="attribute">variant</span>: 在小型大写字母和普通文本选项之间切换。</span><br><span class="line"><span class="built_in">font</span>-<span class="attribute">kerning</span>: 开启或关闭字体间距选项。</span><br><span class="line"><span class="built_in">font</span>-feature-<span class="attribute">settings</span>: 开启或关闭不同的 OpenType 字体特性。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-<span class="attribute">alternates</span>: 控制给定的自定义字体的替代字形的使用。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-<span class="attribute">caps</span>: 控制大写字母替代字形的使用。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-east-<span class="attribute">asian</span>: 控制东亚文字替代字形的使用, 像日语和汉语。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-<span class="attribute">ligatures</span>: 控制文本中使用的连写和上下文形式。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-<span class="attribute">numeric</span>: 控制数字，分式和序标的替代字形的使用。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>-<span class="attribute">position</span>: 控制位于上标或下标处，字号更小的替代字形的使用。</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">size</span>-<span class="attribute">adjust</span>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</span><br><span class="line"><span class="built_in">font</span>-<span class="attribute">stretch</span>: 在给定字体的可选拉伸版本中切换。</span><br><span class="line">text-underline-<span class="attribute">position</span>: 指定下划线的排版位置，通过使用 text-decoration-line 属性的underline 值。</span><br><span class="line">text-<span class="attribute">rendering</span>: 尝试执行一些文本渲染优化。</span><br></pre></td></tr></table></figure>
<h2 id="文本布局样式："><a href="#文本布局样式：" class="headerlink" title="文本布局样式："></a>文本布局样式：</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">text-<span class="string">indent:</span> 指定文本内容的第一行前面应该留出多少的水平空间。</span><br><span class="line">text-<span class="string">overflow:</span> 定义如何向用户表示存在被隐藏的溢出内容。</span><br><span class="line">white-<span class="string">space:</span> 定义如何处理元素内部的空白和换行。</span><br><span class="line">word-<span class="string">break:</span> 指定是否能在单词内部换行。</span><br><span class="line"><span class="string">direction:</span> 定义文本的方向 (这取决于语言，并且通常最好让HTML来处理这部分，因为它是和文本内容相关联的。)</span><br><span class="line"><span class="string">hyphens:</span> 为支持的语言开启或关闭连字符。</span><br><span class="line">line-<span class="string">break:</span> 对东亚语言采用更强或更弱的换行规则。</span><br><span class="line">text-align-<span class="string">last:</span> 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</span><br><span class="line">text-<span class="string">orientation:</span> 定义行内文本的方向。</span><br><span class="line">word-<span class="string">wrap:</span> 指定浏览器是否可以在单词内换行以避免超出范围。</span><br><span class="line">writing-<span class="string">mode:</span> 定义文本行布局为水平还是垂直，以及后继文本流的方向。</span><br></pre></td></tr></table></figure>
<h2 id="Font-简写"><a href="#Font-简写" class="headerlink" title="Font 简写"></a>Font 简写</h2><p>许多字体的属性也可以通过 font 的简写方式来设置 . 这些是按照以下顺序来写的： <code>font-style, font-variant, font-weight, font-stretch, font-size, line-height, and font-family.</code>，在所有这些属性中，只有 <code>font-size</code>和<code>font-family</code>是一定要指定的。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端02--问题集锦</title>
    <url>/2019/02/23/%E5%B7%A9%E5%9B%BA2/</url>
    <content><![CDATA[<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>1、HTML是什么，HTML5是什么</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HTML</span> 指的是超文本标记语言 (Hyper <span class="built_in">Text</span> Markup Language)。</span><br><span class="line">HTML5是最新的HTML标准，拥有更丰富的语义、图形以及多媒体元素等内容。</span><br></pre></td></tr></table></figure>
<p>2、HTML元素标签、属性都是什么概念？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML不是编程语言，是标记语言，所以要使用标记标签来描述网页。</span><br><span class="line">属性是用来提供HTML标签更多的信息。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3、文档类型是什么概念，起什么作用？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在互联网上有许多不同的文档，只有了解文档的类型，浏览器才能正确的显示文档。提前声明文档类型可以帮助浏览器正确的显示网页。</span><br></pre></td></tr></table></figure>
<p>4、meta标签都用来做什么的？</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">通常所说的<span class="keyword">META</span>标签，是在HTML网页源代码中一个重要的html标签。<span class="keyword">META</span>标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。位于HTML代码前面</span><br></pre></td></tr></table></figure>
<p>5、Web语义化是什么，是为了解决什么问题？</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">HTML的每个标签都有其特定含义<span class="comment">(语义)</span>,Web语义化是指使用语义恰当的标签,使页面有良好的结构,页面元素有含义,能够让人和搜索引擎都容易理解。</span><br></pre></td></tr></table></figure>
<p>6、链接是什么概念，对应什么标签？</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">HTML &lt; <span class="keyword">a</span>&gt; 元素 (或锚元素) 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他<span class="built_in">URL</span>的超链接。</span><br></pre></td></tr></table></figure>
<p>7、常用标签都有哪些，都适合用在什么场景</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">body:在网页上要展示出来的页面内容一定要放在body标签中</span><br><span class="line"><span class="keyword">p</span>:如果想在网页上显示文章，这时就需要<span class="keyword">p</span>标签了，把文章的段落放到<span class="keyword">p</span>标签中。标签的默认样式，段前段后都会有空白，如果不喜欢这个空白，可以用css样式来删除或改变它。</span><br><span class="line">span:标签是没有语义的，它的作用就是为了设置单独的样式用的。</span><br><span class="line"><span class="keyword">br</span>:在需要加回车换行的地方加入<span class="keyword">br</span>，<span class="keyword">br</span>标签作用相当于word文档中的回车。在 html 代码中输入回车、空格都是没有作用的。在html文本中想输入回车换行，就必须输入<span class="keyword">br</span>。没有HTML内容的标签就是空标签，空标签只需要写一个开始标签，这样的标签有<span class="keyword">br</span>、hr和img。</span><br><span class="line"><span class="keyword">di</span><span class="variable">v:</span>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个div标签中，这个div标签的作用就相当于一个容器。什么是逻辑部分？它是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。用id属性来为div提供唯一的名称，必须唯一。</span><br><span class="line"><span class="keyword">im</span><span class="variable">g:</span>插入图片,img src=”图片地址” alt=”下载失败时的替换文本” title = “提示文本” src：标识图像的位置；alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本；title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)；图像可以是GIF，PNG，JPEG格式的图像文件。</span><br></pre></td></tr></table></figure>
<p>8、表单标签都有哪些，对应着什么功能，都有哪些属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">form:可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。form <span class="attribute">method</span>=”传送方式” <span class="attribute">action</span>=”服务器文件” . form标签是成对出现的，以form开始，以/form结束。</span><br><span class="line">action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</span><br><span class="line">method ： 数据传送的方式（get/post）。所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在标签之间</span><br><span class="line">input:当用户要在表单中键入字母、数字等内容时，就会用到文本输入框。文本框也可以转化为密码输入框。input <span class="attribute">type</span>=”text/password” <span class="attribute">name</span>=”名称” <span class="attribute">value</span>=”文本” / 当<span class="attribute">type</span>=”text”时，输入框为文本输入框;当type=”password”时, 输入框为密码输入框。</span><br><span class="line">name：为文本框命名，以备后台程序ASP 、PHP使用。value：为文本输入框设置默认值。(一般起到提示作用)</span><br><span class="line">textarea:当用户需要在表单中输入大段文字时，需要用到文本输入域。textarea <span class="attribute">rows</span>=”行数” <span class="attribute">cols</span>=”列数” 文本 /textarea rows ：多行输入域的行数。cols ：多行输入域的列数。在textarea /textarea 标签之间可以输入默认值。</span><br><span class="line">radio/checkbox:使用单选框、复选框，让用户选择,input <span class="attribute">type</span>=”radio/checkbox” <span class="attribute">value</span>=”值” <span class="attribute">name</span>=”名称” <span class="attribute">checked</span>=”checked”/&gt; 当 <span class="attribute">type</span>=”radio” 时，控件为单选框,当 <span class="attribute">type</span>=”checkbox” 时，控件为复选框,value：提交数据到服务器的值（后台程序PHP使用）,name：为控件命名，以备后台程序 ASP、PHP 使用,checked：当设置 <span class="attribute">checked</span>=”checked” 时，该选项被默认选中,同一组的单选按钮，name 取值一定要一致，这样同一组的单选按钮才可以起到单选的作用。</span><br><span class="line">submit:使用提交按钮，提交数据,input <span class="attribute">type</span>=”submit” <span class="attribute">value</span>=”提交”&gt; type：只有当type值设置为submit时，按钮才有提交作用,value：按钮上显示的文字</span><br></pre></td></tr></table></figure>
<p>9、ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">ol、ul、li适用无描述的列表。例如：新闻展示页面，一共N条新闻，点进去可浏览详情。</span><br><span class="line"><span class="built_in">dl</span>、<span class="built_in">dd</span>、<span class="built_in">dt</span>适用有描述的列表 例如：简历页面，介绍自己的信息、年龄、住址等。</span><br></pre></td></tr></table></figure>
<p>10、DOCTYPE的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位于文档的最前面，处于标签之前，主要作用是告诉浏览器该用什么文档类型来解析该文档如果不用DOCTYPE或格式不正确会以混杂模式呈现。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>问题集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>巩固前端01--问题集锦</title>
    <url>/2019/02/22/%E5%B7%A9%E5%9B%BA1/</url>
    <content><![CDATA[<h2 id="HTML-Css阶段一"><a href="#HTML-Css阶段一" class="headerlink" title="HTML+Css阶段一"></a>HTML+Css阶段一</h2><p>今天巩固了前端，重新把那些知识点都看了一遍，发现自己差的还很远，基础知识也很不牢靠，特别是JS，好在我这几天买了一本红宝书，专门来学习JS框架。<br>由于我现在在跟着百度前端技术学院重新学习前端的相关知识，并且它也将课程按照天数来分，所以，我也将在接下来的日子里，按照天数，记录我每一天的学习情况和学习笔记，还有一些我自己的心得体会，当然我也会跟着它的指示做一些小实验和小项目，动手的部分就不用写的太详细，但是在我的博客里面记录的这些笔记可能是很零散的，也可能会有一些重复，因为我是把我自己容易搞混的点和我自己觉得很重要的知识点记了下来。</p>
<a id="more"></a>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><h3 id="三层结构"><a href="#三层结构" class="headerlink" title="三层结构"></a>三层结构</h3><p>今天收获到的都是一些零零散散的知识点，比如网页分为三个结构：<code>结构层、表示层、行为层</code>；三层分别对应的技术是：<code>HTML、CSS、JavaScript</code>。HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</p>
<h3 id="link和-import"><a href="#link和-import" class="headerlink" title="link和@import"></a>link和@import</h3><p>首先它们两个的语法结构不同，<code>&lt;link&gt;</code>是属于HTML标签，只能放入HTML源代码中使用，它是链接文件，没有兼容性问题，当页面加载时link文件同时执行；<br><code>@import</code>是CSS样式，作用是引入CSS样式功能，是导入文件，需要页面完全加载以后才能加载。</p>
<h3 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h3><p>浏览器分为客户端和服务端，客户端就是用户直接体验的这一端，包括页面的展示，用户的点击和浏览操作；服务器就是属于后端，需要操作数据，用户在前端操作留下的数据需要通过接口来传送到服务器端储存起来，就好比我们从家里面出发到目的地，家就类似于我们的客户端，目的地就是我们的服务器端。除了服务器端和用户端，我们还应该了解网络连接、TCP/IP（控制数据如何传输的协议）、DNS（域名服务器，能通过域名找到相应的网址）、HTTP（客户端和服务器端交流的语言的协议）、组成文件（代码（HTML、CSS、JavaScript）、资源（图片、音频、视频））。当我们请求上网时，首先是输入网址，然后请求服务端，服务端再请求数据端，数据端允许服务器做相关操作，服务器允许我们用户做相关操作以后，我们才能下载相应文件。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>在今天之前是断断续续看过几本书，浏览过几个网站，学了一些关于前端的基本知识，但是由于要上课的原因，所以基本上也是断断续续的，自己对其中的一些知识点也是零散记忆不起来，前面刚放暑假，我就在准备好好学习前端，可是没有一个系统的框架，觉得自己学起来也是零零散散的，所以在知乎上面去搜寻了一下，找到了百度前端技术学院这个网站，我准备跟着这个网站的进度一步一步的再来巩固和系统的学习前端，看<br>了上面的别人做的很酷炫的网页，突然就觉得很心动也更加确定了我要走前端这条道路的决心，然后再去看了一下学习前端的一些非常基础的知识，感觉它们的概念很容易理解，但是运用可能会有点困难，所以在后期，我会一边学习理论知识，一边动手做一些自己的小实验和小项目。今天体会最深的就是我缺乏系统性的基础知识功底，并且我的JavaScript知识能力还很欠缺，动手能力也有待提高，所以自己要赶快在接下来的时间里好好学习前端相关的基础知识和应用知识。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>巩固前端系列笔记</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>巩固前端系列</tag>
        <tag>问题集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>css3笔记01</title>
    <url>/2019/02/19/css3%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3c网站参考连接</a></p>
<h2 id="CSS3笔记"><a href="#CSS3笔记" class="headerlink" title="CSS3笔记"></a>CSS3笔记</h2><h2 id="CSS3边框"><a href="#CSS3边框" class="headerlink" title="CSS3边框"></a>CSS3边框</h2><p><b>圆角边框</b>：<code>border-radius：Xpx</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">border</span>:<span class="number">2px</span> solid;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">25px</span>;</span><br><span class="line"><span class="attribute">-moz-border-radius</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像素值定义的是圆角的半径，像素值越大，圆角越明显。百分比也可以定义圆角的半径</p>
<a id="more"></a>
<p>如果只要其中一边的圆角则：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">border-<span class="built_in">top</span>-<span class="built_in">left</span>-radius:<span class="number">2</span>em;</span><br><span class="line">border-<span class="built_in">top</span>-<span class="built_in">right</span>-radius:<span class="number">2</span>em;</span><br><span class="line">border-<span class="built_in">bottom</span>-<span class="built_in">right</span>-radius:<span class="number">2</span>em;</span><br><span class="line">border-<span class="built_in">bottom</span>-<span class="built_in">left</span>-radius:<span class="number">2</span>em;</span><br></pre></td></tr></table></figure>

<p><b>边框阴影</b>：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">box-shadow：Xpx（距离垂直边框的宽度） </span>Ypx（距离上边框的宽度）Zpx（阴影的强重程度，如果越小，阴影越重，越大，阴影越小，越透明越模糊） <span class="comment">#XXXXXX（阴影的颜色）</span></span><br><span class="line"><span class="keyword">div</span></span><br><span class="line"><span class="keyword">&#123; </span><span class="keyword">box-shadow: </span><span class="number">10</span>px <span class="number">10</span>px <span class="number">5</span>px <span class="comment">#888888;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h-<span class="keyword">shadow </span>必需。水平阴影的位置。允许负值。</span><br><span class="line">v-<span class="keyword">shadow </span>必需。垂直阴影的位置。允许负值。</span><br><span class="line"><span class="keyword">blur </span>可选。模糊距离。 测试</span><br><span class="line">spread 可选。阴影的尺寸。 测试</span><br><span class="line">color 可选。阴影的颜色。请参阅 CSS 颜色值。</span><br><span class="line"><span class="keyword">inset </span>可选。将外部阴影 (outset) 改为内部阴影。</span><br></pre></td></tr></table></figure>
<p><b>边框图片</b></p>
<figure class="highlight plain"><figcaption><span>属性允许您规定用于边框的图片！</span></figcaption><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">~~~</span><br><span class="line">border-image:url(border.png) 30 30 round; 为round的时候，说明图片铺满整个文本</span><br><span class="line">border-image:url(&#x2F;i&#x2F;border.png) 40 23 stretch; 为stretch的时候，是把图片拉伸开来</span><br><span class="line">border-image-source 用在边框的图片的路径。</span><br><span class="line">border-image-slice 图片边框向内偏移。</span><br><span class="line">border-image-width 图片边框的宽度。</span><br><span class="line">border-image-outset 边框图像区域超出边框的量。</span><br><span class="line">border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</span><br><span class="line">~~~</span><br><span class="line">## CSS3背景</span><br><span class="line">背景图像设置尺寸：&#96;&#96;&#96;background-size:</span><br></pre></td></tr></table></figure>
<p>后面可以加的值为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ength</span> <span class="string">设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</span></span><br><span class="line"><span class="attr">percentage</span> <span class="string">以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</span></span><br><span class="line"><span class="attr">cover</span> <span class="string">把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</span></span><br><span class="line"><span class="attr">contain</span> <span class="string">把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域（即文本区域）</span></span><br></pre></td></tr></table></figure>
<p>多重背景图片：<code>background-image:url(bg_flower.gif),url(bg_flower_2.gif);</code>直接添加要设置的背景图片</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span> 属性：</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">origin</span> 属性规定 <span class="built_in">background</span>-<span class="built_in">position</span> 属性相对于什么位置来定位。注释：如果背景图像的 <span class="built_in">background</span>-attachment 属性为 “fixed”，则该属性没有效果。</span><br><span class="line">padding-<span class="built_in">box</span> 背景图像相对于内边距框来定位。</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">box</span> 背景图像相对于边框盒来定位。即边框（<span class="built_in">border</span>）</span><br><span class="line"><span class="built_in">content</span>-<span class="built_in">box</span> 背景图像相对于内容框来定位。如文本</span><br><span class="line"><span class="built_in">background</span>-clip 属性</span><br><span class="line"><span class="built_in">background</span>-clip 属性规定背景的绘制区域，即在规定的区域设置背景</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">box</span> 背景被裁剪到边框盒。即<span class="built_in">border</span>定义的最外边框</span><br><span class="line">padding-<span class="built_in">box</span> 背景被裁剪到内边距框，div定义的略小于<span class="built_in">border</span>的边框</span><br><span class="line"><span class="built_in">content</span>-<span class="built_in">box</span> 背景被裁剪到内容框。填写内容的边框</span><br></pre></td></tr></table></figure>
<p><b>总结：</b></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-clip 规定背景的绘制区域。</span><br><span class="line"><span class="built_in">background</span>-origin 规定背景图片的定位区域。</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span> 规定背景图片的尺寸。</span><br></pre></td></tr></table></figure>
<h2 id="CSS3文本效果"><a href="#CSS3文本效果" class="headerlink" title="CSS3文本效果"></a>CSS3文本效果</h2><h3 id="文本阴影："><a href="#文本阴影：" class="headerlink" title="文本阴影："></a>文本阴影：</h3><p>能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色：<br>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span></span><br><span class="line">&#123; <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</span><br><span class="line">&#125; 属性值分别表示：<span class="selector-tag">x</span>的距离、<span class="selector-tag">y</span>的距离、阴影的程度（像素值越大越浅显）、颜色</span><br></pre></td></tr></table></figure>
<p>自动换行word-wrap属性<br>在 CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分。</p>
<p>新的文本属性：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">hanging-punctuation 规定标点字符是否位于线框之外。</span><br><span class="line">punctuation-trim 规定是否对标点字符进行修剪。</span><br><span class="line"><span class="attribute">text-align-last</span> 设置如何对齐最后一行或紧挨着强制换行符之前的行。</span><br><span class="line">text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。</span><br><span class="line">text-justify 规定当 <span class="attribute">text-align</span> 设置为 “justify” 时所使用的对齐方法。</span><br><span class="line">text-<span class="attribute">outline</span> 规定文本的轮廓。</span><br><span class="line"><span class="attribute">text-overflow</span> 规定当文本溢出包含元素时发生的事情。两个属性值：hidden（不显示超出部分）、<span class="attribute">inherit</span>（显示超出部分）</span><br><span class="line"><span class="attribute">text-shadow</span> 向文本添加阴影。</span><br><span class="line">text-wrap 规定文本的换行规则。</span><br><span class="line"><span class="attribute">word-break</span> 规定非中日韩文本的换行规则。</span><br><span class="line"><span class="attribute">word-wrap</span> 允许对长的不可分割的单词进行分割并换行到下一行。</span><br></pre></td></tr></table></figure>
<h2 id="CSS3字体"><a href="#CSS3字体" class="headerlink" title="CSS3字体"></a>CSS3字体</h2><h3 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h3><p>在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。<br>我们“自己的”的字体是在 <code>CSS3 @font-face</code> 规则中定义的。<br>在新的<code>@font-face</code> 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&lt; style&gt;</span><br><span class="line"><span class="meta">@font</span>-face</span><br><span class="line">&#123; font-<span class="string">family:</span> myFirstFont;</span><br><span class="line"><span class="string">src:</span> url(‘Sansation_Light.ttf’),</span><br><span class="line">url(‘Sansation_Light.eot’);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123; font-<span class="string">family:</span>myFirstFont;</span><br><span class="line">&#125; &lt; /style&gt;</span><br><span class="line"></span><br><span class="line">使用粗体字体</span><br><span class="line">必须为粗体文本添加另一个包含描述符的 <span class="meta">@font</span>-face：</span><br><span class="line"><span class="meta">@font</span>-face</span><br><span class="line">&#123; font-<span class="string">family:</span> myFirstFont;</span><br><span class="line"><span class="string">src:</span> url(‘Sansation_Bold.ttf’),</span><br><span class="line">url(‘Sansation_Bold.eot’);</span><br><span class="line">font-<span class="string">weight:</span>bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这是在定义完了以后添加的另一个<code>@font-face</code>，但是定义和加粗必须是两个独立的定义，不能合并和省略。<br>使用两个独立的都要单独定义的方法还可以定义许多其他的文本格式，最重要的都是要独立定义，且是在使用该字体的时候，如果我们要进行文本的加粗或者强调，就直接调用就好了。<br>列出了能够在 <code>@font-face</code> 规则中定义的所有字体描述符：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span> name 必需。规定字体的名称。</span><br><span class="line"><span class="attribute">src</span> URL 必需。定义字体文件的 URL。</span><br><span class="line"><span class="attribute">font-stretch</span> <span class="attribute">normal</span> 可选。定义如何拉伸字体。默认是 “<span class="attribute">normal</span>”。</span><br><span class="line">condensed</span><br><span class="line">ultra-condensed</span><br><span class="line">extra-condensed</span><br><span class="line">semi-condensed</span><br><span class="line">expanded</span><br><span class="line">semi-expanded</span><br><span class="line">extra-expanded</span><br><span class="line">ultra-expanded</span><br><span class="line"><span class="attribute">font-style</span> ormal 可选。定义字体的样式。默认是 “<span class="attribute">normal</span>”。</span><br><span class="line">italic</span><br><span class="line">oblique</span><br><span class="line"><span class="attribute">font-weight</span> <span class="attribute">normal</span></span><br><span class="line">bold</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">300</span><br><span class="line">400</span><br><span class="line">500</span><br><span class="line">600</span><br><span class="line">700</span><br><span class="line">800</span><br><span class="line">900 可选。定义字体的粗细。默认是 “<span class="attribute">normal</span>”。</span><br><span class="line">unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><p>通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。转换是使元素改变形状、尺寸和位置的一种效果。<br>2D转换包括<code>translate()、rotate()、scale()、skew()、matrix()</code>四种<br>调用格式为：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: （选择的属性）（值）;</span><br><span class="line">-ms-<span class="attribute">transform</span>: （选择的属性）（值）;</span><br><span class="line">-webkit-<span class="attribute">transform</span>:（选择的属性）（值）;</span><br><span class="line">-o-<span class="attribute">transform</span>:（选择的属性）（值）;</span><br><span class="line">-moz-<span class="attribute">transform</span>:（选择的属性）（值）;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><p>通过<code>rotate()</code> 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值 rotate(30deg) 把元素顺时针旋转 30 度。</p>
<h3 id="translate转换"><a href="#translate转换" class="headerlink" title="translate转换"></a>translate转换</h3><p>通过<code>translate()</code> 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值<code>translate(50px,100px)</code> 把元素从左侧移动 50 像素，从顶端移动 100 像素</p>
<h3 id="scale转换"><a href="#scale转换" class="headerlink" title="scale转换"></a>scale转换</h3><p>通过<code>scale()</code> 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。按倍数来选择</p>
<h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p>matrix() 方法把所有 2D 转换方法组合在一起。<br>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="attribute">-ms-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="attribute">-o-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的转换属性：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span> 向元素应用 2D 或 3D 转换。</span><br><span class="line"><span class="built_in">transform</span>-<span class="built_in">origin</span> 允许你改变被转换元素的位置。</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h2><p>允许使用 3D 转换来对元素进行格式化。<code>rotateX()</code>、<code>rotateY()</code><br>调用格式为：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: （选择的属性）（值）;</span><br><span class="line">-webkit-<span class="attribute">transform</span>:（选择的属性）（值）;</span><br><span class="line">-moz-<span class="attribute">transform</span>:（选择的属性）（值）;</span><br></pre></td></tr></table></figure>
<h3 id="rotateX-方法"><a href="#rotateX-方法" class="headerlink" title="rotateX()方法"></a>rotateX()方法</h3><p>通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">120deg</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotateX</span>(<span class="number">120deg</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotateX</span>(<span class="number">120deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotateY-旋转"><a href="#rotateY-旋转" class="headerlink" title="rotateY() 旋转"></a>rotateY() 旋转</h3><p>通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);</span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(<span class="number">130deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h2><p>通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p>
<p>要实现这一点，必须规定两项内容：规定把效果添加到哪个 CSS 属性上、规定效果的时长</p>
<p>应用于宽度属性的过渡效果，时长为 2 秒</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-moz-transition</span>: width <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-o-transition</span>: width <span class="number">2s</span>;</span><br><span class="line">&#125; 如果时长未规定，则不会有过渡效果，因为默认值是 0。效果开始于指定的 <span class="selector-tag">CSS</span> 属性改变值时。<span class="selector-tag">CSS</span> 属性改变的典型时间是鼠标指针位于元素上时：</span><br></pre></td></tr></table></figure>
<p>多项改变<br>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">div</span><br><span class="line">&#123; transition: <span class="built_in">width</span> 2s, <span class="built_in">height</span> 2s, <span class="built_in">transform</span> 2s;</span><br><span class="line">-moz-transition: <span class="built_in">width</span> 2s, <span class="built_in">height</span> 2s, -moz-<span class="built_in">transform</span> 2s;</span><br><span class="line">-webkit-transition: <span class="built_in">width</span> 2s, <span class="built_in">height</span> 2s, -webkit-<span class="built_in">transform</span> 2s;</span><br><span class="line">-o-transition: <span class="built_in">width</span> 2s, <span class="built_in">height</span> 2s,-o-<span class="built_in">transform</span> 2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">width</span>+<span class="built_in">height</span>呈现的效果就是类似于旋转然后变成相应的尺寸大小</span><br></pre></td></tr></table></figure>
<p><b>总结：</b><br>列出所有的过度属性；</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span> 简写属性，用于在一个属性中设置四个过渡属性。</span><br><span class="line"><span class="attribute">transition-property</span> 规定应用过渡的 CSS 属性的名称。</span><br><span class="line"><span class="attribute">transition-duration</span> 定义过渡效果花费的时间。默认是 0。</span><br><span class="line"><span class="attribute">transition-timing-function</span> 规定过渡效果的时间曲线。默认是 “ease”。</span><br><span class="line"><span class="attribute">transition-delay</span> 规定过渡效果何时开始。默认是 0。即放鼠标上面以后延迟几秒后才开始有动画</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>规则<br>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。@keyframes 规则用于创建动画。<br>在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：<br>规定动画的名称、规定动画的时长<br>必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0</p>
<h3 id="什么是-CSS3-中的动画？"><a href="#什么是-CSS3-中的动画？" class="headerlink" title="什么是 CSS3 中的动画？"></a>什么是 CSS3 中的动画？</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。我们可以改变任意多的样式任意多的次数。请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，我们应该始终定义 0% 和 100% 选择器。</p>
<p>当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst</span><br><span class="line">&#123; 0% &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">25% &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">50% &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改变背景色和位置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst</span><br><span class="line">&#123; 0% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25% &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">50% &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75% &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>总结：</b></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span></span><br><span class="line">规定动画。如果想要一直有动画，可以在div块里面的animation：Xsinfinite（表示没有限制，如果去除则表示演示一次停止）</span><br><span class="line">animation 所有动画属性的简写属性，除了 animation-play-state 属性。</span><br><span class="line">animation-name 规定 <span class="variable">@keyframes</span> 动画的名称。</span><br><span class="line">animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 <span class="number">0</span>。</span><br><span class="line">animation-timing-function 规定动画的速度曲线。默认是 “ease”。</span><br><span class="line">animation-delay 规定动画何时开始。默认是 <span class="number">0</span>。</span><br><span class="line">animation-iteration-count 规定动画被播放的次数。默认是 <span class="number">1</span>。</span><br><span class="line">animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。</span><br><span class="line">animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。</span><br><span class="line">animation-fill-mode 规定对象动画时间之外的状态。</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h2><p>能够创建多个列来对文本进行布局 - 就像报纸那样！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">column-count</span></span><br><span class="line"><span class="selector-tag">column-gap</span></span><br><span class="line"><span class="selector-tag">column-rule</span></span><br><span class="line"><span class="selector-tag">column-count</span></span><br><span class="line"><span class="selector-tag">column-count</span> 属性规定元素应该被分隔的列数</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123; <span class="attribute">-moz-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">column-gap</span></span><br><span class="line"><span class="selector-tag">column-gap</span> 属性规定列之间的间隔</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123; <span class="attribute">-moz-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">-moz-column-gap</span>:<span class="number">30px</span>;</span><br><span class="line"><span class="attribute">-webkit-column-gap</span>:<span class="number">30px</span>;</span><br><span class="line"><span class="attribute">column-gap</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">column-rule</span></span><br><span class="line"><span class="selector-tag">column-rule</span> 属性设置列之间的宽度、样式和颜色规则。</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123; <span class="attribute">-moz-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">-moz-column-gap</span>:<span class="number">40px</span>;</span><br><span class="line"><span class="attribute">-webkit-column-gap</span>:<span class="number">40px</span>;</span><br><span class="line"><span class="attribute">column-gap</span>:<span class="number">40px</span>;</span><br><span class="line"><span class="attribute">-moz-column-rule</span>:<span class="number">4px</span> outset <span class="number">#ff0000</span>;</span><br><span class="line"><span class="attribute">-webkit-column-rule</span>:<span class="number">4px</span> outset <span class="number">#ff0000</span>;</span><br><span class="line"><span class="attribute">column-rule</span>:<span class="number">4px</span> outset <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性表</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">column-count</span> 规定元素应该被分隔的列数。</span><br><span class="line"><span class="attribute">column-fill</span> 规定如何填充列。</span><br><span class="line"><span class="attribute">column-gap</span> 规定列之间的间隔。</span><br><span class="line"><span class="attribute">column-rule</span> 设置所有 <span class="attribute">column-rule</span>-* 属性的简写属性。</span><br><span class="line"><span class="attribute">column-rule-color</span> 规定列之间规则的颜色。</span><br><span class="line"><span class="attribute">column-rule-style</span> 规定列之间规则的样式。</span><br><span class="line"><span class="attribute">none</span> 定义没有规则。</span><br><span class="line">hidden 定义隐藏规则。</span><br><span class="line">dotted 定义点状规则。</span><br><span class="line">dashed 定义虚线规则。</span><br><span class="line">solid 定义实线规则。</span><br><span class="line">double 定义双线规则。</span><br><span class="line">groove 定义 3D grooved 规则。该效果取决于宽度和颜色值。</span><br><span class="line">ridge 定义 3D ridged 规则。该效果取决于宽度和颜色值。</span><br><span class="line">inset 定义 3D inset 规则。该效果取决于宽度和颜色值。</span><br><span class="line">outset 定义 3D outset 规则。该效果取决于宽度和颜色值。</span><br><span class="line"></span><br><span class="line"><span class="attribute">column-rule-width</span> 规定列之间规则的宽度。</span><br><span class="line">CSS3 Resizing</span><br><span class="line">thin 定义纤细规则。</span><br><span class="line">medium 定义中等规则。</span><br><span class="line">thick 定义宽厚规则。</span><br><span class="line">length 规定规则的宽度。</span><br><span class="line"></span><br><span class="line"><span class="attribute">column-span</span> 规定元素应该横跨的列数。</span><br><span class="line"><span class="attribute">column-width</span> 规定列的宽度。</span><br><span class="line"><span class="attribute">columns</span> 规定设置 <span class="attribute">column-width</span> 和 <span class="attribute">column-count</span> 的简写属性。</span><br></pre></td></tr></table></figure>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>在 CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。</p>
<h3 id="CSS3-Resizing"><a href="#CSS3-Resizing" class="headerlink" title="CSS3 Resizing"></a>CSS3 Resizing</h3><p>在 CSS3，resize 属性规定是否可由用户调整元素尺寸。<br>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">resize</span>:both;</span><br><span class="line"><span class="attribute">overflow</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSS3-Box-Sizing"><a href="#CSS3-Box-Sizing" class="headerlink" title="CSS3 Box Sizing"></a>CSS3 Box Sizing</h3><p>box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。<br>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line"><span class="attribute">-moz-box-sizing</span>:border-box;</span><br><span class="line"><span class="attribute">-webkit-box-sizing</span>:border-box;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSS3-Outline-Offset"><a href="#CSS3-Outline-Offset" class="headerlink" title="CSS3 Outline Offset"></a>CSS3 Outline Offset</h3><p><code>outline-offset</code>属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。<br>轮廓与边框有两点不同：轮廓不占用空间、轮廓可能是非矩形</p>
<p>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123; <span class="attribute">border</span>:<span class="number">2px</span> solid black;</span><br><span class="line"><span class="attribute">outline</span>:<span class="number">2px</span> solid red;</span><br><span class="line"><span class="attribute">outline-offset</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新的用户界面属性："><a href="#新的用户界面属性：" class="headerlink" title="新的用户界面属性："></a>新的用户界面属性：</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">appearance 允许您将元素设置为标准用户界面元素的外观</span><br><span class="line"><span class="attribute">box-sizing</span> 允许您以确切的方式定义适应某个区域的具体内容。</span><br><span class="line"><span class="attribute">icon</span> 为创作者提供使用图标化等价物来设置元素样式的能力。</span><br><span class="line"><span class="attribute">nav-down</span> 规定在使用 arrow-down 导航键时向何处导航。</span><br><span class="line"><span class="attribute">nav-index</span> 设置元素的 tab 键控制次序。</span><br><span class="line"><span class="attribute">nav-left</span> 规定在使用 arrow-left 导航键时向何处导航。</span><br><span class="line"><span class="attribute">nav-right</span> 规定在使用 arrow-right 导航键时向何处导航。</span><br><span class="line"><span class="attribute">nav-up</span> 规定在使用 arrow-up 导航键时向何处导航。</span><br><span class="line"><span class="attribute">outline-offset</span> 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</span><br><span class="line"><span class="attribute">resize</span> 规定是否可由用户对元素的尺寸进行调整。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css笔记</title>
    <url>/2019/02/17/css%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3c网站参考连接</a></p>
<h2 id="CSS笔记"><a href="#CSS笔记" class="headerlink" title="CSS笔记"></a>CSS笔记</h2><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="CSS属性选择器"><a href="#CSS属性选择器" class="headerlink" title="CSS属性选择器"></a>CSS属性选择器</h3><p>找到相同属性值，例如有几个相同的字母或单词，把它们提炼出来作为相同的属性值。从而设置一个属性选择器。<br>一般常用的三个：</p>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">imag</span> <span class="attr">title</span>=<span class="string">”figure</span> <span class="attr">name</span>” <span class="attr">src</span>=<span class="string">”figure</span> <span class="attr">path</span>”&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">a</span> <span class="attr">href</span>=<span class="string">”https://your</span> <span class="attr">website</span> <span class="attr">path</span>”&gt;</span>website name<span class="tag">&lt; /<span class="attr">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span> <span class="attr">lang</span>=<span class="string">”en”</span>&gt;</span>your words<span class="tag">&lt; /<span class="attr">p</span>&gt;</span>(这个规则会选择lang属性等于等于en或者en-开头的所有元素)</span><br></pre></td></tr></table></figure>
<h3 id="CSS后代选择器"><a href="#CSS后代选择器" class="headerlink" title="CSS后代选择器"></a>CSS后代选择器</h3><p>我们可以定义一些后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另一些文档中不起作用。举例来说，如果我们希望只对h1元素中的em应用样式，我们可以这样写：<code>h1 em{color：red；}</code>该规则会把所有h1中的em元素变成红色，而其他em原色则不会改变。</p>
<h3 id="CSS子元素选择器"><a href="#CSS子元素选择器" class="headerlink" title="CSS子元素选择器"></a>CSS子元素选择器</h3><p>如果我们希望选择只作为h1元素子元素的strong元素，我们可以这样写：<code>h1&gt;strong{color：red；}</code><br>只有strong元素嵌套在h1元素中，才能有红色的属性展示，如果是在h1元素下的em元素中的strong元素则不会显示处红色样式。</p>
<h3 id="CSS相邻兄弟选择器"><a href="#CSS相邻兄弟选择器" class="headerlink" title="CSS相邻兄弟选择器"></a>CSS相邻兄弟选择器</h3><p>例如，如果要增加紧接在h1元素后出现的段落的上边距，可以这样写：<code>h1+p{margin-top：50px；}</code>这个选择器读作：”选择紧接在h1元素后出现的段落，，h1和p拥有共同的父元素“。只有h1紧接后面出现的第一个p元素会出现<code>margin-top：50px</code>，其余的p元素都不会出现<code>margin-top：50px</code>元素。</p>
<h2 id="CSS伪类"><a href="#CSS伪类" class="headerlink" title="CSS伪类"></a>CSS伪类</h2><p>设置超链接的颜色格式的时候，必须要有顺序：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">a：link&#123;<span class="keyword">color</span>：<span class="meta">#fffff&#125; 未被访问时候的格式</span></span><br><span class="line">a：visited&#123;<span class="keyword">color</span>：<span class="meta">#ffff&#125; 访问后的格式</span></span><br><span class="line">a：hover&#123;<span class="keyword">color</span>：<span class="meta">#ffff&#125; categories</span></span><br><span class="line">a：active&#123;<span class="keyword">color</span>：<span class="meta">#ffff&#125;</span></span><br></pre></td></tr></table></figure>
<p>定义的顺序只能按照上述顺序来定义，a：hover必须位于a：link和a：visited之后，a：active必须位于a：hover之后。</p>
<h2 id="CSS尺寸、字体和文本属性"><a href="#CSS尺寸、字体和文本属性" class="headerlink" title="CSS尺寸、字体和文本属性"></a>CSS尺寸、字体和文本属性</h2><h3 id="尺寸属性"><a href="#尺寸属性" class="headerlink" title="尺寸属性"></a>尺寸属性</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">line</span>-<span class="built_in">height</span>：设置行高</span><br><span class="line"><span class="built_in">max</span>-<span class="built_in">height</span>：设置元素的最大高度</span><br><span class="line"><span class="built_in">max</span>-<span class="built_in">width</span>：设置元素的最大宽度</span><br><span class="line"><span class="built_in">min</span>-<span class="built_in">height</span>：设置元素的最小高度</span><br><span class="line"><span class="built_in">min</span>-<span class="built_in">width</span>：设置元素的最小宽度</span><br><span class="line"><span class="built_in">width</span>：设置元素的宽度</span><br></pre></td></tr></table></figure>
<h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">font</span>：简写属性。作用是把所有针对字体的属性设置在一个声明中</span><br><span class="line"><span class="built_in">font</span>-family：设置字体系列</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">size</span>：设置字体尺寸</span><br><span class="line"><span class="built_in">font</span>-style：设置字体风格，斜体，加粗，以大写字母或者小写字母显示</span><br><span class="line"><span class="built_in">font</span>-weight：设置字体的粗细</span><br><span class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>：以小型大写字体或者正常字体显示文本</span><br></pre></td></tr></table></figure>
<h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>：设置文本颜色</span><br><span class="line"><span class="attribute">direction</span>：设置文本方向</span><br><span class="line"><span class="attribute">line-height</span>：设置行高</span><br><span class="line"><span class="attribute">letter-spacing</span>：设置字符间距</span><br><span class="line"><span class="attribute">text-align</span>：对齐文本（centre、<span class="attribute">left</span>、<span class="attribute">right</span>）</span><br><span class="line"><span class="attribute">text-decoration</span>：向文本添加修饰</span><br><span class="line"><span class="attribute">text-indent</span>：缩进元素中文本的首行</span><br><span class="line"><span class="attribute">text-shadow</span>：设置文本阴影</span><br><span class="line"><span class="attribute">text-transform</span>：控制元素中的字母</span><br><span class="line"><span class="attribute">unicode-bidi</span>：设置文本方向</span><br><span class="line"><span class="attribute">white-space</span>：设置元素中空白的处理方式</span><br><span class="line"><span class="attribute">word-spacing</span>：设置字间距</span><br></pre></td></tr></table></figure>
<h2 id="背景设置总结"><a href="#背景设置总结" class="headerlink" title="背景设置总结"></a>背景设置总结</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>：简写属性，将所有的背景属性放在一起</span><br><span class="line"><span class="built_in">background</span>-attachment：背景图像是否固定或着随着页面的其余部分滚动</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">color</span>：设置背景颜色</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">image</span>：将图像设置为背景</span><br><span class="line"><span class="built_in">background</span>-<span class="built_in">position</span>：设置背景开始的位置</span><br><span class="line"><span class="built_in">background</span>-repeat：设置图像背景是否重复</span><br></pre></td></tr></table></figure>
<h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-style：简写属性，将列表的所有属性都写在一起</span></span><br><span class="line"><span class="built_in">list-style-image：将图像设置为表项标志，表项前的圆点、方块会被替换成图片</span></span><br><span class="line"><span class="built_in">list-style-position：设置列表中列表项的位置，如：ul&#123;list-style-position：inside；&#125;会把无序表放在里面。inside：列表项目标放置在文本以内，且围绕文本根据标志对齐；outside：默认值，保持标志位于文本的左侧，列表项目标放置在文本外面，且围绕文本不根据标志对齐；inherit：规定应该从父元素继承list-style-position的属性值</span></span><br><span class="line"><span class="built_in">list-style-type：设置列表项标志的类型，用于标志前的图形。</span></span><br></pre></td></tr></table></figure>
<h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>：设置是否把表格边框合并为单一边框</span><br><span class="line"><span class="attribute">border-spacing</span>：设置分隔单元格边框的距离</span><br><span class="line"><span class="attribute">caption-side</span>：设置表格标题的位置</span><br><span class="line"><span class="attribute">empty-cells</span>：设置是否显示表格中的空单元格</span><br><span class="line"><span class="attribute">table-layout</span>：设置单元行、列的算法</span><br></pre></td></tr></table></figure>
<h2 id="轮廓、内边距、外边距、边框属性"><a href="#轮廓、内边距、外边距、边框属性" class="headerlink" title="轮廓、内边距、外边距、边框属性"></a>轮廓、内边距、外边距、边框属性</h2><p>内外边距具有合并的属性，取得是或的逻辑关系，且是大包小</p>
<h3 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">outline</span>：简写属性，在一个声明中简写所有的属性</span><br><span class="line"><span class="attribute">outline-color</span>：颜色属性</span><br><span class="line"><span class="attribute">outline-style</span>：设置轮廓的样式，solid、dotted、dashede</span><br><span class="line"><span class="attribute">outline-width</span>：设置轮廓宽度</span><br></pre></td></tr></table></figure>
<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">padding：简写属性，在一个声明中简写所有的属性</span><br><span class="line">padding-<span class="built_in">bottom</span>/<span class="built_in">left</span>/<span class="built_in">right</span>/<span class="built_in">top</span>：设置元素的下/左/右/上内边距</span><br></pre></td></tr></table></figure>
<h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">margin：简写属性，将所有的属性写在一个声明中</span><br><span class="line">margin-<span class="built_in">bottom</span>/<span class="built_in">left</span>/<span class="built_in">right</span>/<span class="built_in">top</span>：设置元素的下/左/右/上外边距</span><br></pre></td></tr></table></figure>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>：简写属性，将所有的属性写在一个声明中</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">style</span>：用于设置边框的所有样式，或者单独的为各边设置样式</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">width</span>：简写属性，用于为元素的所有边框设置宽度</span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>：简写属性，用于为元素的所有边框设置颜色</span><br><span class="line">borde-bottom/left/right/top：简写属性，用于设置下/左/右/上边框的所有属性</span><br><span class="line"><span class="built_in">border</span>-bottom/left/right/top-<span class="built_in">color</span>/<span class="built_in">style</span>/<span class="built_in">width</span>：分别设置下/左/右/上边框的颜色、样式和宽度</span><br></pre></td></tr></table></figure>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>：把元素放置到一个静态的、相对的、绝对的、或固定的位置上</span><br><span class="line"><span class="attribute">top</span>/right/left/bottom：定义了一个定位元素上边距边界与包含块上边界/右边距边界与包含块右边距边界/左边距边界与包含块左边距边界/下边距边界与下边距边界之间的偏移</span><br><span class="line"><span class="attribute">overflow</span>：设置当元素的内容溢出其区域时发生的事情</span><br><span class="line"><span class="attribute">clip</span>：设置元素的形状。元素被剪入这个形状中然后显示出来</span><br><span class="line"><span class="attribute">vertical-align</span>：设置元素的垂直对齐元素</span><br><span class="line"><span class="attribute">z-index</span>：设置元素的堆叠顺序</span><br><span class="line">relative：相对定位</span><br><span class="line">absolute：绝对定位</span><br><span class="line"><span class="attribute">float</span>：浮动</span><br><span class="line"><span class="attribute">visibility</span>：visible，元素可见；hidden，元素不可见。在表格中，如果想要一行元素或者一个元素不可见可在该对应的列标签中添加属性：visibility：collapse。该属性跟跟empty-cells属性的不同之处在于，该属性是把表格内有值的对应表格变为空，而empty-cells是把原来表格内的空元素对应隐藏起来，这两个最后的结果一样，但是针对的对象不同。用clear属性的时候，会清除该对象的两侧的东西，比如想把两张照片上下叠放而不左右叠放，就可以选择clear属性</span><br></pre></td></tr></table></figure>
<h2 id="分类属性"><a href="#分类属性" class="headerlink" title="分类属性"></a>分类属性</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">clear 设置一个元素的侧面是否允许其他的浮动元素。注意一定是侧面，针对侧面，譬如叠放诗歌</span><br><span class="line">cursor 规定当指向某元素之上时显示的指针类型。即当鼠标指向规定元素时光标改变成相应的设置特性，列举如下：</span><br><span class="line">default 默认光标（通常是一个箭头）</span><br><span class="line">auto 默认。浏览器设置的光标。</span><br><span class="line">crosshair 光标呈现为十字线。</span><br><span class="line">pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动</span><br><span class="line">e-resize 此光标指示矩形框的边缘可被向右（东）移动</span><br><span class="line"><span class="keyword">ne</span>-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东）</span><br><span class="line">nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西）</span><br><span class="line">n-resize 此光标指示矩形框的边缘可被向上（北）移动</span><br><span class="line">se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东）</span><br><span class="line">sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西）</span><br><span class="line">s-resize 此光标指示矩形框的边缘可被向下移动（南）</span><br><span class="line">w-resize 此光标指示矩形框的边缘可被向左移动（西）</span><br><span class="line">text 此光标指示文本</span><br><span class="line">wait 此光标指示程序正忙（通常是一只表或沙漏）</span><br><span class="line">help 此光标指示可用的帮助（通常是一个问号或一个气球）</span><br><span class="line"><span class="keyword">display</span> 设置是否及如何显示元素，列举如下：</span><br><span class="line">none 此元素不会被显示</span><br><span class="line">block 此元素将显示为块级元素，此元素前后会带有换行符</span><br><span class="line">inline 默认。此元素会被显示为内联元素，元素前后没有换行符</span><br><span class="line">inline-block 行内块元素。（CSS2<span class="number">.1</span> 新增的值）</span><br><span class="line">list-item 此元素会作为列表显示</span><br><span class="line">run-in 此元素会根据上下文作为块级元素或内联元素显示</span><br><span class="line">compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2<span class="number">.1</span> 中删除</span><br><span class="line">marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2<span class="number">.1</span> 中删除</span><br><span class="line"><span class="keyword">table</span> 此元素会作为块级表格来显示（类似 &lt; <span class="keyword">table</span>&gt;），表格前后带有换行符</span><br><span class="line">inline-<span class="keyword">table</span> 此元素会作为内联表格来显示（类似 &lt; <span class="keyword">table</span>&gt;），表格前后没有换行符</span><br><span class="line"><span class="keyword">table</span>-row-group 此元素会作为一个或多个行的分组来显示（类似<span class="comment"> &lt; tbody&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-header-group 此元素会作为一个或多个行的分组来显示（类似<span class="comment"> &lt; thead&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-footer-group 此元素会作为一个或多个行的分组来显示（类似<span class="comment"> &lt; tfoot&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-row 此元素会作为一个表格行显示（类似<span class="comment"> &lt; tr&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-column-group 此元素会作为一个或多个列的分组来显示（类似<span class="comment"> &lt; colgroup&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-column 此元素会作为一个单元格列显示（类似<span class="comment"> &lt; col&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-cell 此元素会作为一个表格单元格显示（类似<span class="comment"> &lt; td&gt;</span> 和<span class="comment"> &lt; th&gt;</span>）</span><br><span class="line"><span class="keyword">table</span>-caption 此元素会作为一个表格标题显示（类似<span class="comment"> &lt; caption&gt;</span>）</span><br><span class="line">inherit 规定应该从父元素继承 display 属性的值</span><br><span class="line">float 定义元素在哪个方向浮动</span><br><span class="line">position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中</span><br><span class="line">visibility 设置元素是否可见或不可见</span><br></pre></td></tr></table></figure>
<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p>导航栏=连接列表（链接+列表）//（一般列表去除前面的圆点（<code>list-style-type：none</code>设置）再设置一些外边距和内边距就可以生成一个简单的导航）<br>如果在上述的情况基础之下，再把&lt; a&gt;元素设置成一个块元素，如添加<code>display:block</code> ，就能把链接显示为块元素可使整个链接区域可点击（不仅仅是文本），同时也允许我们规定宽度。而上述情况下只能在文本区域内才能进行链接的点击和进入，但是把a元素设置以后，就可以在整个的块元素之内对应相应的链接也能点击！！</p>
<h3 id="垂直导航栏"><a href="#垂直导航栏" class="headerlink" title="垂直导航栏"></a>垂直导航栏</h3><p>可以用列表设置，如果是要垂直的导航栏的话，可以在&lt; a&gt;元素之间加一个<code>display：block</code>，块元素来把一块圈起来，然后在&lt; a&gt;元素中把该块的背景颜色和字体大小间距设置一下，再用link、visited、hover、active设置相应的颜色改变！！！就可以形成一个比较好看的导航栏</p>
<h3 id="水平导航栏"><a href="#水平导航栏" class="headerlink" title="水平导航栏"></a>水平导航栏</h3><p>有两种创建水平导航栏的方法。使用行内或浮动列表项。两种方法都不错，但是如果我们希望链接拥有相同的尺寸，就必须使用浮动方法<br>①行内列表项<br>构建水平导航栏的方法之一是将 &lt; li&gt; 元素规定为行内元素：<code>li{ display:inline;}</code><br>解释：<code>display:inline;</code> - 默认地，&lt; li&gt; 元素是块元素。在这里，我们去除了每个列表项前后的换行，以便让它们在一行中显示。如果要设置每个链接表的背景颜色，就还是需要在&lt; a&gt;元素里面去设置，在&lt; a&gt;元素里面设置背景颜色、字体颜色、字体风格、对齐方式、大小写以及padding，<br>注意：：不管是垂直还是水平导航栏，不仅需要在&lt; a&gt;元素里面设置padding，还需要在&lt; ul&gt;元素里面设置<code>margin、padding、padding-top、padding-bottom</code>属性，如果您只为 a 元素设置内边距（而不设置 ul 元素），那么链接会出现在 ul 元素之外。所以，我们为 ul 元素添加了 top 和 bottom 内边距。<br>注意：：把外边距和内边距设置为 0 可以去除浏览器的默认设定。<br>用该方法，链接的宽度是不同的。为了让所有链接拥有相等的宽度，浮动 &lt; li&gt; 元素并规定 &lt; a&gt; 元素的宽度：如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line">&#125;，</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">&#125; 解释：<span class="selector-tag">float</span><span class="selector-pseudo">:left</span> <span class="selector-tag">-</span> 使用 <span class="selector-tag">float</span> 来把块元素滑向彼此。</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:block</span> <span class="selector-tag">-</span> 把链接显示为块元素可使整个链接区域可点击（不仅仅是文本），同时也允许我们规定宽度。</span><br><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:60px</span> <span class="selector-tag">-</span> 由于块元素默认占用全部可用宽度，链接无法滑动至彼此相邻。我们需要规定 60 像素的宽度。</span><br></pre></td></tr></table></figure>
<h2 id="图像透明度"><a href="#图像透明度" class="headerlink" title="图像透明度"></a>图像透明度</h2><h3 id="创建透明图像"><a href="#创建透明图像" class="headerlink" title="创建透明图像"></a>创建透明图像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">opacity</span>:<span class="number">0.4</span>;</span><br><span class="line"><span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图像透明度-hover效果"><a href="#图像透明度-hover效果" class="headerlink" title="图像透明度-hover效果"></a>图像透明度-hover效果</h3><p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">img&#123;</span><br><span class="line"><span class="attribute">opacity</span>:<span class="number">0.4</span>;</span><br><span class="line"><span class="attribute">filter</span>:alpha(opacity=<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span>:hover</span><br><span class="line">&#123; <span class="attribute">opacity</span>:<span class="number">1.0</span>;</span><br><span class="line"><span class="attribute">filter</span>:alpha(opacity=<span class="number">100</span>);</span><br><span class="line">&#125; 第一个 CSS 代码块就是创建透明图像的代码。此外，我们已经设置了当鼠标指针位于图像上时的样式。在这个例子中，当指针移动到图像上时，我们希望图像是不透明的。</span><br><span class="line">对应的 CSS 是：<span class="attribute">opacity</span>=<span class="number">1</span>。当鼠标指针移出图像后，图像会再次透明。</span><br></pre></td></tr></table></figure>
<h2 id="透明框中的文本"><a href="#透明框中的文本" class="headerlink" title="透明框中的文本"></a>透明框中的文本</h2><p>首先，我们创建一个 div 元素 (c<code>lass=”background”</code>)，它有固定的高度和宽度、背景图像，以及边框。然后我们在第一个 div 内创建稍小的 div (<code>class=”transbox”</code>)。”transbox” div 有固定的宽度、背景色和边框 - 并且它是透明的。在透明 div 内部，我们在 p 元素中加入了一些文本。</p>
<h2 id="CSS媒介类型"><a href="#CSS媒介类型" class="headerlink" title="CSS媒介类型"></a>CSS媒介类型</h2><p>媒介类型(Media Types)允许你定义以何种媒介来提交文档。文档可以被显示在显示器、纸媒介或者听觉浏览器等等</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">all 用于所有的媒介设备。</span><br><span class="line">aural 用于语音和音频合成器。</span><br><span class="line">braille 用于盲人用点字法触觉回馈设备。</span><br><span class="line">embossed 用于分页的盲人用点字法打印机。</span><br><span class="line">handheld 用于小的手持的设备。</span><br><span class="line"><span class="builtin-name">print</span> 用于打印机。</span><br><span class="line">projection 用于方案展示，比如幻灯片。</span><br><span class="line">screen 用于电脑显示器。</span><br><span class="line">tty 用于使用固定密度字母栅格的媒介，比如电传打字机和终端。</span><br><span class="line">tv 用于电视机类型的设备。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML笔记</title>
    <url>/2019/02/15/HTML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3c网站参考连接</a></p>
<h2 id="HTML-DOM笔记"><a href="#HTML-DOM笔记" class="headerlink" title="HTML DOM笔记"></a>HTML DOM笔记</h2><h2 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h2><p>DOM 是 W3C（万维网联盟）的标准。<br>DOM 定义了访问 HTML 和 XML 文档的标准：<br>“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p>
<a id="more"></a>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">核心 DOM - 针对任何结构化文档的标准模型</span><br><span class="line"><span class="keyword">XML</span> <span class="title">DOM</span> - 针对 <span class="keyword">XML</span> <span class="title">文档的标准模型</span></span><br><span class="line"><span class="title">HTML</span> DOM - 针对 HTML 文档的标准模型</span><br></pre></td></tr></table></figure>
<h3 id="HTML-DOM-节点"><a href="#HTML-DOM-节点" class="headerlink" title="HTML DOM 节点"></a>HTML DOM 节点</h3><p>在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。</p>
<h4 id="1、DOM-节点"><a href="#1、DOM-节点" class="headerlink" title="1、DOM 节点"></a>1、DOM 节点</h4><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">整个文档是一个文档节点</span><br><span class="line">每个 <span class="built_in">HTML</span> 元素是元素节点</span><br><span class="line"><span class="built_in">HTML</span> 元素内的文本是文本节点</span><br><span class="line">每个 <span class="built_in">HTML</span> 属性是属性节点</span><br><span class="line">注释是注释节点</span><br></pre></td></tr></table></figure>
<h4 id="2、HTML-DOM-节点树"><a href="#2、HTML-DOM-节点树" class="headerlink" title="2、HTML DOM 节点树"></a>2、HTML DOM 节点树</h4><p>HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点<br>通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。</p>
<h4 id="3、节点父、子和同胞"><a href="#3、节点父、子和同胞" class="headerlink" title="3、节点父、子和同胞"></a>3、节点父、子和同胞</h4><p>节点树中的节点彼此拥有层级关系。<br>父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。<br>在节点树中，顶端节点被称为根（root）<br>每个节点都有父节点、除了根（它没有父节点）<br>一个节点可拥有任意数量的子<br>同胞是拥有相同父节点的节点</p>
<h3 id="HTML-DOM-方法"><a href="#HTML-DOM-方法" class="headerlink" title="HTML DOM 方法"></a>HTML DOM 方法</h3><p>方法是我们可以在节点（HTML 元素）上执行的动作。</p>
<h4 id="1、编程接口"><a href="#1、编程接口" class="headerlink" title="1、编程接口"></a>1、编程接口</h4><p>可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。</p>
<p>所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。</p>
<p>方法是我们能够执行的动作（比如添加或修改元素）。</p>
<p>属性是我们能够获取或设置的值（比如节点的名称或内容）。</p>
<h4 id="2、getElementById-方法"><a href="#2、getElementById-方法" class="headerlink" title="2、getElementById() 方法"></a>2、getElementById() 方法</h4><p>getElementById() 方法返回带有指定 ID 的元素：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.getElementById(“intro”);</span><br></pre></td></tr></table></figure>
<h4 id="3、HTML-DOM-对象-方法和属性"><a href="#3、HTML-DOM-对象-方法和属性" class="headerlink" title="3、HTML DOM 对象 - 方法和属性"></a>3、HTML DOM 对象 - 方法和属性</h4><p>一些常用的 HTML DOM 方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getElementById</span><span class="params">(id)</span></span> - 获取带有指定 id 的节点（元素）</span><br><span class="line"><span class="function"><span class="title">appendChild</span><span class="params">(node)</span></span> - 插入新的子节点（元素）</span><br><span class="line"><span class="function"><span class="title">removeChild</span><span class="params">(node)</span></span> - 删除子节点（元素）</span><br></pre></td></tr></table></figure>
<p>一些常用的 HTML DOM 属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">innerHTML</span> <span class="string">- 节点（元素）的文本值</span></span><br><span class="line"><span class="attr">parentNode</span> <span class="string">- 节点（元素）的父节点</span></span><br><span class="line"><span class="attr">childNodes</span> <span class="string">- 节点（元素）的子节点</span></span><br><span class="line"><span class="attr">attributes</span> <span class="string">- 节点（元素）的属性节点</span></span><br></pre></td></tr></table></figure>
<h4 id="4、一些-DOM-对象方法"><a href="#4、一些-DOM-对象方法" class="headerlink" title="4、一些 DOM 对象方法"></a>4、一些 DOM 对象方法</h4><p>getElementById() 返回带有指定 ID 的元素。<br>getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。<br>getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。<br>appendChild() 把新的子节点添加到指定节点。<br>removeChild() 删除子节点。<br>replaceChild() 替换子节点。<br>insertBefore() 在指定的子节点前面插入新的子节点。<br>createAttribute() 创建属性节点。<br>createElement() 创建元素节点。<br>createTextNode() 创建文本节点。<br>getAttribute() 返回指定的属性值。<br>setAttribute() 把指定属性设置或修改为指定的值。</p>
<h3 id="HTML-DOM-属性"><a href="#HTML-DOM-属性" class="headerlink" title="HTML DOM 属性"></a>HTML DOM 属性</h3><h4 id="1、编程接口-1"><a href="#1、编程接口-1" class="headerlink" title="1、编程接口"></a>1、编程接口</h4><p>可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。<br>所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。<br>方法是我们能够执行的动作（比如添加或修改元素）。<br>属性是我们能够获取或设置的值（比如节点的名称或内容）。</p>
<h4 id="2、innerHTML-属性"><a href="#2、innerHTML-属性" class="headerlink" title="2、innerHTML 属性"></a>2、innerHTML 属性</h4><p>获取元素内容的最简单方法是使用 innerHTML 属性。<br>innerHTML 属性对于获取或替换 HTML 元素的内容很有用。</p>
<h4 id="3、nodeName-属性"><a href="#3、nodeName-属性" class="headerlink" title="3、nodeName 属性"></a>3、nodeName 属性</h4><p>nodeName 属性规定节点的名称。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">nodeName 是只读的</span><br><span class="line">元素节点的 nodeName 与标签名相同</span><br><span class="line">属性节点的 nodeName 与属性名相同</span><br><span class="line">文本节点的 nodeName 始终是 <span class="comment">#text</span></span><br><span class="line">文档节点的 nodeName 始终是 <span class="comment">#document</span></span><br><span class="line">注释：nodeName 始终包含 <span class="built_in">HTML</span> 元素的大写字母标签名。</span><br></pre></td></tr></table></figure>
<h4 id="4、nodeValue-属性"><a href="#4、nodeValue-属性" class="headerlink" title="4、nodeValue 属性"></a>4、nodeValue 属性</h4><p>nodeValue 属性规定节点的值。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">元素节点的 nodeValue 是 <span class="literal">undefined</span> 或 <span class="literal">null</span></span><br><span class="line">文本节点的 nodeValue 是文本本身</span><br><span class="line">属性节点的 nodeValue 是属性值</span><br></pre></td></tr></table></figure>
<h3 id="HTML-DOM-访问"><a href="#HTML-DOM-访问" class="headerlink" title="HTML DOM 访问"></a>HTML DOM 访问</h3><h4 id="1、访问-HTML-元素（节点）"><a href="#1、访问-HTML-元素（节点）" class="headerlink" title="1、访问 HTML 元素（节点）"></a>1、访问 HTML 元素（节点）</h4><p>访问 HTML 元素等同于访问节点</p>
<p>我们能够以不同的方式来访问 HTML 元素：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">通过使用 <span class="function"><span class="title">getElementById</span>() 方法</span></span><br><span class="line"><span class="function">通过使用 <span class="title">getElementsByTagName</span>() 方法</span></span><br><span class="line"><span class="function">通过使用 <span class="title">getElementsByClassName</span>() 方法</span></span><br></pre></td></tr></table></figure>
<h4 id="2、getElementById-方法-1"><a href="#2、getElementById-方法-1" class="headerlink" title="2、getElementById() 方法"></a>2、getElementById() 方法</h4><p>getElementById() 方法返回带有指定 ID 的元素：</p>
<p>语法</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>.<span class="title">getElementById</span>(“id”);</span><br></pre></td></tr></table></figure>
<p>下面的例子获取 id=”intro” 的元素：<br>例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">document.get<span class="constructor">ElementById(“<span class="params">intro</span>”)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3、getElementsByTagName-方法"><a href="#3、getElementsByTagName-方法" class="headerlink" title="3、getElementsByTagName() 方法"></a>3、getElementsByTagName() 方法</h4><p>getElementsByTagName() 返回带有指定标签名的所有元素。</p>
<p>语法<code>node.getElementsByTagName(“tagname”);</code><br>下面的例子返回包含文档中所有</p>
<p>元素的列表：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">实例 <span class="number">1</span></span><br><span class="line">document.get<span class="constructor">ElementsByTagName(“<span class="params">p</span>”)</span>;</span><br><span class="line">面的例子返回包含文档中所有</span><br><span class="line">元素的列表，并且这些元素应该是 id=”main” 的元素的后代（子、孙等等）：</span><br><span class="line"></span><br><span class="line">实例 <span class="number">2</span></span><br><span class="line">document.get<span class="constructor">ElementById(“<span class="params">main</span>”)</span>.getElementsByTagName</span><br></pre></td></tr></table></figure>
<h4 id="4、getElementsByClassName-方法"><a href="#4、getElementsByClassName-方法" class="headerlink" title="4、getElementsByClassName() 方法"></a>4、getElementsByClassName() 方法</h4><p>如果我们希望查找带有相同类名的所有 HTML 元素，请使用这个方法：<code>document.getElementsByClassName(“intro”);</code></p>
<h3 id="HTML-DOM-修改"><a href="#HTML-DOM-修改" class="headerlink" title="HTML DOM - 修改"></a>HTML DOM - 修改</h3><p>修改 HTML = 改变元素、属性、样式和事件。</p>
<h4 id="1、修改-HTML-元素"><a href="#1、修改-HTML-元素" class="headerlink" title="1、修改 HTML 元素"></a>1、修改 HTML 元素</h4><p>修改 HTML DOM 意味着许多不同的方面：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">改变 <span class="built_in">HTML</span> 内容</span><br><span class="line">改变 CSS 样式</span><br><span class="line">改变 <span class="built_in">HTML</span> 属性</span><br><span class="line">创建新的 <span class="built_in">HTML</span> 元素</span><br><span class="line">删除已有的 <span class="built_in">HTML</span> 元素</span><br><span class="line">改变事件（处理程序）</span><br></pre></td></tr></table></figure>
<h4 id="2、创建-HTML-内容"><a href="#2、创建-HTML-内容" class="headerlink" title="2、创建 HTML 内容"></a>2、创建 HTML 内容</h4><p>改变元素内容的最简答的方法是使用 innerHTML 属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">p</span> <span class="attr">id</span>=<span class="string">”p1”</span>&gt;</span>Hello World!<span class="tag">&lt;/ <span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">script</span>&gt;</span></span><br><span class="line">document.getElementById(“p1”).innerHTML=”New text!”;</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3、改变-HTML-样式"><a href="#3、改变-HTML-样式" class="headerlink" title="3、改变 HTML 样式"></a>3、改变 HTML 样式</h4><p>通过 HTML DOM，您能够访问 HTML 元素的样式对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">p</span> <span class="attr">id</span>=<span class="string">”p2”</span>&gt;</span>Hello world!<span class="tag">&lt; /<span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">script</span>&gt;</span></span><br><span class="line">document.getElementById(“p2”).style.color=”blue”;</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4、创建新的-HTML-元素"><a href="#4、创建新的-HTML-元素" class="headerlink" title="4、创建新的 HTML 元素"></a>4、创建新的 HTML 元素</h4><p>如需向 HTML DOM 添加新元素，您首先必须创建该元素（元素节点），然后把它追加到已有的元素上。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">&lt; div<span class="built_in"> id</span>=”d1”&gt;</span><br><span class="line">&lt; p<span class="built_in"> id</span>=”p1”&gt;This <span class="literal">is</span> a paragraph.&lt; /p&gt;</span><br><span class="line">&lt; p<span class="built_in"> id</span>=”p2”&gt;This <span class="literal">is</span> another paragraph.&lt;/ p&gt;</span><br><span class="line">&lt;/ div&gt;</span><br><span class="line"></span><br><span class="line">&lt; script&gt;</span><br><span class="line">var para<span class="built_in">=document</span>.createElement(“p”);</span><br><span class="line">var <span class="type">node</span><span class="built_in">=document</span>.createTextNode(“This <span class="literal">is</span> new.”);</span><br><span class="line">para.appendChild(<span class="type">node</span>);</span><br><span class="line"></span><br><span class="line">var <span class="keyword">element</span>=<span class="keyword">document</span>.getElementById(“d1”);</span><br><span class="line"><span class="keyword">element</span>.appendChild(para);</span><br><span class="line">&lt;/ script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="HTML-DOM-修改-HTML-内容"><a href="#HTML-DOM-修改-HTML-内容" class="headerlink" title="HTML DOM - 修改 HTML 内容"></a>HTML DOM - 修改 HTML 内容</h3><h4 id="1、改变-HTML-内容"><a href="#1、改变-HTML-内容" class="headerlink" title="1、改变 HTML 内容"></a>1、改变 HTML 内容</h4><p>改变元素内容的最简单的方法是使用 innerHTML 属性。</p>
<h4 id="2、改变-HTML-样式"><a href="#2、改变-HTML-样式" class="headerlink" title="2、改变 HTML 样式"></a>2、改变 HTML 样式</h4><p>通过 HTML DOM，您能够访问 HTML 对象的样式对象。</p>
<h4 id="3、使用事件"><a href="#3、使用事件" class="headerlink" title="3、使用事件"></a>3、使用事件</h4><p>HTML DOM 允许您在事件发生时执行代码。</p>
<p>当 HTML 元素”有事情发生“时，浏览器就会生成事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在元素上点击</span><br><span class="line">加载页面</span><br><span class="line">改变输入字段</span><br></pre></td></tr></table></figure>
<p>下面两个例子在按钮被点击时改变 &lt; body&gt; 元素的背景色：</p>
<p>实例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">input</span> <span class="attr">type</span>=<span class="string">”button”</span> <span class="attr">onclick</span>=<span class="string">”document.body.style.backgroundColor</span>=<span class="string">’lavender’;”</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">”Change</span> <span class="attr">background</span> <span class="attr">color</span>” /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HTML-DOM-元素"><a href="#HTML-DOM-元素" class="headerlink" title="HTML DOM - 元素"></a>HTML DOM - 元素</h3><h4 id="1、创建新的-HTML-元素-appendChild"><a href="#1、创建新的-HTML-元素-appendChild" class="headerlink" title="1、创建新的 HTML 元素 - appendChild()"></a>1、创建新的 HTML 元素 - appendChild()</h4><p>如需向 HTML DOM 添加新元素，您首先必须创建该元素，然后把它追加到已有的元素上。</p>
<h4 id="2、创建新的-HTML-元素-insertBefore"><a href="#2、创建新的-HTML-元素-insertBefore" class="headerlink" title="2、创建新的 HTML 元素 - insertBefore()"></a>2、创建新的 HTML 元素 - insertBefore()</h4><p>上一个例子中的 appendChild() 方法，将新元素作为父元素的最后一个子元素进行添加。<br>如果不希望如此，您可以使用 insertBefore() 方法：</p>
<h4 id="3、删除已有的-HTML-元素"><a href="#3、删除已有的-HTML-元素" class="headerlink" title="3、删除已有的 HTML 元素"></a>3、删除已有的 HTML 元素</h4><p>如需删除 HTML 元素，您必须清楚该元素的父元素：</p>
<h4 id="4、替换-HTML-元素"><a href="#4、替换-HTML-元素" class="headerlink" title="4、替换 HTML 元素"></a>4、替换 HTML 元素</h4><p>如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：</p>
<h3 id="HTML-DOM-事件"><a href="#HTML-DOM-事件" class="headerlink" title="HTML DOM - 事件"></a>HTML DOM - 事件</h3><h4 id="1、对事件作出反应"><a href="#1、对事件作出反应" class="headerlink" title="1、对事件作出反应"></a>1、对事件作出反应</h4><p>当事件发生时，可以执行 JavaScript，比如当用户点击一个 HTML 元素时。</p>
<p>如需在用户点击某个元素时执行代码，请把 JavaScript 代码添加到 HTML 事件属性中：</p>
<p>onclick=JavaScript<br>HTML 事件的例子：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">当用户点击鼠标时</span><br><span class="line">当网页已加载时</span><br><span class="line">当图片已加载时</span><br><span class="line">当鼠标移动到元素上时</span><br><span class="line">当输入字段被改变时</span><br><span class="line">当 <span class="built_in">HTML</span> 表单被提交时</span><br><span class="line">当用户触发按键时</span><br></pre></td></tr></table></figure>
<h4 id="2、HTML-事件属性"><a href="#2、HTML-事件属性" class="headerlink" title="2、HTML 事件属性"></a>2、HTML 事件属性</h4><p>如需向 HTML 元素分配事件，您可以使用事件属性。</p>
<p>实例<br>向 button 元素分配一个 onclick 事件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">button</span> <span class="attr">onclick</span>=<span class="string">”displayDate()”</span>&gt;</span>试一试<span class="tag">&lt;/ <span class="attr">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3、使用-HTML-DOM-来分配事件"><a href="#3、使用-HTML-DOM-来分配事件" class="headerlink" title="3、使用 HTML DOM 来分配事件"></a>3、使用 HTML DOM 来分配事件</h4><p>HTML DOM 允许您使用 JavaScript 向 HTML 元素分配事件：</p>
<p>实例<br>为 button 元素分配 onclick 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt; script&gt;</span><br><span class="line"><span class="built_in">document</span>.getElementById(“myBtn”).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;displayDate()&#125;;</span><br><span class="line">&lt;<span class="regexp">/ script&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4、onload-和-onunload-事件"><a href="#4、onload-和-onunload-事件" class="headerlink" title="4、onload 和 onunload 事件"></a>4、onload 和 onunload 事件</h4><p>当用户进入或离开页面时，会触发 onload 和 onunload 事件。<br>onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页。<br>onload 和 onunload 事件可用于处理 cookies。<br>实例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">body</span> <span class="attr">onload</span>=<span class="string">”checkCookies()”</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5、onchange-事件"><a href="#5、onchange-事件" class="headerlink" title="5、onchange 事件"></a>5、onchange 事件</h4><p>onchange 事件常用于输入字段的验证。<br>下面的例子展示了如何使用 onchange。当用户改变输入字段的内容时，将调用 upperCase() 函数。<br>实例<code>&lt; input type=”text” id=”fname” onchange=”upperCase()”&gt;</code></p>
<h4 id="6、onmouseover-和-onmouseout-事件"><a href="#6、onmouseover-和-onmouseout-事件" class="headerlink" title="6、onmouseover 和 onmouseout 事件"></a>6、onmouseover 和 onmouseout 事件</h4><p>onmouseover 和 onmouseout 事件可用于在鼠标指针移动到或离开元素时触发函数</p>
<h4 id="7、onmousedown、onmouseup-以及-onclick-事件"><a href="#7、onmousedown、onmouseup-以及-onclick-事件" class="headerlink" title="7、onmousedown、onmouseup 以及 onclick 事件"></a>7、onmousedown、onmouseup 以及 onclick 事件</h4><p>onmousedown、onmouseup 以及 onclick 事件是鼠标点击的全部过程。首先当某个鼠标按钮被点击时，触发 onmousedown 事件，然后，当鼠标按钮被松开时，会触发 onmouseup 事件，最后，当鼠标点击完成时，触发 onclick 事件。</p>
<h3 id="HTML-DOM-导航"><a href="#HTML-DOM-导航" class="headerlink" title="HTML DOM - 导航"></a>HTML DOM - 导航</h3><p>通过 HTML DOM，我们能够使用节点关系在节点树中导航。</p>
<h4 id="1、HTML-DOM-节点列表"><a href="#1、HTML-DOM-节点列表" class="headerlink" title="1、HTML DOM 节点列表"></a>1、HTML DOM 节点列表</h4><p>getElementsByTagName() 方法返回节点列表。节点列表是一个节点数组。下面的代码选取文档中的所有 &lt; p&gt; 节点：<br>实例<code>var x=document.getElementsByTagName(“p”);</code><br>可以通过下标号访问这些节点。如需访问第二个 &lt; p&gt;，我们可以这么写：<code>y=x[1];</code>注释：下标号从 0 开始。</p>
<h4 id="2、HTML-DOM-节点列表长度"><a href="#2、HTML-DOM-节点列表长度" class="headerlink" title="2、HTML DOM 节点列表长度"></a>2、HTML DOM 节点列表长度</h4><p>length 属性定义节点列表中节点的数量。<br>我们可以使用 length 属性来循环节点列表：<br>实例</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">x</span>=document.getElementsByTagName(“p”)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for (i=<span class="number">0</span><span class="comment">;i&lt; x.length;i++)</span></span><br><span class="line">&#123; document.write(x[i].innerHTML)<span class="comment">;</span></span><br><span class="line">document.write(“&lt; br /&gt;”)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取所有 &lt; p&gt; 元素节点输出每个 &lt; p&gt; 元素的文本节点的值</p>
<h4 id="3、导航节点关系"><a href="#3、导航节点关系" class="headerlink" title="3、导航节点关系"></a>3、导航节点关系</h4><p>我们能够使用三个节点属性：parentNode、firstChild 以及 lastChild ，在文档结构中进行导航。<br>请看下面的 HTML 片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>Hello World!<span class="tag">&lt; /<span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>DOM 很有用!<span class="tag">&lt; /<span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>本例演示节点关系。<span class="tag">&lt;/ <span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; /<span class="attr">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首个 &lt; p&gt; 元素是 &lt; body&gt; 元素的首个子元素（firstChild）&lt; div&gt; 元素是 &lt; body&gt;元素的最后一个子元素（lastChild）&lt; body&gt; 元素是首个 &lt; p&gt; 元素和 &lt; div&gt; 元素的父节点（parentNode）</p>
<h4 id="4、DOM-根节点"><a href="#4、DOM-根节点" class="headerlink" title="4、DOM 根节点"></a>4、DOM 根节点</h4><p>这里有两个特殊的属性，可以访问全部文档：<br>document.documentElement - 全部文档<br>document.body - 文档的主体<br>实例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>Hello World!<span class="tag">&lt;/ <span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>DOM 很有用!<span class="tag">&lt;/ <span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">p</span>&gt;</span>本例演示 <span class="tag">&lt; <span class="attr">b</span>&gt;</span>document.body<span class="tag">&lt;/ <span class="attr">b</span>&gt;</span> 属性。<span class="tag">&lt; /<span class="attr">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">script</span>&gt;</span></span><br><span class="line">alert(document.body.innerHTML);</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/ <span class="attr">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5、childNodes-和-nodeValue"><a href="#5、childNodes-和-nodeValue" class="headerlink" title="5、childNodes 和 nodeValue"></a>5、childNodes 和 nodeValue</h4><p>除了 innerHTML 属性，我们也可以使用 childNodes 和 nodeValue 属性来获取元素的内容。</p>
]]></content>
      <categories>
        <category>Web 前端</category>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>HTML DOM</tag>
      </tags>
  </entry>
</search>
